
c:/Users/kevro/EE1301/BigP/target/2.3.0/photon/BigP.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .dynalib      00000004  080a0018  080a0018  00010018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00003234  080a001c  080a001c  0001001c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .backup       00000004  40024000  080a3250  00014000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         0000007c  20000000  080a3254  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          000005cc  2000007c  2000007c  0003007c  2**2
                  ALLOC
  6 .module_info_suffix 00000028  080a32d0  080a32d0  000232d0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .module_info_crc 00000004  080a32f8  080a32f8  000232f8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_info   00124184  00000000  00000000  000232fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00015683  00000000  00000000  00147480  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0001c7ec  00000000  00000000  0015cb03  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00002108  00000000  00000000  001792ef  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00005490  00000000  00000000  0017b3f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00027fbf  00000000  00000000  00180887  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0002f9e4  00000000  00000000  001a8846  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000b300c  00000000  00000000  001d822a  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00005620  00000000  00000000  0028b238  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <link_dynalib_end+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <link_dynalib_end+0x2c>)
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}
    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <link_dynalib_end+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f002 fe10 	bl	80a2c52 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <link_dynalib_end+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <link_dynalib_end+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f002 fe18 	bl	80a2c6e <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <link_dynalib_end+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000000 	.word	0x20000000
 80a0048:	080a3254 	.word	0x080a3254
 80a004c:	2000007c 	.word	0x2000007c
 80a0050:	2000007c 	.word	0x2000007c
 80a0054:	20000645 	.word	0x20000645
 80a0058:	20000645 	.word	0x20000645

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f001 ff5b 	bl	80a1f18 <module_user_init_hook>

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0062:	2500      	movs	r5, #0
 80a0064:	4e05      	ldr	r6, [pc, #20]	; (80a007c <module_user_init+0x20>)
 80a0066:	4c06      	ldr	r4, [pc, #24]	; (80a0080 <module_user_init+0x24>)
 80a0068:	1ba4      	subs	r4, r4, r6
 80a006a:	08a4      	lsrs	r4, r4, #2
 80a006c:	42a5      	cmp	r5, r4
 80a006e:	d100      	bne.n	80a0072 <module_user_init+0x16>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a0070:	bd70      	pop	{r4, r5, r6, pc}
        link_constructors_location[ctor_num]();
 80a0072:	f856 3b04 	ldr.w	r3, [r6], #4
 80a0076:	4798      	blx	r3
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f7      	b.n	80a006c <module_user_init+0x10>
 80a007c:	080a3220 	.word	0x080a3220
 80a0080:	080a3244 	.word	0x080a3244

080a0084 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0084:	f000 b818 	b.w	80a00b8 <setup>

080a0088 <module_user_loop>:
}

void module_user_loop() {
 80a0088:	b508      	push	{r3, lr}
    loop();
 80a008a:	f000 f86d 	bl	80a0168 <loop>
    _post_loop();
}
 80a008e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _post_loop();
 80a0092:	f001 bef9 	b.w	80a1e88 <_post_loop>

080a0096 <_Znwj>:
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size)
{
	return malloc(size);
 80a0096:	f001 bca5 	b.w	80a19e4 <malloc>

080a009a <_Znaj>:
 80a009a:	f001 bca3 	b.w	80a19e4 <malloc>

080a009e <_ZdlPv>:
	return malloc(size);
}

void operator delete(void *p)
{
	free(p);
 80a009e:	f001 bca9 	b.w	80a19f4 <free>

080a00a2 <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a00a2:	7800      	ldrb	r0, [r0, #0]
 80a00a4:	fab0 f080 	clz	r0, r0
 80a00a8:	0940      	lsrs	r0, r0, #5
 80a00aa:	4770      	bx	lr

080a00ac <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00ac:	2301      	movs	r3, #1
 80a00ae:	7003      	strb	r3, [r0, #0]
 80a00b0:	4770      	bx	lr

080a00b2 <_ZN10CloudClass22update_string_variableEPKc18Spark_Data_TypeDefPKvPv>:

    static const void* update_string_variable(const char* name, Spark_Data_TypeDef type, const void* var, void* reserved)
    {
        const String* s = (const String*)var;
        return s->c_str();
    }
 80a00b2:	6810      	ldr	r0, [r2, #0]
 80a00b4:	4770      	bx	lr
	...

080a00b8 <setup>:
int data0;
int sinceLastPub;
String strTemp;
int output;
void setup()
{
 80a00b8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  Serial.begin(9600);
 80a00ba:	f002 faf3 	bl	80a26a4 <_Z16_fetch_usbserialv>
 80a00be:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a00c2:	f002 fad5 	bl	80a2670 <_ZN9USBSerial5beginEl>
  pinMode(D7, OUTPUT);
 80a00c6:	2101      	movs	r1, #1
 80a00c8:	2007      	movs	r0, #7
 80a00ca:	f002 fd23 	bl	80a2b14 <pinMode>
        return register_function(call_raw_user_function, (void*)func, funcKey);
 80a00ce:	4a12      	ldr	r2, [pc, #72]	; (80a0118 <setup+0x60>)
 80a00d0:	4912      	ldr	r1, [pc, #72]	; (80a011c <setup+0x64>)
 80a00d2:	4813      	ldr	r0, [pc, #76]	; (80a0120 <setup+0x68>)
 80a00d4:	f001 ffad 	bl	80a2032 <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
        spark_variable_t extra = {};
 80a00d8:	2400      	movs	r4, #0
        extra.size = sizeof(extra);
 80a00da:	230c      	movs	r3, #12
        spark_variable_t extra = {};
 80a00dc:	9401      	str	r4, [sp, #4]
        extra.size = sizeof(extra);
 80a00de:	f8ad 3004 	strh.w	r3, [sp, #4]
        extra.update = update_string_variable;
 80a00e2:	4b10      	ldr	r3, [pc, #64]	; (80a0124 <setup+0x6c>)
        return spark_variable(varKey, userVar, CloudVariableTypeString::TYPE_ID, &extra);
 80a00e4:	2204      	movs	r2, #4
        extra.update = update_string_variable;
 80a00e6:	9302      	str	r3, [sp, #8]
        return spark_variable(varKey, userVar, CloudVariableTypeString::TYPE_ID, &extra);
 80a00e8:	490f      	ldr	r1, [pc, #60]	; (80a0128 <setup+0x70>)
 80a00ea:	ab01      	add	r3, sp, #4
 80a00ec:	480f      	ldr	r0, [pc, #60]	; (80a012c <setup+0x74>)
        spark_variable_t extra = {};
 80a00ee:	9403      	str	r4, [sp, #12]
        return spark_variable(varKey, userVar, CloudVariableTypeString::TYPE_ID, &extra);
 80a00f0:	f001 fc50 	bl	80a1994 <spark_variable>
        return spark_variable(varKey, (const void*)userVar, T::TYPE_ID, NULL);
 80a00f4:	4623      	mov	r3, r4
 80a00f6:	2202      	movs	r2, #2
 80a00f8:	490d      	ldr	r1, [pc, #52]	; (80a0130 <setup+0x78>)
 80a00fa:	480e      	ldr	r0, [pc, #56]	; (80a0134 <setup+0x7c>)
 80a00fc:	f001 fc4a 	bl	80a1994 <spark_variable>
  Particle.function("set_temp", setModeFromString);
  Particle.variable("current_temp", strTemp);
  Particle.variable("desired_temp", output);
  Serial.begin(9600);
 80a0100:	f002 fad0 	bl	80a26a4 <_Z16_fetch_usbserialv>
 80a0104:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a0108:	f002 fab2 	bl	80a2670 <_ZN9USBSerial5beginEl>
  strip.begin();
 80a010c:	480a      	ldr	r0, [pc, #40]	; (80a0138 <setup+0x80>)
 80a010e:	f000 f953 	bl	80a03b8 <_ZN17Adafruit_NeoPixel5beginEv>
}
 80a0112:	b004      	add	sp, #16
 80a0114:	bd10      	pop	{r4, pc}
 80a0116:	bf00      	nop
 80a0118:	080a2f20 	.word	0x080a2f20
 80a011c:	080a01f5 	.word	0x080a01f5
 80a0120:	080a2007 	.word	0x080a2007
 80a0124:	080a00b3 	.word	0x080a00b3
 80a0128:	200000ac 	.word	0x200000ac
 80a012c:	080a2f29 	.word	0x080a2f29
 80a0130:	20000094 	.word	0x20000094
 80a0134:	080a2f36 	.word	0x080a2f36
 80a0138:	200000bc 	.word	0x200000bc

080a013c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
 80a013c:	b538      	push	{r3, r4, r5, lr}
      {
	if (_M_pi != nullptr)
 80a013e:	6804      	ldr	r4, [r0, #0]
      ~__shared_count() noexcept
 80a0140:	4605      	mov	r5, r0
	if (_M_pi != nullptr)
 80a0142:	b17c      	cbz	r4, 80a0164 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
      if (--_M_use_count == 0)
 80a0144:	6863      	ldr	r3, [r4, #4]
 80a0146:	3b01      	subs	r3, #1
 80a0148:	6063      	str	r3, [r4, #4]
 80a014a:	b95b      	cbnz	r3, 80a0164 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
          _M_dispose();
 80a014c:	6823      	ldr	r3, [r4, #0]
 80a014e:	4620      	mov	r0, r4
 80a0150:	689b      	ldr	r3, [r3, #8]
 80a0152:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a0154:	68a3      	ldr	r3, [r4, #8]
 80a0156:	3b01      	subs	r3, #1
 80a0158:	60a3      	str	r3, [r4, #8]
 80a015a:	b91b      	cbnz	r3, 80a0164 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
            _M_destroy();
 80a015c:	6823      	ldr	r3, [r4, #0]
 80a015e:	4620      	mov	r0, r4
 80a0160:	68db      	ldr	r3, [r3, #12]
 80a0162:	4798      	blx	r3
	  _M_pi->_M_release();
      }
 80a0164:	4628      	mov	r0, r5
 80a0166:	bd38      	pop	{r3, r4, r5, pc}

080a0168 <loop>:
 
void loop() {
 80a0168:	b530      	push	{r4, r5, lr}
  digitalWrite(D7, HIGH);
 80a016a:	2101      	movs	r1, #1
void loop() {
 80a016c:	b087      	sub	sp, #28
  digitalWrite(D7, HIGH);
 80a016e:	2007      	movs	r0, #7
 80a0170:	f002 fce1 	bl	80a2b36 <digitalWrite>
   data0 = analogRead(A0);
 80a0174:	200a      	movs	r0, #10
 80a0176:	f002 fcf7 	bl	80a2b68 <analogRead>
   strTemp = String( (data0 -620) /45);
 80a017a:	212d      	movs	r1, #45	; 0x2d
   data0 = analogRead(A0);
 80a017c:	4b18      	ldr	r3, [pc, #96]	; (80a01e0 <loop+0x78>)
   strTemp = String( (data0 -620) /45);
 80a017e:	4d19      	ldr	r5, [pc, #100]	; (80a01e4 <loop+0x7c>)
   data0 = analogRead(A0);
 80a0180:	6018      	str	r0, [r3, #0]
   strTemp = String( (data0 -620) /45);
 80a0182:	f5a0 701b 	sub.w	r0, r0, #620	; 0x26c
 80a0186:	220a      	movs	r2, #10
 80a0188:	fb90 f1f1 	sdiv	r1, r0, r1
 80a018c:	a802      	add	r0, sp, #8
 80a018e:	f001 fd78 	bl	80a1c82 <_ZN6StringC1Eih>
 80a0192:	a902      	add	r1, sp, #8
 80a0194:	4628      	mov	r0, r5
 80a0196:	f001 fd5b 	bl	80a1c50 <_ZN6StringaSEOS_>
  //  Serial.println(data0);
  delay(1000);
  if (sinceLastPub > 80){
 80a019a:	4c13      	ldr	r4, [pc, #76]	; (80a01e8 <loop+0x80>)
   strTemp = String( (data0 -620) /45);
 80a019c:	a802      	add	r0, sp, #8
 80a019e:	f001 fcc3 	bl	80a1b28 <_ZN6StringD1Ev>
  delay(1000);
 80a01a2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a01a6:	f001 fe15 	bl	80a1dd4 <delay>
  if (sinceLastPub > 80){
 80a01aa:	6823      	ldr	r3, [r4, #0]
 80a01ac:	2b50      	cmp	r3, #80	; 0x50
 80a01ae:	dd14      	ble.n	80a01da <loop+0x72>
inline particle::Flags<TagT, ValueT>::Flags(Flag<TagT, ValueT> flag) :
        val_(flag.value()) {
}

template<typename TagT, typename ValueT>
inline particle::Flags<TagT, ValueT>::Flags(ValueT val) :
 80a01b0:	4b0e      	ldr	r3, [pc, #56]	; (80a01ec <loop+0x84>)
        return publish_event(eventName, eventData, ttl, flags1 | flags2);
 80a01b2:	682a      	ldr	r2, [r5, #0]
 80a01b4:	781b      	ldrb	r3, [r3, #0]
 80a01b6:	490e      	ldr	r1, [pc, #56]	; (80a01f0 <loop+0x88>)
 80a01b8:	f88d 3000 	strb.w	r3, [sp]
 80a01bc:	a802      	add	r0, sp, #8
 80a01be:	233c      	movs	r3, #60	; 0x3c
 80a01c0:	f002 f82a 	bl	80a2218 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a01c4:	a803      	add	r0, sp, #12
 80a01c6:	f7ff ffb9 	bl	80a013c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
    Particle.publish("abhistemp", strTemp);
    sinceLastPub = 0;
 80a01ca:	2300      	movs	r3, #0
 80a01cc:	6023      	str	r3, [r4, #0]
  }
  else {++sinceLastPub;}
  delay(1000);
 80a01ce:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a01d2:	f001 fdff 	bl	80a1dd4 <delay>
 
}
 80a01d6:	b007      	add	sp, #28
 80a01d8:	bd30      	pop	{r4, r5, pc}
  else {++sinceLastPub;}
 80a01da:	3301      	adds	r3, #1
 80a01dc:	6023      	str	r3, [r4, #0]
 80a01de:	e7f6      	b.n	80a01ce <loop+0x66>
 80a01e0:	20000090 	.word	0x20000090
 80a01e4:	200000ac 	.word	0x200000ac
 80a01e8:	200000a8 	.word	0x200000a8
 80a01ec:	2000008c 	.word	0x2000008c
 80a01f0:	080a2f43 	.word	0x080a2f43

080a01f4 <_Z17setModeFromString6String>:
 
int setModeFromString(String inputString)
{ output = inputString.toInt();
 80a01f4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80a01f6:	4604      	mov	r4, r0
 80a01f8:	f001 fd68 	bl	80a1ccc <_ZNK6String5toIntEv>
 80a01fc:	4b2d      	ldr	r3, [pc, #180]	; (80a02b4 <_Z17setModeFromString6String+0xc0>)
 80a01fe:	6018      	str	r0, [r3, #0]
    if (output > 50 && output <= 55) {
 80a0200:	f1a0 0333 	sub.w	r3, r0, #51	; 0x33
 80a0204:	2b04      	cmp	r3, #4
 80a0206:	d811      	bhi.n	80a022c <_Z17setModeFromString6String+0x38>
        mode = COLD;
 80a0208:	2100      	movs	r1, #0
 80a020a:	4b2b      	ldr	r3, [pc, #172]	; (80a02b8 <_Z17setModeFromString6String+0xc4>)
 80a020c:	7019      	strb	r1, [r3, #0]
        strip.setPixelColor(0, PixelColorBlue);
 80a020e:	4b2b      	ldr	r3, [pc, #172]	; (80a02bc <_Z17setModeFromString6String+0xc8>)
 80a0210:	681a      	ldr	r2, [r3, #0]
        strip.show();
        delay(1000);
        return 1;
    } else if (output > 63 && output <= 70) {
        mode = HOT;
        strip.setPixelColor(0, PixelColorYellow);
 80a0212:	482b      	ldr	r0, [pc, #172]	; (80a02c0 <_Z17setModeFromString6String+0xcc>)
 80a0214:	f001 f9b6 	bl	80a1584 <_ZN17Adafruit_NeoPixel13setPixelColorEtm>
        strip.show();
 80a0218:	4829      	ldr	r0, [pc, #164]	; (80a02c0 <_Z17setModeFromString6String+0xcc>)
 80a021a:	f000 f903 	bl	80a0424 <_ZN17Adafruit_NeoPixel4showEv>
        delay(1000);
 80a021e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a0222:	f001 fdd7 	bl	80a1dd4 <delay>
        return 1;
 80a0226:	2001      	movs	r0, #1
    else {
        Serial.print("Invalid Mode: ");
        Serial.println(inputString);
        return -1;
    }
}
 80a0228:	b004      	add	sp, #16
 80a022a:	bd10      	pop	{r4, pc}
    } else if (output > 55 && output <= 63) {
 80a022c:	f1a0 0338 	sub.w	r3, r0, #56	; 0x38
 80a0230:	2b07      	cmp	r3, #7
 80a0232:	d806      	bhi.n	80a0242 <_Z17setModeFromString6String+0x4e>
        mode = ROOM;
 80a0234:	2401      	movs	r4, #1
 80a0236:	4b20      	ldr	r3, [pc, #128]	; (80a02b8 <_Z17setModeFromString6String+0xc4>)
 80a0238:	701c      	strb	r4, [r3, #0]
        strip.setPixelColor(0, PixelColorGreen);
 80a023a:	4b22      	ldr	r3, [pc, #136]	; (80a02c4 <_Z17setModeFromString6String+0xd0>)
        strip.setPixelColor(0, PixelColorYellow);
 80a023c:	2100      	movs	r1, #0
 80a023e:	681a      	ldr	r2, [r3, #0]
 80a0240:	e7e7      	b.n	80a0212 <_Z17setModeFromString6String+0x1e>
    } else if (output > 63 && output <= 70) {
 80a0242:	3840      	subs	r0, #64	; 0x40
 80a0244:	2806      	cmp	r0, #6
 80a0246:	d804      	bhi.n	80a0252 <_Z17setModeFromString6String+0x5e>
        mode = HOT;
 80a0248:	2202      	movs	r2, #2
 80a024a:	4b1b      	ldr	r3, [pc, #108]	; (80a02b8 <_Z17setModeFromString6String+0xc4>)
 80a024c:	701a      	strb	r2, [r3, #0]
        strip.setPixelColor(0, PixelColorYellow);
 80a024e:	4b1e      	ldr	r3, [pc, #120]	; (80a02c8 <_Z17setModeFromString6String+0xd4>)
 80a0250:	e7f4      	b.n	80a023c <_Z17setModeFromString6String+0x48>
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
 80a0252:	4620      	mov	r0, r4
 80a0254:	491d      	ldr	r1, [pc, #116]	; (80a02cc <_Z17setModeFromString6String+0xd8>)
 80a0256:	f001 fd27 	bl	80a1ca8 <_ZNK6String6equalsEPKc>
    if (inputString == "RedModeAlert") {
 80a025a:	b1f0      	cbz	r0, 80a029a <_Z17setModeFromString6String+0xa6>
        mode = REDMODEALERT;
 80a025c:	2203      	movs	r2, #3
 80a025e:	4b16      	ldr	r3, [pc, #88]	; (80a02b8 <_Z17setModeFromString6String+0xc4>)
        strip.setPixelColor(0, PixelColorRed);
 80a0260:	2100      	movs	r1, #0
        mode = REDMODEALERT;
 80a0262:	701a      	strb	r2, [r3, #0]
        strip.setPixelColor(0, PixelColorRed);
 80a0264:	4b1a      	ldr	r3, [pc, #104]	; (80a02d0 <_Z17setModeFromString6String+0xdc>)
 80a0266:	4816      	ldr	r0, [pc, #88]	; (80a02c0 <_Z17setModeFromString6String+0xcc>)
 80a0268:	681a      	ldr	r2, [r3, #0]
 80a026a:	f001 f98b 	bl	80a1584 <_ZN17Adafruit_NeoPixel13setPixelColorEtm>
        strip.show();
 80a026e:	4814      	ldr	r0, [pc, #80]	; (80a02c0 <_Z17setModeFromString6String+0xcc>)
 80a0270:	f000 f8d8 	bl	80a0424 <_ZN17Adafruit_NeoPixel4showEv>
        delay(1000);
 80a0274:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a0278:	f001 fdac 	bl	80a1dd4 <delay>
 80a027c:	4b15      	ldr	r3, [pc, #84]	; (80a02d4 <_Z17setModeFromString6String+0xe0>)
 80a027e:	4a16      	ldr	r2, [pc, #88]	; (80a02d8 <_Z17setModeFromString6String+0xe4>)
 80a0280:	781b      	ldrb	r3, [r3, #0]
 80a0282:	4916      	ldr	r1, [pc, #88]	; (80a02dc <_Z17setModeFromString6String+0xe8>)
 80a0284:	f88d 3000 	strb.w	r3, [sp]
 80a0288:	a802      	add	r0, sp, #8
 80a028a:	233c      	movs	r3, #60	; 0x3c
 80a028c:	f001 ffc4 	bl	80a2218 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>
 80a0290:	a803      	add	r0, sp, #12
 80a0292:	f7ff ff53 	bl	80a013c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        return 1;
 80a0296:	2001      	movs	r0, #1
 80a0298:	e7c6      	b.n	80a0228 <_Z17setModeFromString6String+0x34>
        Serial.print("Invalid Mode: ");
 80a029a:	f002 fa03 	bl	80a26a4 <_Z16_fetch_usbserialv>
 80a029e:	4910      	ldr	r1, [pc, #64]	; (80a02e0 <_Z17setModeFromString6String+0xec>)
 80a02a0:	f001 fd3f 	bl	80a1d22 <_ZN5Print5printEPKc>
        Serial.println(inputString);
 80a02a4:	f002 f9fe 	bl	80a26a4 <_Z16_fetch_usbserialv>
 80a02a8:	6821      	ldr	r1, [r4, #0]
 80a02aa:	f001 fd4d 	bl	80a1d48 <_ZN5Print7printlnEPKc>
        return -1;
 80a02ae:	f04f 30ff 	mov.w	r0, #4294967295
 80a02b2:	e7b9      	b.n	80a0228 <_Z17setModeFromString6String+0x34>
 80a02b4:	20000094 	.word	0x20000094
 80a02b8:	2000000c 	.word	0x2000000c
 80a02bc:	2000007c 	.word	0x2000007c
 80a02c0:	200000bc 	.word	0x200000bc
 80a02c4:	20000080 	.word	0x20000080
 80a02c8:	20000088 	.word	0x20000088
 80a02cc:	080a2f4d 	.word	0x080a2f4d
 80a02d0:	20000084 	.word	0x20000084
 80a02d4:	2000008c 	.word	0x2000008c
 80a02d8:	080a2f5a 	.word	0x080a2f5a
 80a02dc:	080a2f8e 	.word	0x080a2f8e
 80a02e0:	080a2f9b 	.word	0x080a2f9b

080a02e4 <_GLOBAL__sub_I_mode>:
}
 80a02e4:	b510      	push	{r4, lr}
        val_(val) {
 80a02e6:	2400      	movs	r4, #0
 80a02e8:	4b18      	ldr	r3, [pc, #96]	; (80a034c <_GLOBAL__sub_I_mode+0x68>)
String redMode = "RedMode is on";
 80a02ea:	4919      	ldr	r1, [pc, #100]	; (80a0350 <_GLOBAL__sub_I_mode+0x6c>)
 80a02ec:	701c      	strb	r4, [r3, #0]
 80a02ee:	4819      	ldr	r0, [pc, #100]	; (80a0354 <_GLOBAL__sub_I_mode+0x70>)
 80a02f0:	f001 fc64 	bl	80a1bbc <_ZN6StringC1EPKc>
Adafruit_NeoPixel strip = Adafruit_NeoPixel(Pixel_Count, Pixel_Pin, Pixel_Type);
 80a02f4:	4b18      	ldr	r3, [pc, #96]	; (80a0358 <_GLOBAL__sub_I_mode+0x74>)
 80a02f6:	4a19      	ldr	r2, [pc, #100]	; (80a035c <_GLOBAL__sub_I_mode+0x78>)
 80a02f8:	4919      	ldr	r1, [pc, #100]	; (80a0360 <_GLOBAL__sub_I_mode+0x7c>)
 80a02fa:	781b      	ldrb	r3, [r3, #0]
 80a02fc:	7812      	ldrb	r2, [r2, #0]
 80a02fe:	8809      	ldrh	r1, [r1, #0]
 80a0300:	4818      	ldr	r0, [pc, #96]	; (80a0364 <_GLOBAL__sub_I_mode+0x80>)
 80a0302:	f000 f87e 	bl	80a0402 <_ZN17Adafruit_NeoPixelC1Ethh>
int PixelColorGreen = strip.Color(255, 0, 0);
 80a0306:	4622      	mov	r2, r4
 80a0308:	4621      	mov	r1, r4
 80a030a:	20ff      	movs	r0, #255	; 0xff
 80a030c:	f001 f97e 	bl	80a160c <_ZN17Adafruit_NeoPixel5ColorEhhh>
 80a0310:	4b15      	ldr	r3, [pc, #84]	; (80a0368 <_GLOBAL__sub_I_mode+0x84>)
int PixelColorBlue = strip.Color(0, 0, 255);
 80a0312:	4621      	mov	r1, r4
int PixelColorGreen = strip.Color(255, 0, 0);
 80a0314:	6018      	str	r0, [r3, #0]
int PixelColorBlue = strip.Color(0, 0, 255);
 80a0316:	22ff      	movs	r2, #255	; 0xff
 80a0318:	4620      	mov	r0, r4
 80a031a:	f001 f977 	bl	80a160c <_ZN17Adafruit_NeoPixel5ColorEhhh>
 80a031e:	4b13      	ldr	r3, [pc, #76]	; (80a036c <_GLOBAL__sub_I_mode+0x88>)
int PixelColorYellow = strip.Color(100, 143, 0);
 80a0320:	4622      	mov	r2, r4
int PixelColorBlue = strip.Color(0, 0, 255);
 80a0322:	6018      	str	r0, [r3, #0]
int PixelColorYellow = strip.Color(100, 143, 0);
 80a0324:	218f      	movs	r1, #143	; 0x8f
 80a0326:	2064      	movs	r0, #100	; 0x64
 80a0328:	f001 f970 	bl	80a160c <_ZN17Adafruit_NeoPixel5ColorEhhh>
 80a032c:	4b10      	ldr	r3, [pc, #64]	; (80a0370 <_GLOBAL__sub_I_mode+0x8c>)
int PixelColorRed = strip.Color (0,255, 0);
 80a032e:	4622      	mov	r2, r4
int PixelColorYellow = strip.Color(100, 143, 0);
 80a0330:	6018      	str	r0, [r3, #0]
int PixelColorRed = strip.Color (0,255, 0);
 80a0332:	21ff      	movs	r1, #255	; 0xff
 80a0334:	4620      	mov	r0, r4
 80a0336:	f001 f969 	bl	80a160c <_ZN17Adafruit_NeoPixel5ColorEhhh>
 80a033a:	4b0e      	ldr	r3, [pc, #56]	; (80a0374 <_GLOBAL__sub_I_mode+0x90>)
String strTemp;
 80a033c:	490e      	ldr	r1, [pc, #56]	; (80a0378 <_GLOBAL__sub_I_mode+0x94>)
int PixelColorRed = strip.Color (0,255, 0);
 80a033e:	6018      	str	r0, [r3, #0]
}
 80a0340:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
String strTemp;
 80a0344:	480d      	ldr	r0, [pc, #52]	; (80a037c <_GLOBAL__sub_I_mode+0x98>)
 80a0346:	f001 bc39 	b.w	80a1bbc <_ZN6StringC1EPKc>
 80a034a:	bf00      	nop
 80a034c:	2000008c 	.word	0x2000008c
 80a0350:	080a2faa 	.word	0x080a2faa
 80a0354:	20000098 	.word	0x20000098
 80a0358:	20000008 	.word	0x20000008
 80a035c:	20000004 	.word	0x20000004
 80a0360:	20000000 	.word	0x20000000
 80a0364:	200000bc 	.word	0x200000bc
 80a0368:	20000080 	.word	0x20000080
 80a036c:	2000007c 	.word	0x2000007c
 80a0370:	20000088 	.word	0x20000088
 80a0374:	20000084 	.word	0x20000084
 80a0378:	080a2fa9 	.word	0x080a2fa9
 80a037c:	200000ac 	.word	0x200000ac

080a0380 <_ZN17Adafruit_NeoPixel12updateLengthEt>:
Adafruit_NeoPixel::~Adafruit_NeoPixel() {
  if (pixels) free(pixels);
  if (begun) pinMode(pin, INPUT);
}

void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a0380:	b538      	push	{r3, r4, r5, lr}
 80a0382:	4604      	mov	r4, r0
  if (pixels) free(pixels); // Free existing data (if any)
 80a0384:	68c0      	ldr	r0, [r0, #12]
void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a0386:	460d      	mov	r5, r1
  if (pixels) free(pixels); // Free existing data (if any)
 80a0388:	b108      	cbz	r0, 80a038e <_ZN17Adafruit_NeoPixel12updateLengthEt+0xe>
 80a038a:	f001 fb33 	bl	80a19f4 <free>

  // Allocate new data -- note: ALL PIXELS ARE CLEARED
  numBytes = n * ((type == SK6812RGBW) ? 4 : 3);
 80a038e:	79a3      	ldrb	r3, [r4, #6]
 80a0390:	2b06      	cmp	r3, #6
 80a0392:	bf0c      	ite	eq
 80a0394:	2004      	moveq	r0, #4
 80a0396:	2003      	movne	r0, #3
 80a0398:	4368      	muls	r0, r5
 80a039a:	b280      	uxth	r0, r0
 80a039c:	80a0      	strh	r0, [r4, #4]
  if ((pixels = (uint8_t *)malloc(numBytes))) {
 80a039e:	f001 fb21 	bl	80a19e4 <malloc>
 80a03a2:	60e0      	str	r0, [r4, #12]
 80a03a4:	b128      	cbz	r0, 80a03b2 <_ZN17Adafruit_NeoPixel12updateLengthEt+0x32>
    memset(pixels, 0, numBytes);
 80a03a6:	2100      	movs	r1, #0
 80a03a8:	88a2      	ldrh	r2, [r4, #4]
 80a03aa:	f002 fc60 	bl	80a2c6e <memset>
    numLEDs = n;
 80a03ae:	8065      	strh	r5, [r4, #2]
  } else {
    numLEDs = numBytes = 0;
  }
}
 80a03b0:	bd38      	pop	{r3, r4, r5, pc}
    numLEDs = numBytes = 0;
 80a03b2:	80a0      	strh	r0, [r4, #4]
 80a03b4:	8060      	strh	r0, [r4, #2]
}
 80a03b6:	e7fb      	b.n	80a03b0 <_ZN17Adafruit_NeoPixel12updateLengthEt+0x30>

080a03b8 <_ZN17Adafruit_NeoPixel5beginEv>:

void Adafruit_NeoPixel::begin(void) {
 80a03b8:	b510      	push	{r4, lr}
 80a03ba:	4604      	mov	r4, r0
  pinMode(pin, OUTPUT);
 80a03bc:	2101      	movs	r1, #1
 80a03be:	79c0      	ldrb	r0, [r0, #7]
 80a03c0:	f002 fba8 	bl	80a2b14 <pinMode>
  digitalWrite(pin, LOW);
 80a03c4:	2100      	movs	r1, #0
 80a03c6:	79e0      	ldrb	r0, [r4, #7]
 80a03c8:	f002 fbb5 	bl	80a2b36 <digitalWrite>
  begun = true;
 80a03cc:	2301      	movs	r3, #1
 80a03ce:	7023      	strb	r3, [r4, #0]
}
 80a03d0:	bd10      	pop	{r4, pc}

080a03d2 <_ZN17Adafruit_NeoPixel6setPinEh>:

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a03d2:	b538      	push	{r3, r4, r5, lr}
    if (begun) {
 80a03d4:	7803      	ldrb	r3, [r0, #0]
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a03d6:	4605      	mov	r5, r0
 80a03d8:	460c      	mov	r4, r1
    if (begun) {
 80a03da:	b11b      	cbz	r3, 80a03e4 <_ZN17Adafruit_NeoPixel6setPinEh+0x12>
        pinMode(pin, INPUT);
 80a03dc:	2100      	movs	r1, #0
 80a03de:	79c0      	ldrb	r0, [r0, #7]
 80a03e0:	f002 fb98 	bl	80a2b14 <pinMode>
    }
    pin = p;
    if (begun) {
 80a03e4:	782b      	ldrb	r3, [r5, #0]
    pin = p;
 80a03e6:	71ec      	strb	r4, [r5, #7]
    if (begun) {
 80a03e8:	b153      	cbz	r3, 80a0400 <_ZN17Adafruit_NeoPixel6setPinEh+0x2e>
        pinMode(p, OUTPUT);
 80a03ea:	b2a4      	uxth	r4, r4
 80a03ec:	4620      	mov	r0, r4
 80a03ee:	2101      	movs	r1, #1
 80a03f0:	f002 fb90 	bl	80a2b14 <pinMode>
        digitalWrite(p, LOW);
 80a03f4:	4620      	mov	r0, r4
    }
}
 80a03f6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        digitalWrite(p, LOW);
 80a03fa:	2100      	movs	r1, #0
 80a03fc:	f002 bb9b 	b.w	80a2b36 <digitalWrite>
}
 80a0400:	bd38      	pop	{r3, r4, r5, pc}

080a0402 <_ZN17Adafruit_NeoPixelC1Ethh>:
Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, uint8_t t) :
 80a0402:	b570      	push	{r4, r5, r6, lr}
  begun(false), type(t), brightness(0), pixels(NULL), endTime(0)
 80a0404:	2500      	movs	r5, #0
Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, uint8_t t) :
 80a0406:	4604      	mov	r4, r0
 80a0408:	4616      	mov	r6, r2
  begun(false), type(t), brightness(0), pixels(NULL), endTime(0)
 80a040a:	7183      	strb	r3, [r0, #6]
 80a040c:	e9c0 5503 	strd	r5, r5, [r0, #12]
 80a0410:	7005      	strb	r5, [r0, #0]
 80a0412:	7205      	strb	r5, [r0, #8]
  updateLength(n);
 80a0414:	f7ff ffb4 	bl	80a0380 <_ZN17Adafruit_NeoPixel12updateLengthEt>
  setPin(p);
 80a0418:	4620      	mov	r0, r4
 80a041a:	4631      	mov	r1, r6
 80a041c:	f7ff ffd9 	bl	80a03d2 <_ZN17Adafruit_NeoPixel6setPinEh>
}
 80a0420:	4620      	mov	r0, r4
 80a0422:	bd70      	pop	{r4, r5, r6, pc}

080a0424 <_ZN17Adafruit_NeoPixel4showEv>:

void Adafruit_NeoPixel::show(void) {
  if(!pixels) return;
 80a0424:	68c3      	ldr	r3, [r0, #12]
 80a0426:	2b00      	cmp	r3, #0
 80a0428:	f000 8441 	beq.w	80a0cae <_ZN17Adafruit_NeoPixel4showEv+0x88a>
void Adafruit_NeoPixel::show(void) {
 80a042c:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a042e:	7983      	ldrb	r3, [r0, #6]
 80a0430:	4604      	mov	r4, r0
  // the function will simply hold off (if needed) on issuing the
  // subsequent round of data until the latch time has elapsed.  This
  // allows the mainline code to start generating the next frame of data
  // rather than stalling for the latch.
  uint32_t wait_time; // wait time in microseconds.
  switch(type) {
 80a0432:	3b02      	subs	r3, #2
 80a0434:	b2db      	uxtb	r3, r3
 80a0436:	2b04      	cmp	r3, #4
 80a0438:	bf8c      	ite	hi
 80a043a:	2532      	movhi	r5, #50	; 0x32
 80a043c:	4a28      	ldrls	r2, [pc, #160]	; (80a04e0 <_ZN17Adafruit_NeoPixel4showEv+0xbc>)
void Adafruit_NeoPixel::show(void) {
 80a043e:	b087      	sub	sp, #28
 80a0440:	bf98      	it	ls
 80a0442:	f852 5023 	ldrls.w	r5, [r2, r3, lsl #2]
#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a0446:	f001 f927 	bl	80a1698 <HAL_Timer_Get_Micro_Seconds>
    case WS2812B2_FAST:
    default: {   // default = 50us reset pulse
        wait_time = 50L;
      } break;
  }
  while((micros() - endTime) < wait_time);
 80a044a:	6923      	ldr	r3, [r4, #16]
 80a044c:	1ac0      	subs	r0, r0, r3
 80a044e:	42a8      	cmp	r0, r5
 80a0450:	d3f9      	bcc.n	80a0446 <_ZN17Adafruit_NeoPixel4showEv+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 80a0452:	b672      	cpsid	i
  __disable_irq(); // Need 100% focus on instruction timing

  volatile uint32_t
    c,    // 24-bit/32-bit pixel color
    mask; // 1-bit mask
  volatile uint16_t i = numBytes; // Output loop counter
 80a0454:	88a3      	ldrh	r3, [r4, #4]
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a0456:	79a5      	ldrb	r5, [r4, #6]
  volatile uint16_t i = numBytes; // Output loop counter
 80a0458:	f8ad 300a 	strh.w	r3, [sp, #10]
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a045c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a0460:	2d02      	cmp	r5, #2
   *ptr = pixels,   // Pointer to next byte
 80a0462:	68e1      	ldr	r1, [r4, #12]
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a0464:	b29b      	uxth	r3, r3
  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a0466:	f000 826e 	beq.w	80a0946 <_ZN17Adafruit_NeoPixel4showEv+0x522>
 80a046a:	2d07      	cmp	r5, #7
 80a046c:	f000 826b 	beq.w	80a0946 <_ZN17Adafruit_NeoPixel4showEv+0x522>
        }
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
 80a0470:	2d06      	cmp	r5, #6
 80a0472:	f000 841d 	beq.w	80a0cb0 <_ZN17Adafruit_NeoPixel4showEv+0x88c>
        }
        mask >>= 1;
      } while ( ++j < 32 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == WS2812B2 || type == WS2812B2_FAST) { // WS2812B with DWT timer
 80a0476:	2d05      	cmp	r5, #5
 80a0478:	f000 83a1 	beq.w	80a0bbe <_ZN17Adafruit_NeoPixel4showEv+0x79a>
 80a047c:	2d08      	cmp	r5, #8
 80a047e:	f000 839e 	beq.w	80a0bbe <_ZN17Adafruit_NeoPixel4showEv+0x79a>
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
#endif
  }
  else if(type == WS2811) { // WS2811, 400 KHz bitstream
 80a0482:	2d00      	cmp	r5, #0
 80a0484:	f040 854f 	bne.w	80a0f26 <_ZN17Adafruit_NeoPixel4showEv+0xb02>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a0488:	2b00      	cmp	r3, #0
 80a048a:	f000 8392 	beq.w	80a0bb2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a048e:	f44f 0600 	mov.w	r6, #8388608	; 0x800000
 80a0492:	4a14      	ldr	r2, [pc, #80]	; (80a04e4 <_ZN17Adafruit_NeoPixel4showEv+0xc0>)
 80a0494:	9604      	str	r6, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a0496:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
 80a049a:	3103      	adds	r1, #3
      i = i-3;      // decrement bytes remaining
 80a049c:	3b03      	subs	r3, #3
 80a049e:	b29b      	uxth	r3, r3
 80a04a0:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a04a4:	f811 3c03 	ldrb.w	r3, [r1, #-3]
 80a04a8:	b2db      	uxtb	r3, r3
 80a04aa:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a04ae:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 80a04b2:	b2db      	uxtb	r3, r3
 80a04b4:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a04b8:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 80a04bc:	b2db      	uxtb	r3, r3
 80a04be:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a04c2:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a04c6:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a04ca:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a04ce:	021b      	lsls	r3, r3, #8
 80a04d0:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a04d4:	4303      	orrs	r3, r0
 80a04d6:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a04d8:	f88d 5005 	strb.w	r5, [sp, #5]
 80a04dc:	e11b      	b.n	80a0716 <_ZN17Adafruit_NeoPixel4showEv+0x2f2>
 80a04de:	bf00      	nop
 80a04e0:	080a2fb8 	.word	0x080a2fb8
 80a04e4:	200000d0 	.word	0x200000d0
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a04e8:	4600      	mov	r0, r0
 80a04ea:	bf00      	nop
 80a04ec:	bf00      	nop
 80a04ee:	bf00      	nop
 80a04f0:	bf00      	nop
 80a04f2:	bf00      	nop
 80a04f4:	bf00      	nop
 80a04f6:	bf00      	nop
 80a04f8:	bf00      	nop
 80a04fa:	bf00      	nop
 80a04fc:	bf00      	nop
 80a04fe:	bf00      	nop
 80a0500:	bf00      	nop
 80a0502:	bf00      	nop
 80a0504:	bf00      	nop
 80a0506:	bf00      	nop
 80a0508:	bf00      	nop
 80a050a:	bf00      	nop
 80a050c:	bf00      	nop
 80a050e:	bf00      	nop
 80a0510:	bf00      	nop
 80a0512:	bf00      	nop
 80a0514:	bf00      	nop
 80a0516:	bf00      	nop
 80a0518:	bf00      	nop
 80a051a:	bf00      	nop
 80a051c:	bf00      	nop
 80a051e:	bf00      	nop
 80a0520:	bf00      	nop
 80a0522:	bf00      	nop
 80a0524:	bf00      	nop
 80a0526:	bf00      	nop
 80a0528:	bf00      	nop
 80a052a:	bf00      	nop
 80a052c:	bf00      	nop
 80a052e:	bf00      	nop
 80a0530:	bf00      	nop
 80a0532:	bf00      	nop
 80a0534:	bf00      	nop
 80a0536:	bf00      	nop
 80a0538:	bf00      	nop
 80a053a:	bf00      	nop
 80a053c:	bf00      	nop
 80a053e:	bf00      	nop
 80a0540:	bf00      	nop
 80a0542:	bf00      	nop
 80a0544:	bf00      	nop
 80a0546:	bf00      	nop
 80a0548:	bf00      	nop
 80a054a:	bf00      	nop
 80a054c:	bf00      	nop
 80a054e:	bf00      	nop
 80a0550:	bf00      	nop
 80a0552:	bf00      	nop
 80a0554:	bf00      	nop
 80a0556:	bf00      	nop
 80a0558:	bf00      	nop
 80a055a:	bf00      	nop
 80a055c:	bf00      	nop
 80a055e:	bf00      	nop
 80a0560:	bf00      	nop
 80a0562:	bf00      	nop
 80a0564:	bf00      	nop
 80a0566:	bf00      	nop
 80a0568:	bf00      	nop
 80a056a:	bf00      	nop
 80a056c:	bf00      	nop
 80a056e:	bf00      	nop
 80a0570:	bf00      	nop
 80a0572:	bf00      	nop
 80a0574:	bf00      	nop
 80a0576:	bf00      	nop
 80a0578:	bf00      	nop
 80a057a:	bf00      	nop
 80a057c:	bf00      	nop
 80a057e:	bf00      	nop
 80a0580:	bf00      	nop
 80a0582:	bf00      	nop
 80a0584:	bf00      	nop
 80a0586:	bf00      	nop
 80a0588:	bf00      	nop
 80a058a:	bf00      	nop
 80a058c:	bf00      	nop
 80a058e:	bf00      	nop
 80a0590:	bf00      	nop
 80a0592:	bf00      	nop
 80a0594:	bf00      	nop
 80a0596:	bf00      	nop
 80a0598:	bf00      	nop
 80a059a:	bf00      	nop
 80a059c:	bf00      	nop
 80a059e:	bf00      	nop
 80a05a0:	bf00      	nop
 80a05a2:	bf00      	nop
 80a05a4:	bf00      	nop
 80a05a6:	bf00      	nop
 80a05a8:	bf00      	nop
 80a05aa:	bf00      	nop
 80a05ac:	bf00      	nop
 80a05ae:	bf00      	nop
 80a05b0:	bf00      	nop
 80a05b2:	bf00      	nop
 80a05b4:	bf00      	nop
 80a05b6:	bf00      	nop
 80a05b8:	bf00      	nop
 80a05ba:	bf00      	nop
 80a05bc:	bf00      	nop
 80a05be:	bf00      	nop
 80a05c0:	bf00      	nop
 80a05c2:	bf00      	nop
 80a05c4:	bf00      	nop
 80a05c6:	bf00      	nop
 80a05c8:	bf00      	nop
 80a05ca:	bf00      	nop
 80a05cc:	bf00      	nop
 80a05ce:	bf00      	nop
 80a05d0:	bf00      	nop
 80a05d2:	bf00      	nop
 80a05d4:	bf00      	nop
 80a05d6:	bf00      	nop
 80a05d8:	bf00      	nop
 80a05da:	bf00      	nop
 80a05dc:	bf00      	nop
 80a05de:	bf00      	nop
 80a05e0:	bf00      	nop
 80a05e2:	bf00      	nop
 80a05e4:	bf00      	nop
 80a05e6:	bf00      	nop
 80a05e8:	bf00      	nop
 80a05ea:	bf00      	nop
 80a05ec:	bf00      	nop
 80a05ee:	bf00      	nop
          // WS2811 spec             1.30us LOW
          // Adafruit on Arduino    (meas. 1.25us)
          // This lib on Spark Core (meas. 1.24us)
          // This lib on Photon     (meas. 1.24us)
          pinSet(pin, LOW); // LOW
 80a05f0:	79e3      	ldrb	r3, [r4, #7]
 80a05f2:	6810      	ldr	r0, [r2, #0]
 80a05f4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a05f8:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a05fc:	88bf      	ldrh	r7, [r7, #4]
 80a05fe:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0602:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a0604:	4600      	mov	r0, r0
 80a0606:	bf00      	nop
 80a0608:	bf00      	nop
 80a060a:	bf00      	nop
 80a060c:	bf00      	nop
 80a060e:	bf00      	nop
 80a0610:	bf00      	nop
 80a0612:	bf00      	nop
 80a0614:	bf00      	nop
 80a0616:	bf00      	nop
 80a0618:	bf00      	nop
 80a061a:	bf00      	nop
 80a061c:	bf00      	nop
 80a061e:	bf00      	nop
 80a0620:	bf00      	nop
 80a0622:	bf00      	nop
 80a0624:	bf00      	nop
 80a0626:	bf00      	nop
 80a0628:	bf00      	nop
 80a062a:	bf00      	nop
 80a062c:	bf00      	nop
 80a062e:	bf00      	nop
 80a0630:	bf00      	nop
 80a0632:	bf00      	nop
 80a0634:	bf00      	nop
 80a0636:	bf00      	nop
 80a0638:	bf00      	nop
 80a063a:	bf00      	nop
 80a063c:	bf00      	nop
 80a063e:	bf00      	nop
 80a0640:	bf00      	nop
 80a0642:	bf00      	nop
 80a0644:	bf00      	nop
 80a0646:	bf00      	nop
 80a0648:	bf00      	nop
 80a064a:	bf00      	nop
 80a064c:	bf00      	nop
 80a064e:	bf00      	nop
 80a0650:	bf00      	nop
 80a0652:	bf00      	nop
 80a0654:	bf00      	nop
 80a0656:	bf00      	nop
 80a0658:	bf00      	nop
 80a065a:	bf00      	nop
 80a065c:	bf00      	nop
 80a065e:	bf00      	nop
 80a0660:	bf00      	nop
 80a0662:	bf00      	nop
 80a0664:	bf00      	nop
 80a0666:	bf00      	nop
 80a0668:	bf00      	nop
 80a066a:	bf00      	nop
 80a066c:	bf00      	nop
 80a066e:	bf00      	nop
 80a0670:	bf00      	nop
 80a0672:	bf00      	nop
 80a0674:	bf00      	nop
 80a0676:	bf00      	nop
 80a0678:	bf00      	nop
 80a067a:	bf00      	nop
 80a067c:	bf00      	nop
 80a067e:	bf00      	nop
 80a0680:	bf00      	nop
 80a0682:	bf00      	nop
 80a0684:	bf00      	nop
 80a0686:	bf00      	nop
 80a0688:	bf00      	nop
 80a068a:	bf00      	nop
 80a068c:	bf00      	nop
 80a068e:	bf00      	nop
 80a0690:	bf00      	nop
 80a0692:	bf00      	nop
 80a0694:	bf00      	nop
 80a0696:	bf00      	nop
 80a0698:	bf00      	nop
 80a069a:	bf00      	nop
 80a069c:	bf00      	nop
 80a069e:	bf00      	nop
 80a06a0:	bf00      	nop
 80a06a2:	bf00      	nop
 80a06a4:	bf00      	nop
 80a06a6:	bf00      	nop
 80a06a8:	bf00      	nop
 80a06aa:	bf00      	nop
 80a06ac:	bf00      	nop
 80a06ae:	bf00      	nop
 80a06b0:	bf00      	nop
 80a06b2:	bf00      	nop
 80a06b4:	bf00      	nop
 80a06b6:	bf00      	nop
 80a06b8:	bf00      	nop
 80a06ba:	bf00      	nop
 80a06bc:	bf00      	nop
 80a06be:	bf00      	nop
 80a06c0:	bf00      	nop
 80a06c2:	bf00      	nop
 80a06c4:	bf00      	nop
 80a06c6:	bf00      	nop
 80a06c8:	bf00      	nop
 80a06ca:	bf00      	nop
 80a06cc:	bf00      	nop
 80a06ce:	bf00      	nop
 80a06d0:	bf00      	nop
 80a06d2:	bf00      	nop
 80a06d4:	bf00      	nop
 80a06d6:	bf00      	nop
 80a06d8:	bf00      	nop
 80a06da:	bf00      	nop
 80a06dc:	bf00      	nop
 80a06de:	bf00      	nop
 80a06e0:	bf00      	nop
 80a06e2:	bf00      	nop
 80a06e4:	bf00      	nop
 80a06e6:	bf00      	nop
 80a06e8:	bf00      	nop
 80a06ea:	bf00      	nop
 80a06ec:	bf00      	nop
 80a06ee:	bf00      	nop
 80a06f0:	bf00      	nop
 80a06f2:	bf00      	nop
 80a06f4:	bf00      	nop
 80a06f6:	bf00      	nop
 80a06f8:	bf00      	nop
 80a06fa:	bf00      	nop
 80a06fc:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a06fe:	9b04      	ldr	r3, [sp, #16]
 80a0700:	085b      	lsrs	r3, r3, #1
 80a0702:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a0704:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a0708:	3301      	adds	r3, #1
 80a070a:	b2db      	uxtb	r3, r3
 80a070c:	2b17      	cmp	r3, #23
 80a070e:	f88d 3005 	strb.w	r3, [sp, #5]
 80a0712:	f200 8727 	bhi.w	80a1564 <_ZN17Adafruit_NeoPixel4showEv+0x1140>
        pinSet(pin, HIGH); // HIGH
 80a0716:	79e3      	ldrb	r3, [r4, #7]
 80a0718:	6810      	ldr	r0, [r2, #0]
 80a071a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a071e:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0722:	88bf      	ldrh	r7, [r7, #4]
 80a0724:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0728:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a072a:	9803      	ldr	r0, [sp, #12]
 80a072c:	9b04      	ldr	r3, [sp, #16]
 80a072e:	4218      	tst	r0, r3
 80a0730:	f47f aeda 	bne.w	80a04e8 <_ZN17Adafruit_NeoPixel4showEv+0xc4>
            ::: "r0", "cc", "memory");
 80a0734:	4600      	mov	r0, r0
 80a0736:	bf00      	nop
 80a0738:	bf00      	nop
 80a073a:	bf00      	nop
 80a073c:	bf00      	nop
 80a073e:	bf00      	nop
 80a0740:	bf00      	nop
 80a0742:	bf00      	nop
 80a0744:	bf00      	nop
 80a0746:	bf00      	nop
 80a0748:	bf00      	nop
 80a074a:	bf00      	nop
 80a074c:	bf00      	nop
 80a074e:	bf00      	nop
 80a0750:	bf00      	nop
 80a0752:	bf00      	nop
 80a0754:	bf00      	nop
 80a0756:	bf00      	nop
 80a0758:	bf00      	nop
 80a075a:	bf00      	nop
 80a075c:	bf00      	nop
 80a075e:	bf00      	nop
 80a0760:	bf00      	nop
 80a0762:	bf00      	nop
 80a0764:	bf00      	nop
 80a0766:	bf00      	nop
 80a0768:	bf00      	nop
 80a076a:	bf00      	nop
 80a076c:	bf00      	nop
 80a076e:	bf00      	nop
 80a0770:	bf00      	nop
 80a0772:	bf00      	nop
 80a0774:	bf00      	nop
 80a0776:	bf00      	nop
 80a0778:	bf00      	nop
 80a077a:	bf00      	nop
 80a077c:	bf00      	nop
 80a077e:	bf00      	nop
 80a0780:	bf00      	nop
 80a0782:	bf00      	nop
 80a0784:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a0786:	79e3      	ldrb	r3, [r4, #7]
 80a0788:	6810      	ldr	r0, [r2, #0]
 80a078a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a078e:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0792:	88bf      	ldrh	r7, [r7, #4]
 80a0794:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0798:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a079a:	4600      	mov	r0, r0
 80a079c:	bf00      	nop
 80a079e:	bf00      	nop
 80a07a0:	bf00      	nop
 80a07a2:	bf00      	nop
 80a07a4:	bf00      	nop
 80a07a6:	bf00      	nop
 80a07a8:	bf00      	nop
 80a07aa:	bf00      	nop
 80a07ac:	bf00      	nop
 80a07ae:	bf00      	nop
 80a07b0:	bf00      	nop
 80a07b2:	bf00      	nop
 80a07b4:	bf00      	nop
 80a07b6:	bf00      	nop
 80a07b8:	bf00      	nop
 80a07ba:	bf00      	nop
 80a07bc:	bf00      	nop
 80a07be:	bf00      	nop
 80a07c0:	bf00      	nop
 80a07c2:	bf00      	nop
 80a07c4:	bf00      	nop
 80a07c6:	bf00      	nop
 80a07c8:	bf00      	nop
 80a07ca:	bf00      	nop
 80a07cc:	bf00      	nop
 80a07ce:	bf00      	nop
 80a07d0:	bf00      	nop
 80a07d2:	bf00      	nop
 80a07d4:	bf00      	nop
 80a07d6:	bf00      	nop
 80a07d8:	bf00      	nop
 80a07da:	bf00      	nop
 80a07dc:	bf00      	nop
 80a07de:	bf00      	nop
 80a07e0:	bf00      	nop
 80a07e2:	bf00      	nop
 80a07e4:	bf00      	nop
 80a07e6:	bf00      	nop
 80a07e8:	bf00      	nop
 80a07ea:	bf00      	nop
 80a07ec:	bf00      	nop
 80a07ee:	bf00      	nop
 80a07f0:	bf00      	nop
 80a07f2:	bf00      	nop
 80a07f4:	bf00      	nop
 80a07f6:	bf00      	nop
 80a07f8:	bf00      	nop
 80a07fa:	bf00      	nop
 80a07fc:	bf00      	nop
 80a07fe:	bf00      	nop
 80a0800:	bf00      	nop
 80a0802:	bf00      	nop
 80a0804:	bf00      	nop
 80a0806:	bf00      	nop
 80a0808:	bf00      	nop
 80a080a:	bf00      	nop
 80a080c:	bf00      	nop
 80a080e:	bf00      	nop
 80a0810:	bf00      	nop
 80a0812:	bf00      	nop
 80a0814:	bf00      	nop
 80a0816:	bf00      	nop
 80a0818:	bf00      	nop
 80a081a:	bf00      	nop
 80a081c:	bf00      	nop
 80a081e:	bf00      	nop
 80a0820:	bf00      	nop
 80a0822:	bf00      	nop
 80a0824:	bf00      	nop
 80a0826:	bf00      	nop
 80a0828:	bf00      	nop
 80a082a:	bf00      	nop
 80a082c:	bf00      	nop
 80a082e:	bf00      	nop
 80a0830:	bf00      	nop
 80a0832:	bf00      	nop
 80a0834:	bf00      	nop
 80a0836:	bf00      	nop
 80a0838:	bf00      	nop
 80a083a:	bf00      	nop
 80a083c:	bf00      	nop
 80a083e:	bf00      	nop
 80a0840:	bf00      	nop
 80a0842:	bf00      	nop
 80a0844:	bf00      	nop
 80a0846:	bf00      	nop
 80a0848:	bf00      	nop
 80a084a:	bf00      	nop
 80a084c:	bf00      	nop
 80a084e:	bf00      	nop
 80a0850:	bf00      	nop
 80a0852:	bf00      	nop
 80a0854:	bf00      	nop
 80a0856:	bf00      	nop
 80a0858:	bf00      	nop
 80a085a:	bf00      	nop
 80a085c:	bf00      	nop
 80a085e:	bf00      	nop
 80a0860:	bf00      	nop
 80a0862:	bf00      	nop
 80a0864:	bf00      	nop
 80a0866:	bf00      	nop
 80a0868:	bf00      	nop
 80a086a:	bf00      	nop
 80a086c:	bf00      	nop
 80a086e:	bf00      	nop
 80a0870:	bf00      	nop
 80a0872:	bf00      	nop
 80a0874:	bf00      	nop
 80a0876:	bf00      	nop
 80a0878:	bf00      	nop
 80a087a:	bf00      	nop
 80a087c:	bf00      	nop
 80a087e:	bf00      	nop
 80a0880:	bf00      	nop
 80a0882:	bf00      	nop
 80a0884:	bf00      	nop
 80a0886:	bf00      	nop
 80a0888:	bf00      	nop
 80a088a:	bf00      	nop
 80a088c:	bf00      	nop
 80a088e:	bf00      	nop
 80a0890:	bf00      	nop
 80a0892:	bf00      	nop
 80a0894:	bf00      	nop
 80a0896:	bf00      	nop
 80a0898:	bf00      	nop
 80a089a:	bf00      	nop
 80a089c:	bf00      	nop
 80a089e:	bf00      	nop
 80a08a0:	bf00      	nop
 80a08a2:	bf00      	nop
 80a08a4:	bf00      	nop
 80a08a6:	bf00      	nop
 80a08a8:	bf00      	nop
 80a08aa:	bf00      	nop
 80a08ac:	bf00      	nop
 80a08ae:	bf00      	nop
 80a08b0:	bf00      	nop
 80a08b2:	bf00      	nop
 80a08b4:	bf00      	nop
 80a08b6:	bf00      	nop
 80a08b8:	bf00      	nop
 80a08ba:	bf00      	nop
 80a08bc:	bf00      	nop
 80a08be:	bf00      	nop
 80a08c0:	bf00      	nop
 80a08c2:	bf00      	nop
 80a08c4:	bf00      	nop
 80a08c6:	bf00      	nop
 80a08c8:	bf00      	nop
 80a08ca:	bf00      	nop
 80a08cc:	bf00      	nop
 80a08ce:	bf00      	nop
 80a08d0:	bf00      	nop
 80a08d2:	bf00      	nop
 80a08d4:	bf00      	nop
 80a08d6:	bf00      	nop
 80a08d8:	bf00      	nop
 80a08da:	bf00      	nop
 80a08dc:	bf00      	nop
 80a08de:	bf00      	nop
 80a08e0:	bf00      	nop
 80a08e2:	bf00      	nop
 80a08e4:	bf00      	nop
 80a08e6:	bf00      	nop
 80a08e8:	bf00      	nop
 80a08ea:	bf00      	nop
 80a08ec:	bf00      	nop
 80a08ee:	bf00      	nop
 80a08f0:	bf00      	nop
 80a08f2:	bf00      	nop
 80a08f4:	bf00      	nop
 80a08f6:	bf00      	nop
 80a08f8:	bf00      	nop
 80a08fa:	bf00      	nop
 80a08fc:	bf00      	nop
 80a08fe:	bf00      	nop
 80a0900:	bf00      	nop
 80a0902:	bf00      	nop
 80a0904:	bf00      	nop
 80a0906:	bf00      	nop
 80a0908:	bf00      	nop
 80a090a:	bf00      	nop
 80a090c:	bf00      	nop
 80a090e:	bf00      	nop
 80a0910:	bf00      	nop
 80a0912:	bf00      	nop
 80a0914:	bf00      	nop
 80a0916:	bf00      	nop
 80a0918:	bf00      	nop
 80a091a:	bf00      	nop
 80a091c:	bf00      	nop
 80a091e:	bf00      	nop
 80a0920:	bf00      	nop
 80a0922:	bf00      	nop
 80a0924:	bf00      	nop
 80a0926:	bf00      	nop
 80a0928:	bf00      	nop
 80a092a:	bf00      	nop
 80a092c:	bf00      	nop
 80a092e:	bf00      	nop
 80a0930:	bf00      	nop
 80a0932:	bf00      	nop
 80a0934:	bf00      	nop
 80a0936:	bf00      	nop
 80a0938:	bf00      	nop
 80a093a:	bf00      	nop
 80a093c:	bf00      	nop
 80a093e:	bf00      	nop
 80a0940:	bf00      	nop
 80a0942:	bf00      	nop
 80a0944:	e6db      	b.n	80a06fe <_ZN17Adafruit_NeoPixel4showEv+0x2da>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a0946:	2b00      	cmp	r3, #0
 80a0948:	f000 8133 	beq.w	80a0bb2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a094c:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      j = 0;        // reset the 24-bit counter
 80a0950:	2600      	movs	r6, #0
 80a0952:	4a13      	ldr	r2, [pc, #76]	; (80a09a0 <_ZN17Adafruit_NeoPixel4showEv+0x57c>)
      mask = 0x800000; // reset the mask
 80a0954:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a0956:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      b = *ptr++;   // Next blue byte value
 80a095a:	3103      	adds	r1, #3
      i = i-3;      // decrement bytes remaining
 80a095c:	3b03      	subs	r3, #3
 80a095e:	b29b      	uxth	r3, r3
 80a0960:	f8ad 300a 	strh.w	r3, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a0964:	f811 3c03 	ldrb.w	r3, [r1, #-3]
 80a0968:	b2db      	uxtb	r3, r3
 80a096a:	f88d 3006 	strb.w	r3, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a096e:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 80a0972:	b2db      	uxtb	r3, r3
 80a0974:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a0978:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 80a097c:	b2db      	uxtb	r3, r3
 80a097e:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a0982:	f89d 7006 	ldrb.w	r7, [sp, #6]
 80a0986:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a098a:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a098e:	021b      	lsls	r3, r3, #8
 80a0990:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a0994:	4303      	orrs	r3, r0
 80a0996:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a0998:	f88d 6005 	strb.w	r6, [sp, #5]
 80a099c:	e080      	b.n	80a0aa0 <_ZN17Adafruit_NeoPixel4showEv+0x67c>
 80a099e:	bf00      	nop
 80a09a0:	200000d0 	.word	0x200000d0
            ::: "r0", "cc", "memory");
 80a09a4:	4600      	mov	r0, r0
 80a09a6:	bf00      	nop
 80a09a8:	bf00      	nop
 80a09aa:	bf00      	nop
 80a09ac:	bf00      	nop
 80a09ae:	bf00      	nop
 80a09b0:	bf00      	nop
 80a09b2:	bf00      	nop
 80a09b4:	bf00      	nop
 80a09b6:	bf00      	nop
 80a09b8:	bf00      	nop
 80a09ba:	bf00      	nop
 80a09bc:	bf00      	nop
 80a09be:	bf00      	nop
 80a09c0:	bf00      	nop
 80a09c2:	bf00      	nop
 80a09c4:	bf00      	nop
 80a09c6:	bf00      	nop
 80a09c8:	bf00      	nop
 80a09ca:	bf00      	nop
 80a09cc:	bf00      	nop
 80a09ce:	bf00      	nop
 80a09d0:	bf00      	nop
 80a09d2:	bf00      	nop
 80a09d4:	bf00      	nop
 80a09d6:	bf00      	nop
 80a09d8:	bf00      	nop
 80a09da:	bf00      	nop
 80a09dc:	bf00      	nop
 80a09de:	bf00      	nop
 80a09e0:	bf00      	nop
 80a09e2:	bf00      	nop
 80a09e4:	bf00      	nop
 80a09e6:	bf00      	nop
 80a09e8:	bf00      	nop
 80a09ea:	bf00      	nop
 80a09ec:	bf00      	nop
 80a09ee:	bf00      	nop
 80a09f0:	bf00      	nop
 80a09f2:	bf00      	nop
 80a09f4:	bf00      	nop
 80a09f6:	bf00      	nop
 80a09f8:	bf00      	nop
 80a09fa:	bf00      	nop
 80a09fc:	bf00      	nop
 80a09fe:	bf00      	nop
 80a0a00:	bf00      	nop
 80a0a02:	bf00      	nop
 80a0a04:	bf00      	nop
 80a0a06:	bf00      	nop
 80a0a08:	bf00      	nop
 80a0a0a:	bf00      	nop
 80a0a0c:	bf00      	nop
 80a0a0e:	bf00      	nop
 80a0a10:	bf00      	nop
 80a0a12:	bf00      	nop
 80a0a14:	bf00      	nop
 80a0a16:	bf00      	nop
 80a0a18:	bf00      	nop
 80a0a1a:	bf00      	nop
 80a0a1c:	bf00      	nop
 80a0a1e:	bf00      	nop
 80a0a20:	bf00      	nop
 80a0a22:	bf00      	nop
 80a0a24:	bf00      	nop
 80a0a26:	bf00      	nop
 80a0a28:	bf00      	nop
 80a0a2a:	bf00      	nop
 80a0a2c:	bf00      	nop
 80a0a2e:	bf00      	nop
 80a0a30:	bf00      	nop
 80a0a32:	bf00      	nop
 80a0a34:	bf00      	nop
 80a0a36:	bf00      	nop
 80a0a38:	bf00      	nop
 80a0a3a:	bf00      	nop
 80a0a3c:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a0a3e:	79e3      	ldrb	r3, [r4, #7]
 80a0a40:	6810      	ldr	r0, [r2, #0]
 80a0a42:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a0a46:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0a4a:	88bf      	ldrh	r7, [r7, #4]
 80a0a4c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0a50:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a0a52:	4600      	mov	r0, r0
 80a0a54:	bf00      	nop
 80a0a56:	bf00      	nop
 80a0a58:	bf00      	nop
 80a0a5a:	bf00      	nop
 80a0a5c:	bf00      	nop
 80a0a5e:	bf00      	nop
 80a0a60:	bf00      	nop
 80a0a62:	bf00      	nop
 80a0a64:	bf00      	nop
 80a0a66:	bf00      	nop
 80a0a68:	bf00      	nop
 80a0a6a:	bf00      	nop
 80a0a6c:	bf00      	nop
 80a0a6e:	bf00      	nop
 80a0a70:	bf00      	nop
 80a0a72:	bf00      	nop
 80a0a74:	bf00      	nop
 80a0a76:	bf00      	nop
 80a0a78:	bf00      	nop
 80a0a7a:	bf00      	nop
 80a0a7c:	bf00      	nop
 80a0a7e:	bf00      	nop
 80a0a80:	bf00      	nop
 80a0a82:	bf00      	nop
 80a0a84:	bf00      	nop
 80a0a86:	bf00      	nop
        mask >>= 1;
 80a0a88:	9b04      	ldr	r3, [sp, #16]
 80a0a8a:	085b      	lsrs	r3, r3, #1
 80a0a8c:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a0a8e:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a0a92:	3301      	adds	r3, #1
 80a0a94:	b2db      	uxtb	r3, r3
 80a0a96:	2b17      	cmp	r3, #23
 80a0a98:	f88d 3005 	strb.w	r3, [sp, #5]
 80a0a9c:	f200 8083 	bhi.w	80a0ba6 <_ZN17Adafruit_NeoPixel4showEv+0x782>
        pinSet(pin, HIGH); // HIGH
 80a0aa0:	79e3      	ldrb	r3, [r4, #7]
 80a0aa2:	6810      	ldr	r0, [r2, #0]
 80a0aa4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a0aa8:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0aac:	88bf      	ldrh	r7, [r7, #4]
 80a0aae:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0ab2:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a0ab4:	9803      	ldr	r0, [sp, #12]
 80a0ab6:	9b04      	ldr	r3, [sp, #16]
 80a0ab8:	4218      	tst	r0, r3
 80a0aba:	f47f af73 	bne.w	80a09a4 <_ZN17Adafruit_NeoPixel4showEv+0x580>
            ::: "r0", "cc", "memory");
 80a0abe:	4600      	mov	r0, r0
 80a0ac0:	bf00      	nop
 80a0ac2:	bf00      	nop
 80a0ac4:	bf00      	nop
 80a0ac6:	bf00      	nop
 80a0ac8:	bf00      	nop
 80a0aca:	bf00      	nop
 80a0acc:	bf00      	nop
 80a0ace:	bf00      	nop
 80a0ad0:	bf00      	nop
 80a0ad2:	bf00      	nop
 80a0ad4:	bf00      	nop
 80a0ad6:	bf00      	nop
 80a0ad8:	bf00      	nop
 80a0ada:	bf00      	nop
 80a0adc:	bf00      	nop
 80a0ade:	bf00      	nop
 80a0ae0:	bf00      	nop
 80a0ae2:	bf00      	nop
 80a0ae4:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a0ae6:	79e3      	ldrb	r3, [r4, #7]
 80a0ae8:	6810      	ldr	r0, [r2, #0]
 80a0aea:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a0aee:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0af2:	88bf      	ldrh	r7, [r7, #4]
 80a0af4:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0af8:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a0afa:	4600      	mov	r0, r0
 80a0afc:	bf00      	nop
 80a0afe:	bf00      	nop
 80a0b00:	bf00      	nop
 80a0b02:	bf00      	nop
 80a0b04:	bf00      	nop
 80a0b06:	bf00      	nop
 80a0b08:	bf00      	nop
 80a0b0a:	bf00      	nop
 80a0b0c:	bf00      	nop
 80a0b0e:	bf00      	nop
 80a0b10:	bf00      	nop
 80a0b12:	bf00      	nop
 80a0b14:	bf00      	nop
 80a0b16:	bf00      	nop
 80a0b18:	bf00      	nop
 80a0b1a:	bf00      	nop
 80a0b1c:	bf00      	nop
 80a0b1e:	bf00      	nop
 80a0b20:	bf00      	nop
 80a0b22:	bf00      	nop
 80a0b24:	bf00      	nop
 80a0b26:	bf00      	nop
 80a0b28:	bf00      	nop
 80a0b2a:	bf00      	nop
 80a0b2c:	bf00      	nop
 80a0b2e:	bf00      	nop
 80a0b30:	bf00      	nop
 80a0b32:	bf00      	nop
 80a0b34:	bf00      	nop
 80a0b36:	bf00      	nop
 80a0b38:	bf00      	nop
 80a0b3a:	bf00      	nop
 80a0b3c:	bf00      	nop
 80a0b3e:	bf00      	nop
 80a0b40:	bf00      	nop
 80a0b42:	bf00      	nop
 80a0b44:	bf00      	nop
 80a0b46:	bf00      	nop
 80a0b48:	bf00      	nop
 80a0b4a:	bf00      	nop
 80a0b4c:	bf00      	nop
 80a0b4e:	bf00      	nop
 80a0b50:	bf00      	nop
 80a0b52:	bf00      	nop
 80a0b54:	bf00      	nop
 80a0b56:	bf00      	nop
 80a0b58:	bf00      	nop
 80a0b5a:	bf00      	nop
 80a0b5c:	bf00      	nop
 80a0b5e:	bf00      	nop
 80a0b60:	bf00      	nop
 80a0b62:	bf00      	nop
 80a0b64:	bf00      	nop
 80a0b66:	bf00      	nop
 80a0b68:	bf00      	nop
 80a0b6a:	bf00      	nop
 80a0b6c:	bf00      	nop
 80a0b6e:	bf00      	nop
 80a0b70:	bf00      	nop
 80a0b72:	bf00      	nop
 80a0b74:	bf00      	nop
 80a0b76:	bf00      	nop
 80a0b78:	bf00      	nop
 80a0b7a:	bf00      	nop
 80a0b7c:	bf00      	nop
 80a0b7e:	bf00      	nop
 80a0b80:	bf00      	nop
 80a0b82:	bf00      	nop
 80a0b84:	bf00      	nop
 80a0b86:	bf00      	nop
 80a0b88:	bf00      	nop
 80a0b8a:	bf00      	nop
 80a0b8c:	bf00      	nop
 80a0b8e:	bf00      	nop
 80a0b90:	bf00      	nop
 80a0b92:	bf00      	nop
 80a0b94:	bf00      	nop
 80a0b96:	bf00      	nop
 80a0b98:	bf00      	nop
 80a0b9a:	bf00      	nop
 80a0b9c:	bf00      	nop
 80a0b9e:	bf00      	nop
 80a0ba0:	bf00      	nop
 80a0ba2:	bf00      	nop
 80a0ba4:	e770      	b.n	80a0a88 <_ZN17Adafruit_NeoPixel4showEv+0x664>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a0ba6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a0baa:	b29b      	uxth	r3, r3
 80a0bac:	2b00      	cmp	r3, #0
 80a0bae:	f47f aed1 	bne.w	80a0954 <_ZN17Adafruit_NeoPixel4showEv+0x530>
  __ASM volatile ("cpsie i");
 80a0bb2:	b662      	cpsie	i
 80a0bb4:	f000 fd70 	bl	80a1698 <HAL_Timer_Get_Micro_Seconds>
  }
// END of NRF52 implementation


#endif
  endTime = micros(); // Save EOD time for latch on next call
 80a0bb8:	6120      	str	r0, [r4, #16]
}
 80a0bba:	b007      	add	sp, #28
 80a0bbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a0bbe:	2b00      	cmp	r3, #0
 80a0bc0:	d0f7      	beq.n	80a0bb2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a0bc2:	f44f 0e00 	mov.w	lr, #8388608	; 0x800000
      j = 0;        // reset the 24-bit counter
 80a0bc6:	2600      	movs	r6, #0
        pinSet(pin, HIGH); // HIGH
 80a0bc8:	4b54      	ldr	r3, [pc, #336]	; (80a0d1c <_ZN17Adafruit_NeoPixel4showEv+0x8f8>)
 80a0bca:	6818      	ldr	r0, [r3, #0]
        cyc = DWT->CYCCNT;
 80a0bcc:	4b54      	ldr	r3, [pc, #336]	; (80a0d20 <_ZN17Adafruit_NeoPixel4showEv+0x8fc>)
      mask = 0x800000; // reset the mask
 80a0bce:	f8cd e010 	str.w	lr, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a0bd2:	f8bd 200a 	ldrh.w	r2, [sp, #10]
      b = *ptr++;   // Next blue byte value
 80a0bd6:	3103      	adds	r1, #3
      i = i-3;      // decrement bytes remaining
 80a0bd8:	3a03      	subs	r2, #3
 80a0bda:	b292      	uxth	r2, r2
 80a0bdc:	f8ad 200a 	strh.w	r2, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a0be0:	f811 2c03 	ldrb.w	r2, [r1, #-3]
 80a0be4:	b2d2      	uxtb	r2, r2
 80a0be6:	f88d 2006 	strb.w	r2, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a0bea:	f811 2c02 	ldrb.w	r2, [r1, #-2]
 80a0bee:	b2d2      	uxtb	r2, r2
 80a0bf0:	f88d 2007 	strb.w	r2, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a0bf4:	f811 2c01 	ldrb.w	r2, [r1, #-1]
 80a0bf8:	b2d2      	uxtb	r2, r2
 80a0bfa:	f88d 2008 	strb.w	r2, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a0bfe:	f89d c006 	ldrb.w	ip, [sp, #6]
 80a0c02:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80a0c06:	f89d 7008 	ldrb.w	r7, [sp, #8]
 80a0c0a:	0212      	lsls	r2, r2, #8
 80a0c0c:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
 80a0c10:	433a      	orrs	r2, r7
 80a0c12:	9203      	str	r2, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a0c14:	f88d 6005 	strb.w	r6, [sp, #5]
        pinSet(pin, HIGH); // HIGH
 80a0c18:	79e2      	ldrb	r2, [r4, #7]
        cyc = DWT->CYCCNT;
 80a0c1a:	685d      	ldr	r5, [r3, #4]
        pinSet(pin, HIGH); // HIGH
 80a0c1c:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a0c20:	eb00 0782 	add.w	r7, r0, r2, lsl #2
 80a0c24:	88bf      	ldrh	r7, [r7, #4]
 80a0c26:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
        cyc = DWT->CYCCNT;
 80a0c2a:	9505      	str	r5, [sp, #20]
        pinSet(pin, HIGH); // HIGH
 80a0c2c:	8317      	strh	r7, [r2, #24]
        if (c & mask) { // if masked bit is high
 80a0c2e:	9f03      	ldr	r7, [sp, #12]
 80a0c30:	9a04      	ldr	r2, [sp, #16]
 80a0c32:	4217      	tst	r7, r2
 80a0c34:	d025      	beq.n	80a0c82 <_ZN17Adafruit_NeoPixel4showEv+0x85e>
          while(DWT->CYCCNT - cyc < CYCLES_800_T1H);
 80a0c36:	685a      	ldr	r2, [r3, #4]
 80a0c38:	9f05      	ldr	r7, [sp, #20]
 80a0c3a:	1bd2      	subs	r2, r2, r7
 80a0c3c:	2a4f      	cmp	r2, #79	; 0x4f
 80a0c3e:	d9fa      	bls.n	80a0c36 <_ZN17Adafruit_NeoPixel4showEv+0x812>
          pinSet(pin, LOW);
 80a0c40:	79e2      	ldrb	r2, [r4, #7]
 80a0c42:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a0c46:	eb00 0782 	add.w	r7, r0, r2, lsl #2
 80a0c4a:	88bf      	ldrh	r7, [r7, #4]
 80a0c4c:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 80a0c50:	8357      	strh	r7, [r2, #26]
          cyc = DWT->CYCCNT;
 80a0c52:	685a      	ldr	r2, [r3, #4]
 80a0c54:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T1L);
 80a0c56:	685a      	ldr	r2, [r3, #4]
 80a0c58:	9f05      	ldr	r7, [sp, #20]
 80a0c5a:	1bd2      	subs	r2, r2, r7
 80a0c5c:	2a07      	cmp	r2, #7
 80a0c5e:	d9fa      	bls.n	80a0c56 <_ZN17Adafruit_NeoPixel4showEv+0x832>
        mask >>= 1;
 80a0c60:	9a04      	ldr	r2, [sp, #16]
 80a0c62:	0852      	lsrs	r2, r2, #1
 80a0c64:	9204      	str	r2, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a0c66:	f89d 2005 	ldrb.w	r2, [sp, #5]
 80a0c6a:	3201      	adds	r2, #1
 80a0c6c:	b2d2      	uxtb	r2, r2
 80a0c6e:	2a17      	cmp	r2, #23
 80a0c70:	f88d 2005 	strb.w	r2, [sp, #5]
 80a0c74:	d9d0      	bls.n	80a0c18 <_ZN17Adafruit_NeoPixel4showEv+0x7f4>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a0c76:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 80a0c7a:	b292      	uxth	r2, r2
 80a0c7c:	2a00      	cmp	r2, #0
 80a0c7e:	d1a6      	bne.n	80a0bce <_ZN17Adafruit_NeoPixel4showEv+0x7aa>
 80a0c80:	e797      	b.n	80a0bb2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
          while(DWT->CYCCNT - cyc < CYCLES_800_T0H);
 80a0c82:	685a      	ldr	r2, [r3, #4]
 80a0c84:	9f05      	ldr	r7, [sp, #20]
 80a0c86:	1bd2      	subs	r2, r2, r7
 80a0c88:	2a18      	cmp	r2, #24
 80a0c8a:	d9fa      	bls.n	80a0c82 <_ZN17Adafruit_NeoPixel4showEv+0x85e>
          pinSet(pin, LOW);
 80a0c8c:	79e2      	ldrb	r2, [r4, #7]
 80a0c8e:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a0c92:	eb00 0782 	add.w	r7, r0, r2, lsl #2
 80a0c96:	88bf      	ldrh	r7, [r7, #4]
 80a0c98:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 80a0c9c:	8357      	strh	r7, [r2, #26]
          cyc = DWT->CYCCNT;
 80a0c9e:	685a      	ldr	r2, [r3, #4]
 80a0ca0:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T0L);
 80a0ca2:	685a      	ldr	r2, [r3, #4]
 80a0ca4:	9f05      	ldr	r7, [sp, #20]
 80a0ca6:	1bd2      	subs	r2, r2, r7
 80a0ca8:	2a45      	cmp	r2, #69	; 0x45
 80a0caa:	d9fa      	bls.n	80a0ca2 <_ZN17Adafruit_NeoPixel4showEv+0x87e>
 80a0cac:	e7d8      	b.n	80a0c60 <_ZN17Adafruit_NeoPixel4showEv+0x83c>
 80a0cae:	4770      	bx	lr
    while(i) { // While bytes left... (4 bytes = 1 pixel)
 80a0cb0:	2b00      	cmp	r3, #0
 80a0cb2:	f43f af7e 	beq.w	80a0bb2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x80000000; // reset the mask
 80a0cb6:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
      j = 0;        // reset the 32-bit counter
 80a0cba:	2600      	movs	r6, #0
 80a0cbc:	4a17      	ldr	r2, [pc, #92]	; (80a0d1c <_ZN17Adafruit_NeoPixel4showEv+0x8f8>)
      mask = 0x80000000; // reset the mask
 80a0cbe:	9504      	str	r5, [sp, #16]
      i = i-4;      // decrement bytes remaining
 80a0cc0:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      w = *ptr++;   // Next white byte value
 80a0cc4:	3104      	adds	r1, #4
      i = i-4;      // decrement bytes remaining
 80a0cc6:	3b04      	subs	r3, #4
 80a0cc8:	b29b      	uxth	r3, r3
 80a0cca:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a0cce:	f811 3c04 	ldrb.w	r3, [r1, #-4]
 80a0cd2:	b2db      	uxtb	r3, r3
 80a0cd4:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a0cd8:	f811 3c03 	ldrb.w	r3, [r1, #-3]
 80a0cdc:	b2db      	uxtb	r3, r3
 80a0cde:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a0ce2:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 80a0ce6:	b2db      	uxtb	r3, r3
 80a0ce8:	f88d 3008 	strb.w	r3, [sp, #8]
      w = *ptr++;   // Next white byte value
 80a0cec:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 80a0cf0:	b2db      	uxtb	r3, r3
 80a0cf2:	f88d 3009 	strb.w	r3, [sp, #9]
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
 80a0cf6:	f89d c007 	ldrb.w	ip, [sp, #7]
 80a0cfa:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a0cfe:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a0d02:	041b      	lsls	r3, r3, #16
 80a0d04:	f89d 7009 	ldrb.w	r7, [sp, #9]
 80a0d08:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
 80a0d0c:	433b      	orrs	r3, r7
 80a0d0e:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80a0d12:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 32-bit counter
 80a0d14:	f88d 6005 	strb.w	r6, [sp, #5]
 80a0d18:	e07f      	b.n	80a0e1a <_ZN17Adafruit_NeoPixel4showEv+0x9f6>
 80a0d1a:	bf00      	nop
 80a0d1c:	200000d0 	.word	0x200000d0
 80a0d20:	e0001000 	.word	0xe0001000
            ::: "r0", "cc", "memory");
 80a0d24:	4600      	mov	r0, r0
 80a0d26:	bf00      	nop
 80a0d28:	bf00      	nop
 80a0d2a:	bf00      	nop
 80a0d2c:	bf00      	nop
 80a0d2e:	bf00      	nop
 80a0d30:	bf00      	nop
 80a0d32:	bf00      	nop
 80a0d34:	bf00      	nop
 80a0d36:	bf00      	nop
 80a0d38:	bf00      	nop
 80a0d3a:	bf00      	nop
 80a0d3c:	bf00      	nop
 80a0d3e:	bf00      	nop
 80a0d40:	bf00      	nop
 80a0d42:	bf00      	nop
 80a0d44:	bf00      	nop
 80a0d46:	bf00      	nop
 80a0d48:	bf00      	nop
 80a0d4a:	bf00      	nop
 80a0d4c:	bf00      	nop
 80a0d4e:	bf00      	nop
 80a0d50:	bf00      	nop
 80a0d52:	bf00      	nop
 80a0d54:	bf00      	nop
 80a0d56:	bf00      	nop
 80a0d58:	bf00      	nop
 80a0d5a:	bf00      	nop
 80a0d5c:	bf00      	nop
 80a0d5e:	bf00      	nop
 80a0d60:	bf00      	nop
 80a0d62:	bf00      	nop
 80a0d64:	bf00      	nop
 80a0d66:	bf00      	nop
 80a0d68:	bf00      	nop
 80a0d6a:	bf00      	nop
 80a0d6c:	bf00      	nop
 80a0d6e:	bf00      	nop
 80a0d70:	bf00      	nop
 80a0d72:	bf00      	nop
 80a0d74:	bf00      	nop
 80a0d76:	bf00      	nop
 80a0d78:	bf00      	nop
 80a0d7a:	bf00      	nop
 80a0d7c:	bf00      	nop
 80a0d7e:	bf00      	nop
 80a0d80:	bf00      	nop
 80a0d82:	bf00      	nop
 80a0d84:	bf00      	nop
 80a0d86:	bf00      	nop
 80a0d88:	bf00      	nop
 80a0d8a:	bf00      	nop
 80a0d8c:	bf00      	nop
 80a0d8e:	bf00      	nop
 80a0d90:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a0d92:	79e3      	ldrb	r3, [r4, #7]
 80a0d94:	6810      	ldr	r0, [r2, #0]
 80a0d96:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a0d9a:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0d9e:	88bf      	ldrh	r7, [r7, #4]
 80a0da0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0da4:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a0da6:	4600      	mov	r0, r0
 80a0da8:	bf00      	nop
 80a0daa:	bf00      	nop
 80a0dac:	bf00      	nop
 80a0dae:	bf00      	nop
 80a0db0:	bf00      	nop
 80a0db2:	bf00      	nop
 80a0db4:	bf00      	nop
 80a0db6:	bf00      	nop
 80a0db8:	bf00      	nop
 80a0dba:	bf00      	nop
 80a0dbc:	bf00      	nop
 80a0dbe:	bf00      	nop
 80a0dc0:	bf00      	nop
 80a0dc2:	bf00      	nop
 80a0dc4:	bf00      	nop
 80a0dc6:	bf00      	nop
 80a0dc8:	bf00      	nop
 80a0dca:	bf00      	nop
 80a0dcc:	bf00      	nop
 80a0dce:	bf00      	nop
 80a0dd0:	bf00      	nop
 80a0dd2:	bf00      	nop
 80a0dd4:	bf00      	nop
 80a0dd6:	bf00      	nop
 80a0dd8:	bf00      	nop
 80a0dda:	bf00      	nop
 80a0ddc:	bf00      	nop
 80a0dde:	bf00      	nop
 80a0de0:	bf00      	nop
 80a0de2:	bf00      	nop
 80a0de4:	bf00      	nop
 80a0de6:	bf00      	nop
 80a0de8:	bf00      	nop
 80a0dea:	bf00      	nop
 80a0dec:	bf00      	nop
 80a0dee:	bf00      	nop
 80a0df0:	bf00      	nop
 80a0df2:	bf00      	nop
 80a0df4:	bf00      	nop
 80a0df6:	bf00      	nop
 80a0df8:	bf00      	nop
 80a0dfa:	bf00      	nop
 80a0dfc:	bf00      	nop
 80a0dfe:	bf00      	nop
 80a0e00:	bf00      	nop
 80a0e02:	bf00      	nop
        mask >>= 1;
 80a0e04:	9b04      	ldr	r3, [sp, #16]
 80a0e06:	085b      	lsrs	r3, r3, #1
 80a0e08:	9304      	str	r3, [sp, #16]
      } while ( ++j < 32 ); // ... pixel done
 80a0e0a:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a0e0e:	3301      	adds	r3, #1
 80a0e10:	b2db      	uxtb	r3, r3
 80a0e12:	2b1f      	cmp	r3, #31
 80a0e14:	f88d 3005 	strb.w	r3, [sp, #5]
 80a0e18:	d87e      	bhi.n	80a0f18 <_ZN17Adafruit_NeoPixel4showEv+0xaf4>
        pinSet(pin, HIGH); // HIGH
 80a0e1a:	79e3      	ldrb	r3, [r4, #7]
 80a0e1c:	6810      	ldr	r0, [r2, #0]
 80a0e1e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a0e22:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0e26:	88bf      	ldrh	r7, [r7, #4]
 80a0e28:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0e2c:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a0e2e:	9803      	ldr	r0, [sp, #12]
 80a0e30:	9b04      	ldr	r3, [sp, #16]
 80a0e32:	4218      	tst	r0, r3
 80a0e34:	f47f af76 	bne.w	80a0d24 <_ZN17Adafruit_NeoPixel4showEv+0x900>
            ::: "r0", "cc", "memory");
 80a0e38:	4600      	mov	r0, r0
 80a0e3a:	bf00      	nop
 80a0e3c:	bf00      	nop
 80a0e3e:	bf00      	nop
 80a0e40:	bf00      	nop
 80a0e42:	bf00      	nop
 80a0e44:	bf00      	nop
 80a0e46:	bf00      	nop
 80a0e48:	bf00      	nop
 80a0e4a:	bf00      	nop
 80a0e4c:	bf00      	nop
 80a0e4e:	bf00      	nop
 80a0e50:	bf00      	nop
 80a0e52:	bf00      	nop
 80a0e54:	bf00      	nop
 80a0e56:	bf00      	nop
 80a0e58:	bf00      	nop
 80a0e5a:	bf00      	nop
 80a0e5c:	bf00      	nop
 80a0e5e:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a0e60:	79e3      	ldrb	r3, [r4, #7]
 80a0e62:	6810      	ldr	r0, [r2, #0]
 80a0e64:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a0e68:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0e6c:	88bf      	ldrh	r7, [r7, #4]
 80a0e6e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0e72:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a0e74:	4600      	mov	r0, r0
 80a0e76:	bf00      	nop
 80a0e78:	bf00      	nop
 80a0e7a:	bf00      	nop
 80a0e7c:	bf00      	nop
 80a0e7e:	bf00      	nop
 80a0e80:	bf00      	nop
 80a0e82:	bf00      	nop
 80a0e84:	bf00      	nop
 80a0e86:	bf00      	nop
 80a0e88:	bf00      	nop
 80a0e8a:	bf00      	nop
 80a0e8c:	bf00      	nop
 80a0e8e:	bf00      	nop
 80a0e90:	bf00      	nop
 80a0e92:	bf00      	nop
 80a0e94:	bf00      	nop
 80a0e96:	bf00      	nop
 80a0e98:	bf00      	nop
 80a0e9a:	bf00      	nop
 80a0e9c:	bf00      	nop
 80a0e9e:	bf00      	nop
 80a0ea0:	bf00      	nop
 80a0ea2:	bf00      	nop
 80a0ea4:	bf00      	nop
 80a0ea6:	bf00      	nop
 80a0ea8:	bf00      	nop
 80a0eaa:	bf00      	nop
 80a0eac:	bf00      	nop
 80a0eae:	bf00      	nop
 80a0eb0:	bf00      	nop
 80a0eb2:	bf00      	nop
 80a0eb4:	bf00      	nop
 80a0eb6:	bf00      	nop
 80a0eb8:	bf00      	nop
 80a0eba:	bf00      	nop
 80a0ebc:	bf00      	nop
 80a0ebe:	bf00      	nop
 80a0ec0:	bf00      	nop
 80a0ec2:	bf00      	nop
 80a0ec4:	bf00      	nop
 80a0ec6:	bf00      	nop
 80a0ec8:	bf00      	nop
 80a0eca:	bf00      	nop
 80a0ecc:	bf00      	nop
 80a0ece:	bf00      	nop
 80a0ed0:	bf00      	nop
 80a0ed2:	bf00      	nop
 80a0ed4:	bf00      	nop
 80a0ed6:	bf00      	nop
 80a0ed8:	bf00      	nop
 80a0eda:	bf00      	nop
 80a0edc:	bf00      	nop
 80a0ede:	bf00      	nop
 80a0ee0:	bf00      	nop
 80a0ee2:	bf00      	nop
 80a0ee4:	bf00      	nop
 80a0ee6:	bf00      	nop
 80a0ee8:	bf00      	nop
 80a0eea:	bf00      	nop
 80a0eec:	bf00      	nop
 80a0eee:	bf00      	nop
 80a0ef0:	bf00      	nop
 80a0ef2:	bf00      	nop
 80a0ef4:	bf00      	nop
 80a0ef6:	bf00      	nop
 80a0ef8:	bf00      	nop
 80a0efa:	bf00      	nop
 80a0efc:	bf00      	nop
 80a0efe:	bf00      	nop
 80a0f00:	bf00      	nop
 80a0f02:	bf00      	nop
 80a0f04:	bf00      	nop
 80a0f06:	bf00      	nop
 80a0f08:	bf00      	nop
 80a0f0a:	bf00      	nop
 80a0f0c:	bf00      	nop
 80a0f0e:	bf00      	nop
 80a0f10:	bf00      	nop
 80a0f12:	bf00      	nop
 80a0f14:	bf00      	nop
 80a0f16:	e775      	b.n	80a0e04 <_ZN17Adafruit_NeoPixel4showEv+0x9e0>
    while(i) { // While bytes left... (4 bytes = 1 pixel)
 80a0f18:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a0f1c:	b29b      	uxth	r3, r3
 80a0f1e:	2b00      	cmp	r3, #0
 80a0f20:	f47f aecd 	bne.w	80a0cbe <_ZN17Adafruit_NeoPixel4showEv+0x89a>
 80a0f24:	e645      	b.n	80a0bb2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
 80a0f26:	2d03      	cmp	r5, #3
 80a0f28:	f000 812b 	beq.w	80a1182 <_ZN17Adafruit_NeoPixel4showEv+0xd5e>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a0f2c:	2b00      	cmp	r3, #0
 80a0f2e:	f43f ae40 	beq.w	80a0bb2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a0f32:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      j = 0;        // reset the 24-bit counter
 80a0f36:	2600      	movs	r6, #0
 80a0f38:	4a17      	ldr	r2, [pc, #92]	; (80a0f98 <_ZN17Adafruit_NeoPixel4showEv+0xb74>)
      mask = 0x800000; // reset the mask
 80a0f3a:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a0f3c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      pinSet(pin, LOW); // LOW
 80a0f40:	79e0      	ldrb	r0, [r4, #7]
      i = i-3;      // decrement bytes remaining
 80a0f42:	3b03      	subs	r3, #3
 80a0f44:	b29b      	uxth	r3, r3
 80a0f46:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a0f4a:	780b      	ldrb	r3, [r1, #0]
      pinSet(pin, LOW); // LOW
 80a0f4c:	6817      	ldr	r7, [r2, #0]
      r = *ptr++;   // Next red byte value
 80a0f4e:	b2db      	uxtb	r3, r3
 80a0f50:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a0f54:	784b      	ldrb	r3, [r1, #1]
      pinSet(pin, LOW); // LOW
 80a0f56:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
      b = *ptr++;   // Next blue byte value
 80a0f5a:	b2db      	uxtb	r3, r3
 80a0f5c:	f88d 3008 	strb.w	r3, [sp, #8]
      g = *ptr++;   // Next green byte value
 80a0f60:	788b      	ldrb	r3, [r1, #2]
      pinSet(pin, LOW); // LOW
 80a0f62:	eb07 0c80 	add.w	ip, r7, r0, lsl #2
      g = *ptr++;   // Next green byte value
 80a0f66:	b2db      	uxtb	r3, r3
 80a0f68:	f88d 3006 	strb.w	r3, [sp, #6]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a0f6c:	f89d e007 	ldrb.w	lr, [sp, #7]
 80a0f70:	f89d 3008 	ldrb.w	r3, [sp, #8]
      pinSet(pin, LOW); // LOW
 80a0f74:	f8bc c004 	ldrh.w	ip, [ip, #4]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a0f78:	021b      	lsls	r3, r3, #8
 80a0f7a:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 80a0f7e:	f89d e006 	ldrb.w	lr, [sp, #6]
      pinSet(pin, LOW); // LOW
 80a0f82:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a0f86:	ea43 030e 	orr.w	r3, r3, lr
 80a0f8a:	9303      	str	r3, [sp, #12]
      g = *ptr++;   // Next green byte value
 80a0f8c:	3103      	adds	r1, #3
      j = 0;        // reset the 24-bit counter
 80a0f8e:	f88d 6005 	strb.w	r6, [sp, #5]
      pinSet(pin, LOW); // LOW
 80a0f92:	f8a0 c01a 	strh.w	ip, [r0, #26]
 80a0f96:	e07c      	b.n	80a1092 <_ZN17Adafruit_NeoPixel4showEv+0xc6e>
 80a0f98:	200000d0 	.word	0x200000d0
          mask >>= 1; // Do this task during the long delay of this bit
 80a0f9c:	9b04      	ldr	r3, [sp, #16]
 80a0f9e:	085b      	lsrs	r3, r3, #1
 80a0fa0:	9304      	str	r3, [sp, #16]
            ::: "r0", "cc", "memory");
 80a0fa2:	4600      	mov	r0, r0
 80a0fa4:	bf00      	nop
 80a0fa6:	bf00      	nop
 80a0fa8:	bf00      	nop
 80a0faa:	bf00      	nop
 80a0fac:	bf00      	nop
 80a0fae:	bf00      	nop
 80a0fb0:	bf00      	nop
 80a0fb2:	bf00      	nop
 80a0fb4:	bf00      	nop
 80a0fb6:	bf00      	nop
 80a0fb8:	bf00      	nop
 80a0fba:	bf00      	nop
 80a0fbc:	bf00      	nop
 80a0fbe:	bf00      	nop
 80a0fc0:	bf00      	nop
 80a0fc2:	bf00      	nop
 80a0fc4:	bf00      	nop
 80a0fc6:	bf00      	nop
 80a0fc8:	bf00      	nop
 80a0fca:	bf00      	nop
 80a0fcc:	bf00      	nop
 80a0fce:	bf00      	nop
 80a0fd0:	bf00      	nop
 80a0fd2:	bf00      	nop
 80a0fd4:	bf00      	nop
 80a0fd6:	bf00      	nop
 80a0fd8:	bf00      	nop
 80a0fda:	bf00      	nop
 80a0fdc:	bf00      	nop
 80a0fde:	bf00      	nop
 80a0fe0:	bf00      	nop
 80a0fe2:	bf00      	nop
 80a0fe4:	bf00      	nop
 80a0fe6:	bf00      	nop
 80a0fe8:	bf00      	nop
 80a0fea:	bf00      	nop
 80a0fec:	bf00      	nop
 80a0fee:	bf00      	nop
 80a0ff0:	bf00      	nop
 80a0ff2:	bf00      	nop
 80a0ff4:	bf00      	nop
 80a0ff6:	bf00      	nop
 80a0ff8:	bf00      	nop
 80a0ffa:	bf00      	nop
 80a0ffc:	bf00      	nop
 80a0ffe:	bf00      	nop
 80a1000:	bf00      	nop
 80a1002:	bf00      	nop
 80a1004:	bf00      	nop
 80a1006:	bf00      	nop
 80a1008:	bf00      	nop
 80a100a:	bf00      	nop
 80a100c:	bf00      	nop
 80a100e:	bf00      	nop
 80a1010:	bf00      	nop
 80a1012:	bf00      	nop
 80a1014:	bf00      	nop
 80a1016:	bf00      	nop
 80a1018:	bf00      	nop
 80a101a:	bf00      	nop
 80a101c:	bf00      	nop
 80a101e:	bf00      	nop
 80a1020:	bf00      	nop
 80a1022:	bf00      	nop
 80a1024:	bf00      	nop
 80a1026:	bf00      	nop
          pinSet(pin, HIGH); // HIGH
 80a1028:	79e0      	ldrb	r0, [r4, #7]
 80a102a:	6817      	ldr	r7, [r2, #0]
          j++;
 80a102c:	f89d 3005 	ldrb.w	r3, [sp, #5]
          pinSet(pin, HIGH); // HIGH
 80a1030:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 80a1034:	eb07 0c80 	add.w	ip, r7, r0, lsl #2
 80a1038:	f8bc c004 	ldrh.w	ip, [ip, #4]
 80a103c:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
          j++;
 80a1040:	3301      	adds	r3, #1
 80a1042:	b2db      	uxtb	r3, r3
 80a1044:	f88d 3005 	strb.w	r3, [sp, #5]
          pinSet(pin, HIGH); // HIGH
 80a1048:	f8a0 c018 	strh.w	ip, [r0, #24]
            ::: "r0", "cc", "memory");
 80a104c:	4600      	mov	r0, r0
 80a104e:	bf00      	nop
 80a1050:	bf00      	nop
 80a1052:	bf00      	nop
 80a1054:	bf00      	nop
 80a1056:	bf00      	nop
 80a1058:	bf00      	nop
 80a105a:	bf00      	nop
 80a105c:	bf00      	nop
 80a105e:	bf00      	nop
 80a1060:	bf00      	nop
 80a1062:	bf00      	nop
 80a1064:	bf00      	nop
 80a1066:	bf00      	nop
 80a1068:	bf00      	nop
 80a106a:	bf00      	nop
 80a106c:	bf00      	nop
 80a106e:	bf00      	nop
 80a1070:	bf00      	nop
 80a1072:	bf00      	nop
 80a1074:	bf00      	nop
          if(j==24) break;
 80a1076:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a107a:	2b18      	cmp	r3, #24
 80a107c:	d07a      	beq.n	80a1174 <_ZN17Adafruit_NeoPixel4showEv+0xd50>
          pinSet(pin, LOW); // LOW
 80a107e:	79e3      	ldrb	r3, [r4, #7]
 80a1080:	6810      	ldr	r0, [r2, #0]
 80a1082:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1086:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a108a:	88bf      	ldrh	r7, [r7, #4]
 80a108c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1090:	835f      	strh	r7, [r3, #26]
        if (c & mask) { // if masked bit is high
 80a1092:	9803      	ldr	r0, [sp, #12]
 80a1094:	9b04      	ldr	r3, [sp, #16]
 80a1096:	4218      	tst	r0, r3
 80a1098:	d180      	bne.n	80a0f9c <_ZN17Adafruit_NeoPixel4showEv+0xb78>
            ::: "r0", "cc", "memory");
 80a109a:	4600      	mov	r0, r0
 80a109c:	bf00      	nop
 80a109e:	bf00      	nop
 80a10a0:	bf00      	nop
 80a10a2:	bf00      	nop
 80a10a4:	bf00      	nop
 80a10a6:	bf00      	nop
 80a10a8:	bf00      	nop
 80a10aa:	bf00      	nop
 80a10ac:	bf00      	nop
 80a10ae:	bf00      	nop
 80a10b0:	bf00      	nop
 80a10b2:	bf00      	nop
 80a10b4:	bf00      	nop
 80a10b6:	bf00      	nop
 80a10b8:	bf00      	nop
 80a10ba:	bf00      	nop
          pinSet(pin, HIGH); // HIGH
 80a10bc:	79e3      	ldrb	r3, [r4, #7]
 80a10be:	6810      	ldr	r0, [r2, #0]
 80a10c0:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a10c4:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a10c8:	88bf      	ldrh	r7, [r7, #4]
 80a10ca:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a10ce:	831f      	strh	r7, [r3, #24]
          j++;
 80a10d0:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a10d4:	3301      	adds	r3, #1
 80a10d6:	b2db      	uxtb	r3, r3
 80a10d8:	f88d 3005 	strb.w	r3, [sp, #5]
          mask >>= 1; // Do this task during the long delay of this bit
 80a10dc:	9b04      	ldr	r3, [sp, #16]
 80a10de:	085b      	lsrs	r3, r3, #1
 80a10e0:	9304      	str	r3, [sp, #16]
            ::: "r0", "cc", "memory");
 80a10e2:	4600      	mov	r0, r0
 80a10e4:	bf00      	nop
 80a10e6:	bf00      	nop
 80a10e8:	bf00      	nop
 80a10ea:	bf00      	nop
 80a10ec:	bf00      	nop
 80a10ee:	bf00      	nop
 80a10f0:	bf00      	nop
 80a10f2:	bf00      	nop
 80a10f4:	bf00      	nop
 80a10f6:	bf00      	nop
 80a10f8:	bf00      	nop
 80a10fa:	bf00      	nop
 80a10fc:	bf00      	nop
 80a10fe:	bf00      	nop
 80a1100:	bf00      	nop
 80a1102:	bf00      	nop
 80a1104:	bf00      	nop
 80a1106:	bf00      	nop
 80a1108:	bf00      	nop
 80a110a:	bf00      	nop
 80a110c:	bf00      	nop
 80a110e:	bf00      	nop
 80a1110:	bf00      	nop
 80a1112:	bf00      	nop
 80a1114:	bf00      	nop
 80a1116:	bf00      	nop
 80a1118:	bf00      	nop
 80a111a:	bf00      	nop
 80a111c:	bf00      	nop
 80a111e:	bf00      	nop
 80a1120:	bf00      	nop
 80a1122:	bf00      	nop
 80a1124:	bf00      	nop
 80a1126:	bf00      	nop
 80a1128:	bf00      	nop
 80a112a:	bf00      	nop
 80a112c:	bf00      	nop
 80a112e:	bf00      	nop
 80a1130:	bf00      	nop
 80a1132:	bf00      	nop
 80a1134:	bf00      	nop
 80a1136:	bf00      	nop
 80a1138:	bf00      	nop
 80a113a:	bf00      	nop
 80a113c:	bf00      	nop
 80a113e:	bf00      	nop
 80a1140:	bf00      	nop
 80a1142:	bf00      	nop
 80a1144:	bf00      	nop
 80a1146:	bf00      	nop
 80a1148:	bf00      	nop
 80a114a:	bf00      	nop
 80a114c:	bf00      	nop
 80a114e:	bf00      	nop
 80a1150:	bf00      	nop
 80a1152:	bf00      	nop
 80a1154:	bf00      	nop
 80a1156:	bf00      	nop
 80a1158:	bf00      	nop
 80a115a:	bf00      	nop
 80a115c:	bf00      	nop
 80a115e:	bf00      	nop
 80a1160:	bf00      	nop
 80a1162:	bf00      	nop
 80a1164:	bf00      	nop
 80a1166:	bf00      	nop
 80a1168:	bf00      	nop
 80a116a:	bf00      	nop
          if(j==24) break;
 80a116c:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a1170:	2b18      	cmp	r3, #24
 80a1172:	d184      	bne.n	80a107e <_ZN17Adafruit_NeoPixel4showEv+0xc5a>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1174:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a1178:	b29b      	uxth	r3, r3
 80a117a:	2b00      	cmp	r3, #0
 80a117c:	f47f aedd 	bne.w	80a0f3a <_ZN17Adafruit_NeoPixel4showEv+0xb16>
 80a1180:	e517      	b.n	80a0bb2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1182:	2b00      	cmp	r3, #0
 80a1184:	f43f ad15 	beq.w	80a0bb2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a1188:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      j = 0;        // reset the 24-bit counter
 80a118c:	2600      	movs	r6, #0
 80a118e:	4a13      	ldr	r2, [pc, #76]	; (80a11dc <_ZN17Adafruit_NeoPixel4showEv+0xdb8>)
      mask = 0x800000; // reset the mask
 80a1190:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a1192:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      b = *ptr++;   // Next green byte value
 80a1196:	3103      	adds	r1, #3
      i = i-3;      // decrement bytes remaining
 80a1198:	3b03      	subs	r3, #3
 80a119a:	b29b      	uxth	r3, r3
 80a119c:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a11a0:	f811 3c03 	ldrb.w	r3, [r1, #-3]
 80a11a4:	b2db      	uxtb	r3, r3
 80a11a6:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next blue byte value
 80a11aa:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 80a11ae:	b2db      	uxtb	r3, r3
 80a11b0:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next green byte value
 80a11b4:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 80a11b8:	b2db      	uxtb	r3, r3
 80a11ba:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a11be:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a11c2:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a11c6:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a11ca:	021b      	lsls	r3, r3, #8
 80a11cc:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a11d0:	4303      	orrs	r3, r0
 80a11d2:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a11d4:	f88d 6005 	strb.w	r6, [sp, #5]
 80a11d8:	e0e1      	b.n	80a139e <_ZN17Adafruit_NeoPixel4showEv+0xf7a>
 80a11da:	bf00      	nop
 80a11dc:	200000d0 	.word	0x200000d0
            ::: "r0", "cc", "memory");
 80a11e0:	4600      	mov	r0, r0
 80a11e2:	bf00      	nop
 80a11e4:	bf00      	nop
 80a11e6:	bf00      	nop
 80a11e8:	bf00      	nop
 80a11ea:	bf00      	nop
 80a11ec:	bf00      	nop
 80a11ee:	bf00      	nop
 80a11f0:	bf00      	nop
 80a11f2:	bf00      	nop
 80a11f4:	bf00      	nop
 80a11f6:	bf00      	nop
 80a11f8:	bf00      	nop
 80a11fa:	bf00      	nop
 80a11fc:	bf00      	nop
 80a11fe:	bf00      	nop
 80a1200:	bf00      	nop
 80a1202:	bf00      	nop
 80a1204:	bf00      	nop
 80a1206:	bf00      	nop
 80a1208:	bf00      	nop
 80a120a:	bf00      	nop
 80a120c:	bf00      	nop
 80a120e:	bf00      	nop
 80a1210:	bf00      	nop
 80a1212:	bf00      	nop
 80a1214:	bf00      	nop
 80a1216:	bf00      	nop
 80a1218:	bf00      	nop
 80a121a:	bf00      	nop
 80a121c:	bf00      	nop
 80a121e:	bf00      	nop
 80a1220:	bf00      	nop
 80a1222:	bf00      	nop
 80a1224:	bf00      	nop
 80a1226:	bf00      	nop
 80a1228:	bf00      	nop
 80a122a:	bf00      	nop
 80a122c:	bf00      	nop
 80a122e:	bf00      	nop
 80a1230:	bf00      	nop
 80a1232:	bf00      	nop
 80a1234:	bf00      	nop
 80a1236:	bf00      	nop
 80a1238:	bf00      	nop
 80a123a:	bf00      	nop
 80a123c:	bf00      	nop
 80a123e:	bf00      	nop
 80a1240:	bf00      	nop
 80a1242:	bf00      	nop
 80a1244:	bf00      	nop
 80a1246:	bf00      	nop
 80a1248:	bf00      	nop
 80a124a:	bf00      	nop
 80a124c:	bf00      	nop
 80a124e:	bf00      	nop
 80a1250:	bf00      	nop
 80a1252:	bf00      	nop
 80a1254:	bf00      	nop
 80a1256:	bf00      	nop
 80a1258:	bf00      	nop
 80a125a:	bf00      	nop
 80a125c:	bf00      	nop
 80a125e:	bf00      	nop
 80a1260:	bf00      	nop
 80a1262:	bf00      	nop
 80a1264:	bf00      	nop
 80a1266:	bf00      	nop
 80a1268:	bf00      	nop
 80a126a:	bf00      	nop
 80a126c:	bf00      	nop
 80a126e:	bf00      	nop
 80a1270:	bf00      	nop
 80a1272:	bf00      	nop
 80a1274:	bf00      	nop
 80a1276:	bf00      	nop
 80a1278:	bf00      	nop
 80a127a:	bf00      	nop
 80a127c:	bf00      	nop
 80a127e:	bf00      	nop
 80a1280:	bf00      	nop
 80a1282:	bf00      	nop
 80a1284:	bf00      	nop
 80a1286:	bf00      	nop
 80a1288:	bf00      	nop
 80a128a:	bf00      	nop
 80a128c:	bf00      	nop
 80a128e:	bf00      	nop
 80a1290:	bf00      	nop
 80a1292:	bf00      	nop
 80a1294:	bf00      	nop
 80a1296:	bf00      	nop
 80a1298:	bf00      	nop
 80a129a:	bf00      	nop
 80a129c:	bf00      	nop
 80a129e:	bf00      	nop
 80a12a0:	bf00      	nop
 80a12a2:	bf00      	nop
 80a12a4:	bf00      	nop
 80a12a6:	bf00      	nop
 80a12a8:	bf00      	nop
 80a12aa:	bf00      	nop
 80a12ac:	bf00      	nop
 80a12ae:	bf00      	nop
 80a12b0:	bf00      	nop
 80a12b2:	bf00      	nop
 80a12b4:	bf00      	nop
 80a12b6:	bf00      	nop
 80a12b8:	bf00      	nop
 80a12ba:	bf00      	nop
 80a12bc:	bf00      	nop
 80a12be:	bf00      	nop
 80a12c0:	bf00      	nop
 80a12c2:	bf00      	nop
 80a12c4:	bf00      	nop
 80a12c6:	bf00      	nop
 80a12c8:	bf00      	nop
 80a12ca:	bf00      	nop
 80a12cc:	bf00      	nop
 80a12ce:	bf00      	nop
 80a12d0:	bf00      	nop
 80a12d2:	bf00      	nop
 80a12d4:	bf00      	nop
 80a12d6:	bf00      	nop
 80a12d8:	bf00      	nop
 80a12da:	bf00      	nop
 80a12dc:	bf00      	nop
 80a12de:	bf00      	nop
 80a12e0:	bf00      	nop
 80a12e2:	bf00      	nop
 80a12e4:	bf00      	nop
 80a12e6:	bf00      	nop
 80a12e8:	bf00      	nop
 80a12ea:	bf00      	nop
 80a12ec:	bf00      	nop
 80a12ee:	bf00      	nop
 80a12f0:	bf00      	nop
 80a12f2:	bf00      	nop
 80a12f4:	bf00      	nop
 80a12f6:	bf00      	nop
 80a12f8:	bf00      	nop
 80a12fa:	bf00      	nop
 80a12fc:	bf00      	nop
 80a12fe:	bf00      	nop
 80a1300:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a1302:	79e3      	ldrb	r3, [r4, #7]
 80a1304:	6810      	ldr	r0, [r2, #0]
 80a1306:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a130a:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a130e:	88bf      	ldrh	r7, [r7, #4]
 80a1310:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1314:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a1316:	4600      	mov	r0, r0
 80a1318:	bf00      	nop
 80a131a:	bf00      	nop
 80a131c:	bf00      	nop
 80a131e:	bf00      	nop
 80a1320:	bf00      	nop
 80a1322:	bf00      	nop
 80a1324:	bf00      	nop
 80a1326:	bf00      	nop
 80a1328:	bf00      	nop
 80a132a:	bf00      	nop
 80a132c:	bf00      	nop
 80a132e:	bf00      	nop
 80a1330:	bf00      	nop
 80a1332:	bf00      	nop
 80a1334:	bf00      	nop
 80a1336:	bf00      	nop
 80a1338:	bf00      	nop
 80a133a:	bf00      	nop
 80a133c:	bf00      	nop
 80a133e:	bf00      	nop
 80a1340:	bf00      	nop
 80a1342:	bf00      	nop
 80a1344:	bf00      	nop
 80a1346:	bf00      	nop
 80a1348:	bf00      	nop
 80a134a:	bf00      	nop
 80a134c:	bf00      	nop
 80a134e:	bf00      	nop
 80a1350:	bf00      	nop
 80a1352:	bf00      	nop
 80a1354:	bf00      	nop
 80a1356:	bf00      	nop
 80a1358:	bf00      	nop
 80a135a:	bf00      	nop
 80a135c:	bf00      	nop
 80a135e:	bf00      	nop
 80a1360:	bf00      	nop
 80a1362:	bf00      	nop
 80a1364:	bf00      	nop
 80a1366:	bf00      	nop
 80a1368:	bf00      	nop
 80a136a:	bf00      	nop
 80a136c:	bf00      	nop
 80a136e:	bf00      	nop
 80a1370:	bf00      	nop
 80a1372:	bf00      	nop
 80a1374:	bf00      	nop
 80a1376:	bf00      	nop
 80a1378:	bf00      	nop
 80a137a:	bf00      	nop
 80a137c:	bf00      	nop
 80a137e:	bf00      	nop
 80a1380:	bf00      	nop
 80a1382:	bf00      	nop
 80a1384:	bf00      	nop
        mask >>= 1;
 80a1386:	9b04      	ldr	r3, [sp, #16]
 80a1388:	085b      	lsrs	r3, r3, #1
 80a138a:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a138c:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a1390:	3301      	adds	r3, #1
 80a1392:	b2db      	uxtb	r3, r3
 80a1394:	2b17      	cmp	r3, #23
 80a1396:	f88d 3005 	strb.w	r3, [sp, #5]
 80a139a:	f200 80eb 	bhi.w	80a1574 <_ZN17Adafruit_NeoPixel4showEv+0x1150>
        pinSet(pin, HIGH); // HIGH
 80a139e:	79e3      	ldrb	r3, [r4, #7]
 80a13a0:	6810      	ldr	r0, [r2, #0]
 80a13a2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a13a6:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a13aa:	88bf      	ldrh	r7, [r7, #4]
 80a13ac:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a13b0:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a13b2:	9803      	ldr	r0, [sp, #12]
 80a13b4:	9b04      	ldr	r3, [sp, #16]
 80a13b6:	4218      	tst	r0, r3
 80a13b8:	f47f af12 	bne.w	80a11e0 <_ZN17Adafruit_NeoPixel4showEv+0xdbc>
            ::: "r0", "cc", "memory");
 80a13bc:	4600      	mov	r0, r0
 80a13be:	bf00      	nop
 80a13c0:	bf00      	nop
 80a13c2:	bf00      	nop
 80a13c4:	bf00      	nop
 80a13c6:	bf00      	nop
 80a13c8:	bf00      	nop
 80a13ca:	bf00      	nop
 80a13cc:	bf00      	nop
 80a13ce:	bf00      	nop
 80a13d0:	bf00      	nop
 80a13d2:	bf00      	nop
 80a13d4:	bf00      	nop
 80a13d6:	bf00      	nop
 80a13d8:	bf00      	nop
 80a13da:	bf00      	nop
 80a13dc:	bf00      	nop
 80a13de:	bf00      	nop
 80a13e0:	bf00      	nop
 80a13e2:	bf00      	nop
 80a13e4:	bf00      	nop
 80a13e6:	bf00      	nop
 80a13e8:	bf00      	nop
 80a13ea:	bf00      	nop
 80a13ec:	bf00      	nop
 80a13ee:	bf00      	nop
 80a13f0:	bf00      	nop
 80a13f2:	bf00      	nop
 80a13f4:	bf00      	nop
 80a13f6:	bf00      	nop
 80a13f8:	bf00      	nop
 80a13fa:	bf00      	nop
 80a13fc:	bf00      	nop
 80a13fe:	bf00      	nop
 80a1400:	bf00      	nop
 80a1402:	bf00      	nop
 80a1404:	bf00      	nop
 80a1406:	bf00      	nop
 80a1408:	bf00      	nop
 80a140a:	bf00      	nop
 80a140c:	bf00      	nop
 80a140e:	bf00      	nop
 80a1410:	bf00      	nop
 80a1412:	bf00      	nop
 80a1414:	bf00      	nop
 80a1416:	bf00      	nop
 80a1418:	bf00      	nop
 80a141a:	bf00      	nop
 80a141c:	bf00      	nop
 80a141e:	bf00      	nop
 80a1420:	bf00      	nop
 80a1422:	bf00      	nop
 80a1424:	bf00      	nop
 80a1426:	bf00      	nop
 80a1428:	bf00      	nop
 80a142a:	bf00      	nop
 80a142c:	bf00      	nop
 80a142e:	bf00      	nop
 80a1430:	bf00      	nop
 80a1432:	bf00      	nop
 80a1434:	bf00      	nop
 80a1436:	bf00      	nop
 80a1438:	bf00      	nop
 80a143a:	bf00      	nop
 80a143c:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a143e:	79e3      	ldrb	r3, [r4, #7]
 80a1440:	6810      	ldr	r0, [r2, #0]
 80a1442:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1446:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a144a:	88bf      	ldrh	r7, [r7, #4]
 80a144c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1450:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a1452:	4600      	mov	r0, r0
 80a1454:	bf00      	nop
 80a1456:	bf00      	nop
 80a1458:	bf00      	nop
 80a145a:	bf00      	nop
 80a145c:	bf00      	nop
 80a145e:	bf00      	nop
 80a1460:	bf00      	nop
 80a1462:	bf00      	nop
 80a1464:	bf00      	nop
 80a1466:	bf00      	nop
 80a1468:	bf00      	nop
 80a146a:	bf00      	nop
 80a146c:	bf00      	nop
 80a146e:	bf00      	nop
 80a1470:	bf00      	nop
 80a1472:	bf00      	nop
 80a1474:	bf00      	nop
 80a1476:	bf00      	nop
 80a1478:	bf00      	nop
 80a147a:	bf00      	nop
 80a147c:	bf00      	nop
 80a147e:	bf00      	nop
 80a1480:	bf00      	nop
 80a1482:	bf00      	nop
 80a1484:	bf00      	nop
 80a1486:	bf00      	nop
 80a1488:	bf00      	nop
 80a148a:	bf00      	nop
 80a148c:	bf00      	nop
 80a148e:	bf00      	nop
 80a1490:	bf00      	nop
 80a1492:	bf00      	nop
 80a1494:	bf00      	nop
 80a1496:	bf00      	nop
 80a1498:	bf00      	nop
 80a149a:	bf00      	nop
 80a149c:	bf00      	nop
 80a149e:	bf00      	nop
 80a14a0:	bf00      	nop
 80a14a2:	bf00      	nop
 80a14a4:	bf00      	nop
 80a14a6:	bf00      	nop
 80a14a8:	bf00      	nop
 80a14aa:	bf00      	nop
 80a14ac:	bf00      	nop
 80a14ae:	bf00      	nop
 80a14b0:	bf00      	nop
 80a14b2:	bf00      	nop
 80a14b4:	bf00      	nop
 80a14b6:	bf00      	nop
 80a14b8:	bf00      	nop
 80a14ba:	bf00      	nop
 80a14bc:	bf00      	nop
 80a14be:	bf00      	nop
 80a14c0:	bf00      	nop
 80a14c2:	bf00      	nop
 80a14c4:	bf00      	nop
 80a14c6:	bf00      	nop
 80a14c8:	bf00      	nop
 80a14ca:	bf00      	nop
 80a14cc:	bf00      	nop
 80a14ce:	bf00      	nop
 80a14d0:	bf00      	nop
 80a14d2:	bf00      	nop
 80a14d4:	bf00      	nop
 80a14d6:	bf00      	nop
 80a14d8:	bf00      	nop
 80a14da:	bf00      	nop
 80a14dc:	bf00      	nop
 80a14de:	bf00      	nop
 80a14e0:	bf00      	nop
 80a14e2:	bf00      	nop
 80a14e4:	bf00      	nop
 80a14e6:	bf00      	nop
 80a14e8:	bf00      	nop
 80a14ea:	bf00      	nop
 80a14ec:	bf00      	nop
 80a14ee:	bf00      	nop
 80a14f0:	bf00      	nop
 80a14f2:	bf00      	nop
 80a14f4:	bf00      	nop
 80a14f6:	bf00      	nop
 80a14f8:	bf00      	nop
 80a14fa:	bf00      	nop
 80a14fc:	bf00      	nop
 80a14fe:	bf00      	nop
 80a1500:	bf00      	nop
 80a1502:	bf00      	nop
 80a1504:	bf00      	nop
 80a1506:	bf00      	nop
 80a1508:	bf00      	nop
 80a150a:	bf00      	nop
 80a150c:	bf00      	nop
 80a150e:	bf00      	nop
 80a1510:	bf00      	nop
 80a1512:	bf00      	nop
 80a1514:	bf00      	nop
 80a1516:	bf00      	nop
 80a1518:	bf00      	nop
 80a151a:	bf00      	nop
 80a151c:	bf00      	nop
 80a151e:	bf00      	nop
 80a1520:	bf00      	nop
 80a1522:	bf00      	nop
 80a1524:	bf00      	nop
 80a1526:	bf00      	nop
 80a1528:	bf00      	nop
 80a152a:	bf00      	nop
 80a152c:	bf00      	nop
 80a152e:	bf00      	nop
 80a1530:	bf00      	nop
 80a1532:	bf00      	nop
 80a1534:	bf00      	nop
 80a1536:	bf00      	nop
 80a1538:	bf00      	nop
 80a153a:	bf00      	nop
 80a153c:	bf00      	nop
 80a153e:	bf00      	nop
 80a1540:	bf00      	nop
 80a1542:	bf00      	nop
 80a1544:	bf00      	nop
 80a1546:	bf00      	nop
 80a1548:	bf00      	nop
 80a154a:	bf00      	nop
 80a154c:	bf00      	nop
 80a154e:	bf00      	nop
 80a1550:	bf00      	nop
 80a1552:	bf00      	nop
 80a1554:	bf00      	nop
 80a1556:	bf00      	nop
 80a1558:	bf00      	nop
 80a155a:	bf00      	nop
 80a155c:	bf00      	nop
 80a155e:	bf00      	nop
 80a1560:	bf00      	nop
 80a1562:	e710      	b.n	80a1386 <_ZN17Adafruit_NeoPixel4showEv+0xf62>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1564:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a1568:	b29b      	uxth	r3, r3
 80a156a:	2b00      	cmp	r3, #0
 80a156c:	f47e af92 	bne.w	80a0494 <_ZN17Adafruit_NeoPixel4showEv+0x70>
 80a1570:	f7ff bb1f 	b.w	80a0bb2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1574:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a1578:	b29b      	uxth	r3, r3
 80a157a:	2b00      	cmp	r3, #0
 80a157c:	f47f ae08 	bne.w	80a1190 <_ZN17Adafruit_NeoPixel4showEv+0xd6c>
 80a1580:	f7ff bb17 	b.w	80a0bb2 <_ZN17Adafruit_NeoPixel4showEv+0x78e>

080a1584 <_ZN17Adafruit_NeoPixel13setPixelColorEtm>:
}

// Set pixel color from 'packed' 32-bit RGB color:
// If RGB+W color, order of bytes is WRGB in packed 32-bit form
void Adafruit_NeoPixel::setPixelColor(uint16_t n, uint32_t c) {
  if(n < numLEDs) {
 80a1584:	8843      	ldrh	r3, [r0, #2]
void Adafruit_NeoPixel::setPixelColor(uint16_t n, uint32_t c) {
 80a1586:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(n < numLEDs) {
 80a1588:	428b      	cmp	r3, r1
 80a158a:	d926      	bls.n	80a15da <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x56>
    uint8_t
      r = (uint8_t)(c >> 16),
      g = (uint8_t)(c >>  8),
      b = (uint8_t)c;
    if(brightness) { // See notes in setBrightness()
 80a158c:	7a05      	ldrb	r5, [r0, #8]
 80a158e:	f3c2 4307 	ubfx	r3, r2, #16, #8
 80a1592:	f3c2 2407 	ubfx	r4, r2, #8, #8
 80a1596:	b2d6      	uxtb	r6, r2
 80a1598:	b13d      	cbz	r5, 80a15aa <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x26>
      r = (r * brightness) >> 8;
 80a159a:	436b      	muls	r3, r5
      g = (g * brightness) >> 8;
 80a159c:	436c      	muls	r4, r5
      b = (b * brightness) >> 8;
 80a159e:	436e      	muls	r6, r5
      r = (r * brightness) >> 8;
 80a15a0:	f3c3 2307 	ubfx	r3, r3, #8, #8
      g = (g * brightness) >> 8;
 80a15a4:	f3c4 2407 	ubfx	r4, r4, #8, #8
      b = (b * brightness) >> 8;
 80a15a8:	0a36      	lsrs	r6, r6, #8
    }
    uint8_t *p = &pixels[n * (type==SK6812RGBW?4:3)];
 80a15aa:	f890 c006 	ldrb.w	ip, [r0, #6]
 80a15ae:	68c7      	ldr	r7, [r0, #12]
 80a15b0:	f1bc 0f06 	cmp.w	ip, #6
 80a15b4:	bf0c      	ite	eq
 80a15b6:	2504      	moveq	r5, #4
 80a15b8:	2503      	movne	r5, #3
 80a15ba:	4369      	muls	r1, r5
 80a15bc:	f1ac 0c02 	sub.w	ip, ip, #2
 80a15c0:	187d      	adds	r5, r7, r1
    switch(type) {
 80a15c2:	f1bc 0f06 	cmp.w	ip, #6
 80a15c6:	d81d      	bhi.n	80a1604 <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x80>
 80a15c8:	e8df f00c 	tbb	[pc, ip]
 80a15cc:	04081c04 	.word	0x04081c04
 80a15d0:	040f      	.short	0x040f
 80a15d2:	04          	.byte	0x04
 80a15d3:	00          	.byte	0x00
      case WS2812B: // WS2812, WS2812B & WS2813 is GRB order.
      case WS2812B_FAST:
      case WS2812B2:
      case WS2812B2_FAST: {
          *p++ = g;
 80a15d4:	547c      	strb	r4, [r7, r1]
          *p++ = r;
 80a15d6:	706b      	strb	r3, [r5, #1]
          *p = b;
 80a15d8:	70ae      	strb	r6, [r5, #2]
          *p++ = g;
          *p = b;
        } break;
    }
  }
}
 80a15da:	bdf0      	pop	{r4, r5, r6, r7, pc}
          *p++ = r;
 80a15dc:	2bfe      	cmp	r3, #254	; 0xfe
 80a15de:	bf28      	it	cs
 80a15e0:	23fe      	movcs	r3, #254	; 0xfe
 80a15e2:	547b      	strb	r3, [r7, r1]
          *p++ = b;
 80a15e4:	706e      	strb	r6, [r5, #1]
          *p = g;
 80a15e6:	70ac      	strb	r4, [r5, #2]
        } break;
 80a15e8:	e7f7      	b.n	80a15da <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x56>
          *p++ = r;
 80a15ea:	547b      	strb	r3, [r7, r1]
          *p++ = g;
 80a15ec:	706c      	strb	r4, [r5, #1]
          *p++ = b;
 80a15ee:	70ae      	strb	r6, [r5, #2]
          *p = brightness ? ((w * brightness) >> 8) : w;
 80a15f0:	7a03      	ldrb	r3, [r0, #8]
          uint8_t w = (uint8_t)(c >> 24);
 80a15f2:	0e12      	lsrs	r2, r2, #24
          *p = brightness ? ((w * brightness) >> 8) : w;
 80a15f4:	b913      	cbnz	r3, 80a15fc <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x78>
          uint8_t w = (uint8_t)(c >> 24);
 80a15f6:	b2d2      	uxtb	r2, r2
          *p = brightness ? ((w * brightness) >> 8) : w;
 80a15f8:	70ea      	strb	r2, [r5, #3]
        } break;
 80a15fa:	e7ee      	b.n	80a15da <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x56>
          *p = brightness ? ((w * brightness) >> 8) : w;
 80a15fc:	435a      	muls	r2, r3
 80a15fe:	f3c2 2207 	ubfx	r2, r2, #8, #8
 80a1602:	e7f9      	b.n	80a15f8 <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x74>
          *p++ = r;
 80a1604:	547b      	strb	r3, [r7, r1]
          *p++ = g;
 80a1606:	706c      	strb	r4, [r5, #1]
          *p = b;
 80a1608:	70ae      	strb	r6, [r5, #2]
}
 80a160a:	e7e6      	b.n	80a15da <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x56>

080a160c <_ZN17Adafruit_NeoPixel5ColorEhhh>:
}

// Convert separate R,G,B into packed 32-bit RGB color.
// Packed format is always RGB, regardless of LED strand color order.
uint32_t Adafruit_NeoPixel::Color(uint8_t r, uint8_t g, uint8_t b) {
  return ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b;
 80a160c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
}
 80a1610:	ea42 4000 	orr.w	r0, r2, r0, lsl #16
 80a1614:	4770      	bx	lr
	...

080a1618 <_GLOBAL__sub_I_PIN_MAP2>:
  return brightness - 1;
}

void Adafruit_NeoPixel::clear(void) {
  memset(pixels, 0, numBytes);
}
 80a1618:	b508      	push	{r3, lr}
  STM32_Pin_Info* PIN_MAP2 = HAL_Pin_Map(); // Pointer required for highest access speed
 80a161a:	f000 f805 	bl	80a1628 <HAL_Pin_Map>
 80a161e:	4b01      	ldr	r3, [pc, #4]	; (80a1624 <_GLOBAL__sub_I_PIN_MAP2+0xc>)
 80a1620:	6018      	str	r0, [r3, #0]
}
 80a1622:	bd08      	pop	{r3, pc}
 80a1624:	200000d0 	.word	0x200000d0

080a1628 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, Hal_Pin_Info*(void))
 80a1628:	b508      	push	{r3, lr}
 80a162a:	4b02      	ldr	r3, [pc, #8]	; (80a1634 <HAL_Pin_Map+0xc>)
 80a162c:	681b      	ldr	r3, [r3, #0]
 80a162e:	681b      	ldr	r3, [r3, #0]
 80a1630:	9301      	str	r3, [sp, #4]
 80a1632:	bd08      	pop	{r3, pc}
 80a1634:	080601b0 	.word	0x080601b0

080a1638 <HAL_Validate_Pin_Function>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
 80a1638:	b508      	push	{r3, lr}
 80a163a:	4b02      	ldr	r3, [pc, #8]	; (80a1644 <HAL_Validate_Pin_Function+0xc>)
 80a163c:	681b      	ldr	r3, [r3, #0]
 80a163e:	685b      	ldr	r3, [r3, #4]
 80a1640:	9301      	str	r3, [sp, #4]
 80a1642:	bd08      	pop	{r3, pc}
 80a1644:	080601b0 	.word	0x080601b0

080a1648 <HAL_Pin_Mode>:
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a1648:	b508      	push	{r3, lr}
 80a164a:	4b02      	ldr	r3, [pc, #8]	; (80a1654 <HAL_Pin_Mode+0xc>)
 80a164c:	681b      	ldr	r3, [r3, #0]
 80a164e:	689b      	ldr	r3, [r3, #8]
 80a1650:	9301      	str	r3, [sp, #4]
 80a1652:	bd08      	pop	{r3, pc}
 80a1654:	080601b0 	.word	0x080601b0

080a1658 <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a1658:	b508      	push	{r3, lr}
 80a165a:	4b02      	ldr	r3, [pc, #8]	; (80a1664 <HAL_Get_Pin_Mode+0xc>)
 80a165c:	681b      	ldr	r3, [r3, #0]
 80a165e:	68db      	ldr	r3, [r3, #12]
 80a1660:	9301      	str	r3, [sp, #4]
 80a1662:	bd08      	pop	{r3, pc}
 80a1664:	080601b0 	.word	0x080601b0

080a1668 <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
 80a1668:	b508      	push	{r3, lr}
 80a166a:	4b02      	ldr	r3, [pc, #8]	; (80a1674 <HAL_GPIO_Write+0xc>)
 80a166c:	681b      	ldr	r3, [r3, #0]
 80a166e:	691b      	ldr	r3, [r3, #16]
 80a1670:	9301      	str	r3, [sp, #4]
 80a1672:	bd08      	pop	{r3, pc}
 80a1674:	080601b0 	.word	0x080601b0

080a1678 <hal_adc_read>:
DYNALIB_FN(8, hal_gpio, HAL_Interrupts_Enable_All, void(void))
DYNALIB_FN(9, hal_gpio, HAL_Interrupts_Disable_All, void(void))

DYNALIB_FN(10, hal_gpio, HAL_DAC_Write, void(pin_t, uint16_t))
DYNALIB_FN(11, hal_gpio, hal_adc_set_sample_time, void(uint8_t))
DYNALIB_FN(12, hal_gpio, hal_adc_read, int32_t(uint16_t))
 80a1678:	b508      	push	{r3, lr}
 80a167a:	4b02      	ldr	r3, [pc, #8]	; (80a1684 <hal_adc_read+0xc>)
 80a167c:	681b      	ldr	r3, [r3, #0]
 80a167e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a1680:	9301      	str	r3, [sp, #4]
 80a1682:	bd08      	pop	{r3, pc}
 80a1684:	080601b0 	.word	0x080601b0

080a1688 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a1688:	b508      	push	{r3, lr}
 80a168a:	4b02      	ldr	r3, [pc, #8]	; (80a1694 <HAL_RNG_GetRandomNumber+0xc>)
 80a168c:	681b      	ldr	r3, [r3, #0]
 80a168e:	685b      	ldr	r3, [r3, #4]
 80a1690:	9301      	str	r3, [sp, #4]
 80a1692:	bd08      	pop	{r3, pc}
 80a1694:	0806019c 	.word	0x0806019c

080a1698 <HAL_Timer_Get_Micro_Seconds>:
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
 80a1698:	b508      	push	{r3, lr}
 80a169a:	4b02      	ldr	r3, [pc, #8]	; (80a16a4 <HAL_Timer_Get_Micro_Seconds+0xc>)
 80a169c:	681b      	ldr	r3, [r3, #0]
 80a169e:	691b      	ldr	r3, [r3, #16]
 80a16a0:	9301      	str	r3, [sp, #4]
 80a16a2:	bd08      	pop	{r3, pc}
 80a16a4:	0806019c 	.word	0x0806019c

080a16a8 <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a16a8:	b508      	push	{r3, lr}
 80a16aa:	4b02      	ldr	r3, [pc, #8]	; (80a16b4 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a16ac:	681b      	ldr	r3, [r3, #0]
 80a16ae:	695b      	ldr	r3, [r3, #20]
 80a16b0:	9301      	str	r3, [sp, #4]
 80a16b2:	bd08      	pop	{r3, pc}
 80a16b4:	0806019c 	.word	0x0806019c

080a16b8 <os_mutex_recursive_create>:
DYNALIB_FN(13, hal_concurrent, os_mutex_destroy, int(os_mutex_t))
DYNALIB_FN(14, hal_concurrent, os_mutex_lock, int(os_mutex_t))
DYNALIB_FN(15, hal_concurrent, os_mutex_trylock, int(os_mutex_t))
DYNALIB_FN(16, hal_concurrent, os_mutex_unlock, int(os_mutex_t))

DYNALIB_FN(17, hal_concurrent, os_mutex_recursive_create, int(os_mutex_recursive_t*))
 80a16b8:	b508      	push	{r3, lr}
 80a16ba:	4b02      	ldr	r3, [pc, #8]	; (80a16c4 <os_mutex_recursive_create+0xc>)
 80a16bc:	681b      	ldr	r3, [r3, #0]
 80a16be:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a16c0:	9301      	str	r3, [sp, #4]
 80a16c2:	bd08      	pop	{r3, pc}
 80a16c4:	080601d0 	.word	0x080601d0

080a16c8 <os_mutex_recursive_destroy>:
DYNALIB_FN(18, hal_concurrent, os_mutex_recursive_destroy, int(os_mutex_recursive_t))
 80a16c8:	b508      	push	{r3, lr}
 80a16ca:	4b02      	ldr	r3, [pc, #8]	; (80a16d4 <os_mutex_recursive_destroy+0xc>)
 80a16cc:	681b      	ldr	r3, [r3, #0]
 80a16ce:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a16d0:	9301      	str	r3, [sp, #4]
 80a16d2:	bd08      	pop	{r3, pc}
 80a16d4:	080601d0 	.word	0x080601d0

080a16d8 <hal_usart_init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, hal_usart_init, void(hal_usart_interface_t, hal_usart_ring_buffer_t*, hal_usart_ring_buffer_t*))
 80a16d8:	b508      	push	{r3, lr}
 80a16da:	4b02      	ldr	r3, [pc, #8]	; (80a16e4 <hal_usart_init+0xc>)
 80a16dc:	681b      	ldr	r3, [r3, #0]
 80a16de:	699b      	ldr	r3, [r3, #24]
 80a16e0:	9301      	str	r3, [sp, #4]
 80a16e2:	bd08      	pop	{r3, pc}
 80a16e4:	080601c4 	.word	0x080601c4

080a16e8 <hal_usart_write>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, hal_usart_begin, void(hal_usart_interface_t, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, hal_usart_end, void(hal_usart_interface_t))
DYNALIB_FN(BASE_IDX + 3, hal_usart, hal_usart_write, uint32_t(hal_usart_interface_t, uint8_t))
 80a16e8:	b508      	push	{r3, lr}
 80a16ea:	4b02      	ldr	r3, [pc, #8]	; (80a16f4 <hal_usart_write+0xc>)
 80a16ec:	681b      	ldr	r3, [r3, #0]
 80a16ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a16f0:	9301      	str	r3, [sp, #4]
 80a16f2:	bd08      	pop	{r3, pc}
 80a16f4:	080601c4 	.word	0x080601c4

080a16f8 <hal_usart_available>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, hal_usart_available, int32_t(hal_usart_interface_t))
 80a16f8:	b508      	push	{r3, lr}
 80a16fa:	4b02      	ldr	r3, [pc, #8]	; (80a1704 <hal_usart_available+0xc>)
 80a16fc:	681b      	ldr	r3, [r3, #0]
 80a16fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a1700:	9301      	str	r3, [sp, #4]
 80a1702:	bd08      	pop	{r3, pc}
 80a1704:	080601c4 	.word	0x080601c4

080a1708 <hal_usart_read>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, hal_usart_read, int32_t(hal_usart_interface_t))
 80a1708:	b508      	push	{r3, lr}
 80a170a:	4b02      	ldr	r3, [pc, #8]	; (80a1714 <hal_usart_read+0xc>)
 80a170c:	681b      	ldr	r3, [r3, #0]
 80a170e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a1710:	9301      	str	r3, [sp, #4]
 80a1712:	bd08      	pop	{r3, pc}
 80a1714:	080601c4 	.word	0x080601c4

080a1718 <hal_usart_peek>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, hal_usart_peek, int32_t(hal_usart_interface_t))
 80a1718:	b508      	push	{r3, lr}
 80a171a:	4b02      	ldr	r3, [pc, #8]	; (80a1724 <hal_usart_peek+0xc>)
 80a171c:	681b      	ldr	r3, [r3, #0]
 80a171e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a1720:	9301      	str	r3, [sp, #4]
 80a1722:	bd08      	pop	{r3, pc}
 80a1724:	080601c4 	.word	0x080601c4

080a1728 <hal_usart_flush>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, hal_usart_flush, void(hal_usart_interface_t))
 80a1728:	b508      	push	{r3, lr}
 80a172a:	4b02      	ldr	r3, [pc, #8]	; (80a1734 <hal_usart_flush+0xc>)
 80a172c:	681b      	ldr	r3, [r3, #0]
 80a172e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a1730:	9301      	str	r3, [sp, #4]
 80a1732:	bd08      	pop	{r3, pc}
 80a1734:	080601c4 	.word	0x080601c4

080a1738 <hal_usart_is_enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, hal_usart_is_enabled, bool(hal_usart_interface_t))
 80a1738:	b508      	push	{r3, lr}
 80a173a:	4b02      	ldr	r3, [pc, #8]	; (80a1744 <hal_usart_is_enabled+0xc>)
 80a173c:	681b      	ldr	r3, [r3, #0]
 80a173e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a1740:	9301      	str	r3, [sp, #4]
 80a1742:	bd08      	pop	{r3, pc}
 80a1744:	080601c4 	.word	0x080601c4

080a1748 <hal_usart_available_data_for_write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, hal_usart_half_duplex, void(hal_usart_interface_t, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, hal_usart_available_data_for_write, int32_t(hal_usart_interface_t))
 80a1748:	b508      	push	{r3, lr}
 80a174a:	4b02      	ldr	r3, [pc, #8]	; (80a1754 <hal_usart_available_data_for_write+0xc>)
 80a174c:	681b      	ldr	r3, [r3, #0]
 80a174e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a1750:	9301      	str	r3, [sp, #4]
 80a1752:	bd08      	pop	{r3, pc}
 80a1754:	080601c4 	.word	0x080601c4

080a1758 <hal_i2c_write>:
DYNALIB_FN(BASE_IDX + 3, hal_i2c, hal_i2c_begin, void(hal_i2c_interface_t, hal_i2c_mode_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 4, hal_i2c, hal_i2c_end, void(hal_i2c_interface_t, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, hal_i2c_request, uint32_t(hal_i2c_interface_t, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, hal_i2c_begin_transmission, void(hal_i2c_interface_t, uint8_t, const hal_i2c_transmission_config_t*))
DYNALIB_FN(BASE_IDX + 7, hal_i2c, hal_i2c_end_transmission, uint8_t(hal_i2c_interface_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 8, hal_i2c, hal_i2c_write, uint32_t(hal_i2c_interface_t, uint8_t, void*))
 80a1758:	b508      	push	{r3, lr}
 80a175a:	4b02      	ldr	r3, [pc, #8]	; (80a1764 <hal_i2c_write+0xc>)
 80a175c:	681b      	ldr	r3, [r3, #0]
 80a175e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a1760:	9301      	str	r3, [sp, #4]
 80a1762:	bd08      	pop	{r3, pc}
 80a1764:	080601ac 	.word	0x080601ac

080a1768 <hal_i2c_available>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, hal_i2c_available, int32_t(hal_i2c_interface_t, void*))
 80a1768:	b508      	push	{r3, lr}
 80a176a:	4b02      	ldr	r3, [pc, #8]	; (80a1774 <hal_i2c_available+0xc>)
 80a176c:	681b      	ldr	r3, [r3, #0]
 80a176e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a1770:	9301      	str	r3, [sp, #4]
 80a1772:	bd08      	pop	{r3, pc}
 80a1774:	080601ac 	.word	0x080601ac

080a1778 <hal_i2c_read>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, hal_i2c_read, int32_t(hal_i2c_interface_t, void*))
 80a1778:	b508      	push	{r3, lr}
 80a177a:	4b02      	ldr	r3, [pc, #8]	; (80a1784 <hal_i2c_read+0xc>)
 80a177c:	681b      	ldr	r3, [r3, #0]
 80a177e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a1780:	9301      	str	r3, [sp, #4]
 80a1782:	bd08      	pop	{r3, pc}
 80a1784:	080601ac 	.word	0x080601ac

080a1788 <hal_i2c_peek>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, hal_i2c_peek, int32_t(hal_i2c_interface_t, void*))
 80a1788:	b508      	push	{r3, lr}
 80a178a:	4b02      	ldr	r3, [pc, #8]	; (80a1794 <hal_i2c_peek+0xc>)
 80a178c:	681b      	ldr	r3, [r3, #0]
 80a178e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a1790:	9301      	str	r3, [sp, #4]
 80a1792:	bd08      	pop	{r3, pc}
 80a1794:	080601ac 	.word	0x080601ac

080a1798 <hal_i2c_flush>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, hal_i2c_flush, void(hal_i2c_interface_t, void*))
 80a1798:	b508      	push	{r3, lr}
 80a179a:	4b02      	ldr	r3, [pc, #8]	; (80a17a4 <hal_i2c_flush+0xc>)
 80a179c:	681b      	ldr	r3, [r3, #0]
 80a179e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a17a0:	9301      	str	r3, [sp, #4]
 80a17a2:	bd08      	pop	{r3, pc}
 80a17a4:	080601ac 	.word	0x080601ac

080a17a8 <hal_i2c_is_enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, hal_i2c_is_enabled, bool(hal_i2c_interface_t, void*))
 80a17a8:	b508      	push	{r3, lr}
 80a17aa:	4b02      	ldr	r3, [pc, #8]	; (80a17b4 <hal_i2c_is_enabled+0xc>)
 80a17ac:	681b      	ldr	r3, [r3, #0]
 80a17ae:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a17b0:	9301      	str	r3, [sp, #4]
 80a17b2:	bd08      	pop	{r3, pc}
 80a17b4:	080601ac 	.word	0x080601ac

080a17b8 <hal_i2c_init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, hal_i2c_set_callback_on_received, void(hal_i2c_interface_t, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, hal_i2c_set_callback_on_requested, void(hal_i2c_interface_t, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, hal_i2c_init, int(hal_i2c_interface_t, const hal_i2c_config_t*))
 80a17b8:	b508      	push	{r3, lr}
 80a17ba:	4b03      	ldr	r3, [pc, #12]	; (80a17c8 <hal_i2c_init+0x10>)
 80a17bc:	681b      	ldr	r3, [r3, #0]
 80a17be:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a17c2:	9301      	str	r3, [sp, #4]
 80a17c4:	bd08      	pop	{r3, pc}
 80a17c6:	0000      	.short	0x0000
 80a17c8:	080601ac 	.word	0x080601ac

080a17cc <hal_spi_init>:
DYNALIB_FN(2, hal_spi, hal_spi_set_bit_order, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(3, hal_spi, hal_spi_set_data_mode, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(4, hal_spi, hal_spi_set_clock_divider, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(5, hal_spi, hal_spi_transfer, uint16_t(hal_spi_interface_t, uint16_t))
DYNALIB_FN(6, hal_spi, hal_spi_is_enabled_deprecated, bool(void))
DYNALIB_FN(7, hal_spi, hal_spi_init, void(hal_spi_interface_t))
 80a17cc:	b508      	push	{r3, lr}
 80a17ce:	4b02      	ldr	r3, [pc, #8]	; (80a17d8 <hal_spi_init+0xc>)
 80a17d0:	681b      	ldr	r3, [r3, #0]
 80a17d2:	69db      	ldr	r3, [r3, #28]
 80a17d4:	9301      	str	r3, [sp, #4]
 80a17d6:	bd08      	pop	{r3, pc}
 80a17d8:	080601b4 	.word	0x080601b4

080a17dc <hal_spi_is_enabled>:
DYNALIB_FN(8, hal_spi, hal_spi_is_enabled, bool(hal_spi_interface_t))
 80a17dc:	b508      	push	{r3, lr}
 80a17de:	4b02      	ldr	r3, [pc, #8]	; (80a17e8 <hal_spi_is_enabled+0xc>)
 80a17e0:	681b      	ldr	r3, [r3, #0]
 80a17e2:	6a1b      	ldr	r3, [r3, #32]
 80a17e4:	9301      	str	r3, [sp, #4]
 80a17e6:	bd08      	pop	{r3, pc}
 80a17e8:	080601b4 	.word	0x080601b4

080a17ec <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a17ec:	b508      	push	{r3, lr}
 80a17ee:	4b02      	ldr	r3, [pc, #8]	; (80a17f8 <HAL_USB_USART_Init+0xc>)
 80a17f0:	681b      	ldr	r3, [r3, #0]
 80a17f2:	681b      	ldr	r3, [r3, #0]
 80a17f4:	9301      	str	r3, [sp, #4]
 80a17f6:	bd08      	pop	{r3, pc}
 80a17f8:	080601d8 	.word	0x080601d8

080a17fc <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
 80a17fc:	b508      	push	{r3, lr}
 80a17fe:	4b02      	ldr	r3, [pc, #8]	; (80a1808 <HAL_USB_USART_Begin+0xc>)
 80a1800:	681b      	ldr	r3, [r3, #0]
 80a1802:	685b      	ldr	r3, [r3, #4]
 80a1804:	9301      	str	r3, [sp, #4]
 80a1806:	bd08      	pop	{r3, pc}
 80a1808:	080601d8 	.word	0x080601d8

080a180c <HAL_USB_USART_Available_Data>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a180c:	b508      	push	{r3, lr}
 80a180e:	4b02      	ldr	r3, [pc, #8]	; (80a1818 <HAL_USB_USART_Available_Data+0xc>)
 80a1810:	681b      	ldr	r3, [r3, #0]
 80a1812:	691b      	ldr	r3, [r3, #16]
 80a1814:	9301      	str	r3, [sp, #4]
 80a1816:	bd08      	pop	{r3, pc}
 80a1818:	080601d8 	.word	0x080601d8

080a181c <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a181c:	b508      	push	{r3, lr}
 80a181e:	4b02      	ldr	r3, [pc, #8]	; (80a1828 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a1820:	681b      	ldr	r3, [r3, #0]
 80a1822:	695b      	ldr	r3, [r3, #20]
 80a1824:	9301      	str	r3, [sp, #4]
 80a1826:	bd08      	pop	{r3, pc}
 80a1828:	080601d8 	.word	0x080601d8

080a182c <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a182c:	b508      	push	{r3, lr}
 80a182e:	4b02      	ldr	r3, [pc, #8]	; (80a1838 <HAL_USB_USART_Receive_Data+0xc>)
 80a1830:	681b      	ldr	r3, [r3, #0]
 80a1832:	699b      	ldr	r3, [r3, #24]
 80a1834:	9301      	str	r3, [sp, #4]
 80a1836:	bd08      	pop	{r3, pc}
 80a1838:	080601d8 	.word	0x080601d8

080a183c <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a183c:	b508      	push	{r3, lr}
 80a183e:	4b02      	ldr	r3, [pc, #8]	; (80a1848 <HAL_USB_USART_Send_Data+0xc>)
 80a1840:	681b      	ldr	r3, [r3, #0]
 80a1842:	69db      	ldr	r3, [r3, #28]
 80a1844:	9301      	str	r3, [sp, #4]
 80a1846:	bd08      	pop	{r3, pc}
 80a1848:	080601d8 	.word	0x080601d8

080a184c <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a184c:	b508      	push	{r3, lr}
 80a184e:	4b02      	ldr	r3, [pc, #8]	; (80a1858 <HAL_USB_USART_Flush_Data+0xc>)
 80a1850:	681b      	ldr	r3, [r3, #0]
 80a1852:	6a1b      	ldr	r3, [r3, #32]
 80a1854:	9301      	str	r3, [sp, #4]
 80a1856:	bd08      	pop	{r3, pc}
 80a1858:	080601d8 	.word	0x080601d8

080a185c <inet_gethostbyname>:
DYNALIB_FN(14, hal_wlan, wlan_set_error_count, void(uint32_t))
DYNALIB_FN(15, hal_wlan, wlan_fetch_ipconfig, int(WLanConfig*))
DYNALIB_FN(16, hal_wlan, wlan_setup, void(void))

DYNALIB_FN(17, hal_wlan, HAL_NET_SetNetWatchDog, uint32_t(uint32_t))
DYNALIB_FN(18, hal_wlan, inet_gethostbyname, int(const char*, uint16_t, HAL_IPAddress*, network_interface_t, void*))
 80a185c:	b508      	push	{r3, lr}
 80a185e:	4b02      	ldr	r3, [pc, #8]	; (80a1868 <inet_gethostbyname+0xc>)
 80a1860:	681b      	ldr	r3, [r3, #0]
 80a1862:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a1864:	9301      	str	r3, [sp, #4]
 80a1866:	bd08      	pop	{r3, pc}
 80a1868:	080601c0 	.word	0x080601c0

080a186c <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a186c:	b508      	push	{r3, lr}
 80a186e:	4b02      	ldr	r3, [pc, #8]	; (80a1878 <set_system_mode+0xc>)
 80a1870:	681b      	ldr	r3, [r3, #0]
 80a1872:	685b      	ldr	r3, [r3, #4]
 80a1874:	9301      	str	r3, [sp, #4]
 80a1876:	bd08      	pop	{r3, pc}
 80a1878:	080601a4 	.word	0x080601a4

080a187c <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a187c:	b508      	push	{r3, lr}
 80a187e:	4b02      	ldr	r3, [pc, #8]	; (80a1888 <system_delay_ms+0xc>)
 80a1880:	681b      	ldr	r3, [r3, #0]
 80a1882:	695b      	ldr	r3, [r3, #20]
 80a1884:	9301      	str	r3, [sp, #4]
 80a1886:	bd08      	pop	{r3, pc}
 80a1888:	080601a4 	.word	0x080601a4

080a188c <application_thread_current>:
DYNALIB_FN(15, system, system_get_flag, int(system_flag_t, uint8_t*, void*))
DYNALIB_FN(16, system, Spark_Prepare_For_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))
DYNALIB_FN(17, system, Spark_Save_Firmware_Chunk, int(FileTransfer::Descriptor&, const uint8_t*, void*))
DYNALIB_FN(18, system, Spark_Finish_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))

DYNALIB_FN(19, system, application_thread_current, uint8_t(void*))
 80a188c:	b508      	push	{r3, lr}
 80a188e:	4b02      	ldr	r3, [pc, #8]	; (80a1898 <application_thread_current+0xc>)
 80a1890:	681b      	ldr	r3, [r3, #0]
 80a1892:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a1894:	9301      	str	r3, [sp, #4]
 80a1896:	bd08      	pop	{r3, pc}
 80a1898:	080601a4 	.word	0x080601a4

080a189c <application_thread_invoke>:
DYNALIB_FN(20, system, system_thread_current, uint8_t(void*))
DYNALIB_FN(21, system, application_thread_invoke, uint8_t(void(*)(void*), void*, void*))
 80a189c:	b508      	push	{r3, lr}
 80a189e:	4b02      	ldr	r3, [pc, #8]	; (80a18a8 <application_thread_invoke+0xc>)
 80a18a0:	681b      	ldr	r3, [r3, #0]
 80a18a2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a18a4:	9301      	str	r3, [sp, #4]
 80a18a6:	bd08      	pop	{r3, pc}
 80a18a8:	080601a4 	.word	0x080601a4

080a18ac <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a18ac:	b508      	push	{r3, lr}
 80a18ae:	4b03      	ldr	r3, [pc, #12]	; (80a18bc <system_ctrl_set_app_request_handler+0x10>)
 80a18b0:	681b      	ldr	r3, [r3, #0]
 80a18b2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a18b6:	9301      	str	r3, [sp, #4]
 80a18b8:	bd08      	pop	{r3, pc}
 80a18ba:	0000      	.short	0x0000
 80a18bc:	080601a4 	.word	0x080601a4

080a18c0 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a18c0:	b508      	push	{r3, lr}
 80a18c2:	4b03      	ldr	r3, [pc, #12]	; (80a18d0 <system_ctrl_set_result+0x10>)
 80a18c4:	681b      	ldr	r3, [r3, #0]
 80a18c6:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a18ca:	9301      	str	r3, [sp, #4]
 80a18cc:	bd08      	pop	{r3, pc}
 80a18ce:	0000      	.short	0x0000
 80a18d0:	080601a4 	.word	0x080601a4

080a18d4 <network_connect>:
#endif

DYNALIB_BEGIN(system_net)

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
 80a18d4:	b508      	push	{r3, lr}
 80a18d6:	4b02      	ldr	r3, [pc, #8]	; (80a18e0 <network_connect+0xc>)
 80a18d8:	681b      	ldr	r3, [r3, #0]
 80a18da:	685b      	ldr	r3, [r3, #4]
 80a18dc:	9301      	str	r3, [sp, #4]
 80a18de:	bd08      	pop	{r3, pc}
 80a18e0:	080601c8 	.word	0x080601c8

080a18e4 <network_connecting>:
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
 80a18e4:	b508      	push	{r3, lr}
 80a18e6:	4b02      	ldr	r3, [pc, #8]	; (80a18f0 <network_connecting+0xc>)
 80a18e8:	681b      	ldr	r3, [r3, #0]
 80a18ea:	689b      	ldr	r3, [r3, #8]
 80a18ec:	9301      	str	r3, [sp, #4]
 80a18ee:	bd08      	pop	{r3, pc}
 80a18f0:	080601c8 	.word	0x080601c8

080a18f4 <network_disconnect>:
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
 80a18f4:	b508      	push	{r3, lr}
 80a18f6:	4b02      	ldr	r3, [pc, #8]	; (80a1900 <network_disconnect+0xc>)
 80a18f8:	681b      	ldr	r3, [r3, #0]
 80a18fa:	68db      	ldr	r3, [r3, #12]
 80a18fc:	9301      	str	r3, [sp, #4]
 80a18fe:	bd08      	pop	{r3, pc}
 80a1900:	080601c8 	.word	0x080601c8

080a1904 <network_ready>:
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a1904:	b508      	push	{r3, lr}
 80a1906:	4b02      	ldr	r3, [pc, #8]	; (80a1910 <network_ready+0xc>)
 80a1908:	681b      	ldr	r3, [r3, #0]
 80a190a:	691b      	ldr	r3, [r3, #16]
 80a190c:	9301      	str	r3, [sp, #4]
 80a190e:	bd08      	pop	{r3, pc}
 80a1910:	080601c8 	.word	0x080601c8

080a1914 <network_on>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
 80a1914:	b508      	push	{r3, lr}
 80a1916:	4b02      	ldr	r3, [pc, #8]	; (80a1920 <network_on+0xc>)
 80a1918:	681b      	ldr	r3, [r3, #0]
 80a191a:	695b      	ldr	r3, [r3, #20]
 80a191c:	9301      	str	r3, [sp, #4]
 80a191e:	bd08      	pop	{r3, pc}
 80a1920:	080601c8 	.word	0x080601c8

080a1924 <network_off>:
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
 80a1924:	b508      	push	{r3, lr}
 80a1926:	4b02      	ldr	r3, [pc, #8]	; (80a1930 <network_off+0xc>)
 80a1928:	681b      	ldr	r3, [r3, #0]
 80a192a:	699b      	ldr	r3, [r3, #24]
 80a192c:	9301      	str	r3, [sp, #4]
 80a192e:	bd08      	pop	{r3, pc}
 80a1930:	080601c8 	.word	0x080601c8

080a1934 <network_listen>:
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
 80a1934:	b508      	push	{r3, lr}
 80a1936:	4b02      	ldr	r3, [pc, #8]	; (80a1940 <network_listen+0xc>)
 80a1938:	681b      	ldr	r3, [r3, #0]
 80a193a:	69db      	ldr	r3, [r3, #28]
 80a193c:	9301      	str	r3, [sp, #4]
 80a193e:	bd08      	pop	{r3, pc}
 80a1940:	080601c8 	.word	0x080601c8

080a1944 <network_listening>:
DYNALIB_FN(8, system_net, network_listening, bool(network_handle_t, uint32_t, void*))
 80a1944:	b508      	push	{r3, lr}
 80a1946:	4b02      	ldr	r3, [pc, #8]	; (80a1950 <network_listening+0xc>)
 80a1948:	681b      	ldr	r3, [r3, #0]
 80a194a:	6a1b      	ldr	r3, [r3, #32]
 80a194c:	9301      	str	r3, [sp, #4]
 80a194e:	bd08      	pop	{r3, pc}
 80a1950:	080601c8 	.word	0x080601c8

080a1954 <network_set_listen_timeout>:
DYNALIB_FN(9, system_net, network_has_credentials, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(10, system_net, network_set_credentials, int(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(11, system_net, network_clear_credentials, bool(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(12, system_net, network_set_listen_timeout, void(network_handle_t, uint16_t, void*))
 80a1954:	b508      	push	{r3, lr}
 80a1956:	4b02      	ldr	r3, [pc, #8]	; (80a1960 <network_set_listen_timeout+0xc>)
 80a1958:	681b      	ldr	r3, [r3, #0]
 80a195a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a195c:	9301      	str	r3, [sp, #4]
 80a195e:	bd08      	pop	{r3, pc}
 80a1960:	080601c8 	.word	0x080601c8

080a1964 <network_get_listen_timeout>:
DYNALIB_FN(13, system_net, network_get_listen_timeout, uint16_t(network_handle_t, uint32_t, void*))
 80a1964:	b508      	push	{r3, lr}
 80a1966:	4b02      	ldr	r3, [pc, #8]	; (80a1970 <network_get_listen_timeout+0xc>)
 80a1968:	681b      	ldr	r3, [r3, #0]
 80a196a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a196c:	9301      	str	r3, [sp, #4]
 80a196e:	bd08      	pop	{r3, pc}
 80a1970:	080601c8 	.word	0x080601c8

080a1974 <network_is_on>:
DYNALIB_FN(14, system_net, network_set_hostname, int(network_handle_t, uint32_t, const char*, void*))
DYNALIB_FN(15, system_net, network_get_hostname, int(network_handle_t, uint32_t, char*, size_t, void*))
DYNALIB_FN(16, system_net, network_is_on, bool(network_handle_t, void*))
 80a1974:	b508      	push	{r3, lr}
 80a1976:	4b02      	ldr	r3, [pc, #8]	; (80a1980 <network_is_on+0xc>)
 80a1978:	681b      	ldr	r3, [r3, #0]
 80a197a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a197c:	9301      	str	r3, [sp, #4]
 80a197e:	bd08      	pop	{r3, pc}
 80a1980:	080601c8 	.word	0x080601c8

080a1984 <network_is_off>:
DYNALIB_FN(17, system_net, network_is_off, bool(network_handle_t, void*))
 80a1984:	b508      	push	{r3, lr}
 80a1986:	4b02      	ldr	r3, [pc, #8]	; (80a1990 <network_is_off+0xc>)
 80a1988:	681b      	ldr	r3, [r3, #0]
 80a198a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a198c:	9301      	str	r3, [sp, #4]
 80a198e:	bd08      	pop	{r3, pc}
 80a1990:	080601c8 	.word	0x080601c8

080a1994 <spark_variable>:
#endif


DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
 80a1994:	b508      	push	{r3, lr}
 80a1996:	4b02      	ldr	r3, [pc, #8]	; (80a19a0 <spark_variable+0xc>)
 80a1998:	681b      	ldr	r3, [r3, #0]
 80a199a:	681b      	ldr	r3, [r3, #0]
 80a199c:	9301      	str	r3, [sp, #4]
 80a199e:	bd08      	pop	{r3, pc}
 80a19a0:	080601cc 	.word	0x080601cc

080a19a4 <spark_function>:
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
 80a19a4:	b508      	push	{r3, lr}
 80a19a6:	4b02      	ldr	r3, [pc, #8]	; (80a19b0 <spark_function+0xc>)
 80a19a8:	681b      	ldr	r3, [r3, #0]
 80a19aa:	685b      	ldr	r3, [r3, #4]
 80a19ac:	9301      	str	r3, [sp, #4]
 80a19ae:	bd08      	pop	{r3, pc}
 80a19b0:	080601cc 	.word	0x080601cc

080a19b4 <spark_cloud_flag_connected>:
DYNALIB_FN(2, system_cloud, spark_process, void(void))
DYNALIB_FN(3, system_cloud, spark_cloud_flag_connect, void(void))
DYNALIB_FN(4, system_cloud, spark_cloud_flag_disconnect, void(void))
DYNALIB_FN(5, system_cloud, spark_cloud_flag_connected, bool(void))
 80a19b4:	b508      	push	{r3, lr}
 80a19b6:	4b02      	ldr	r3, [pc, #8]	; (80a19c0 <spark_cloud_flag_connected+0xc>)
 80a19b8:	681b      	ldr	r3, [r3, #0]
 80a19ba:	695b      	ldr	r3, [r3, #20]
 80a19bc:	9301      	str	r3, [sp, #4]
 80a19be:	bd08      	pop	{r3, pc}
 80a19c0:	080601cc 	.word	0x080601cc

080a19c4 <spark_send_event>:
DYNALIB_FN(6, system_cloud, system_cloud_protocol_instance, ProtocolFacade*(void))
DYNALIB_FN(7, system_cloud, spark_deviceID, String(void))
DYNALIB_FN(8, system_cloud, spark_send_event, bool(const char*, const char*, int, uint32_t, void*))
 80a19c4:	b508      	push	{r3, lr}
 80a19c6:	4b02      	ldr	r3, [pc, #8]	; (80a19d0 <spark_send_event+0xc>)
 80a19c8:	681b      	ldr	r3, [r3, #0]
 80a19ca:	6a1b      	ldr	r3, [r3, #32]
 80a19cc:	9301      	str	r3, [sp, #4]
 80a19ce:	bd08      	pop	{r3, pc}
 80a19d0:	080601cc 	.word	0x080601cc

080a19d4 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time32_t*, time_t*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, const void*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a19d4:	b508      	push	{r3, lr}
 80a19d6:	4b02      	ldr	r3, [pc, #8]	; (80a19e0 <spark_set_random_seed_from_cloud_handler+0xc>)
 80a19d8:	681b      	ldr	r3, [r3, #0]
 80a19da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a19dc:	9301      	str	r3, [sp, #4]
 80a19de:	bd08      	pop	{r3, pc}
 80a19e0:	080601cc 	.word	0x080601cc

080a19e4 <malloc>:
#include "hal_platform.h"
#endif // defined(DYNALIB_EXPORT) || (defined(DYNALIB_IMPORT) && !defined(RT_DYNALIB_NO_DEPENDENCY_BREAKING_IMPORTS))

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a19e4:	b508      	push	{r3, lr}
 80a19e6:	4b02      	ldr	r3, [pc, #8]	; (80a19f0 <malloc+0xc>)
 80a19e8:	681b      	ldr	r3, [r3, #0]
 80a19ea:	681b      	ldr	r3, [r3, #0]
 80a19ec:	9301      	str	r3, [sp, #4]
 80a19ee:	bd08      	pop	{r3, pc}
 80a19f0:	080601a0 	.word	0x080601a0

080a19f4 <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a19f4:	b508      	push	{r3, lr}
 80a19f6:	4b02      	ldr	r3, [pc, #8]	; (80a1a00 <free+0xc>)
 80a19f8:	681b      	ldr	r3, [r3, #0]
 80a19fa:	685b      	ldr	r3, [r3, #4]
 80a19fc:	9301      	str	r3, [sp, #4]
 80a19fe:	bd08      	pop	{r3, pc}
 80a1a00:	080601a0 	.word	0x080601a0

080a1a04 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a1a04:	b508      	push	{r3, lr}
 80a1a06:	4b02      	ldr	r3, [pc, #8]	; (80a1a10 <realloc+0xc>)
 80a1a08:	681b      	ldr	r3, [r3, #0]
 80a1a0a:	689b      	ldr	r3, [r3, #8]
 80a1a0c:	9301      	str	r3, [sp, #4]
 80a1a0e:	bd08      	pop	{r3, pc}
 80a1a10:	080601a0 	.word	0x080601a0

080a1a14 <abort>:
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(10, rt, vsniprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(11, rt, abort, void(void))
 80a1a14:	b508      	push	{r3, lr}
 80a1a16:	4b02      	ldr	r3, [pc, #8]	; (80a1a20 <abort+0xc>)
 80a1a18:	681b      	ldr	r3, [r3, #0]
 80a1a1a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a1a1c:	9301      	str	r3, [sp, #4]
 80a1a1e:	bd08      	pop	{r3, pc}
 80a1a20:	080601a0 	.word	0x080601a0

080a1a24 <_malloc_r>:
DYNALIB_FN(12, rt, _malloc_r, void*(struct _reent*, size_t))
 80a1a24:	b508      	push	{r3, lr}
 80a1a26:	4b02      	ldr	r3, [pc, #8]	; (80a1a30 <_malloc_r+0xc>)
 80a1a28:	681b      	ldr	r3, [r3, #0]
 80a1a2a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a1a2c:	9301      	str	r3, [sp, #4]
 80a1a2e:	bd08      	pop	{r3, pc}
 80a1a30:	080601a0 	.word	0x080601a0

080a1a34 <newlib_impure_ptr_callback>:
// RT is currently being imported into system-part1 from system-part2,
// which is the reverse direction.

#if defined(DYNALIB_EXPORT) || (defined(DYNALIB_IMPORT) && !defined(RT_DYNALIB_NO_DEPENDENCY_BREAKING_IMPORTS))
DYNALIB_FN(16, rt, __assert_func, void(const char*, int, const char*, const char*))
DYNALIB_FN(17, rt, newlib_impure_ptr_callback, void(void (*)(struct _reent*, size_t, uint32_t, void*), void*))
 80a1a34:	b508      	push	{r3, lr}
 80a1a36:	4b02      	ldr	r3, [pc, #8]	; (80a1a40 <newlib_impure_ptr_callback+0xc>)
 80a1a38:	681b      	ldr	r3, [r3, #0]
 80a1a3a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a1a3c:	9301      	str	r3, [sp, #4]
 80a1a3e:	bd08      	pop	{r3, pc}
 80a1a40:	080601a0 	.word	0x080601a0

080a1a44 <_ZN8SPIClassC1E19hal_spi_interface_t>:
    }
    return particle::SPISettings(info->clock, info->bit_order, info->data_mode);
}
} // namespace

SPIClass::SPIClass(hal_spi_interface_t spi)
 80a1a44:	b570      	push	{r4, r5, r6, lr}
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
 80a1a46:	2600      	movs	r6, #0
 80a1a48:	4604      	mov	r4, r0
 80a1a4a:	460d      	mov	r5, r1
 80a1a4c:	f840 6f08 	str.w	r6, [r0, #8]!
    {
        os_mutex_recursive_create(&handle_);
 80a1a50:	f7ff fe32 	bl	80a16b8 <os_mutex_recursive_create>
{
    _spi = spi;
    hal_spi_init(_spi);
 80a1a54:	4628      	mov	r0, r5
    _spi = spi;
 80a1a56:	7025      	strb	r5, [r4, #0]
    hal_spi_init(_spi);
 80a1a58:	f7ff feb8 	bl	80a17cc <hal_spi_init>
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
}
 80a1a5c:	4620      	mov	r0, r4
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
 80a1a5e:	6066      	str	r6, [r4, #4]
}
 80a1a60:	bd70      	pop	{r4, r5, r6, pc}
	...

080a1a64 <_GLOBAL__sub_I_System>:
} // namespace particle

// particle::Flag<TagT, ValueT>
template<typename TagT, typename ValueT>
inline particle::Flag<TagT, ValueT>::Flag(ValueT val) :
        val_(val) {
 80a1a64:	2202      	movs	r2, #2

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
 80a1a66:	2000      	movs	r0, #0
 80a1a68:	4b04      	ldr	r3, [pc, #16]	; (80a1a7c <_GLOBAL__sub_I_System+0x18>)
 80a1a6a:	601a      	str	r2, [r3, #0]
 80a1a6c:	4b04      	ldr	r3, [pc, #16]	; (80a1a80 <_GLOBAL__sub_I_System+0x1c>)
    SleepResult() {}
 80a1a6e:	4a05      	ldr	r2, [pc, #20]	; (80a1a84 <_GLOBAL__sub_I_System+0x20>)
              error_(SYSTEM_ERROR_NONE) {
 80a1a70:	6018      	str	r0, [r3, #0]
 80a1a72:	8098      	strh	r0, [r3, #4]
    SleepResult() {}
 80a1a74:	7198      	strb	r0, [r3, #6]
 80a1a76:	609a      	str	r2, [r3, #8]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a1a78:	f7ff bef8 	b.w	80a186c <set_system_mode>
 80a1a7c:	200000e0 	.word	0x200000e0
 80a1a80:	200000d4 	.word	0x200000d4
 80a1a84:	ffff0000 	.word	0xffff0000

080a1a88 <_Z11str_reversePc>:

//------------------------------------------------------------------------------------------
#define BUFSIZE (sizeof(long) * 8 + 1)

//utility function used by ultoa()
__attribute__((weak)) void str_reverse(char* buffer){
 80a1a88:	b510      	push	{r4, lr}
 80a1a8a:	4604      	mov	r4, r0
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
 80a1a8c:	f001 f949 	bl	80a2d22 <strlen>
 80a1a90:	1e43      	subs	r3, r0, #1
 80a1a92:	4620      	mov	r0, r4
 80a1a94:	4423      	add	r3, r4
	while(i<j){
 80a1a96:	4283      	cmp	r3, r0
 80a1a98:	d906      	bls.n	80a1aa8 <_Z11str_reversePc+0x20>
		c = *i;
 80a1a9a:	7802      	ldrb	r2, [r0, #0]
		*i = *j;
 80a1a9c:	7819      	ldrb	r1, [r3, #0]
 80a1a9e:	f800 1b01 	strb.w	r1, [r0], #1
		*j = c;
 80a1aa2:	f803 2901 	strb.w	r2, [r3], #-1
	while(i<j){
 80a1aa6:	e7f6      	b.n	80a1a96 <_Z11str_reversePc+0xe>
		++i;
		--j;
	}
}
 80a1aa8:	bd10      	pop	{r4, pc}

080a1aaa <ultoa>:
      memcpy(head, ++tail, i);
      return str;
}

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
 80a1aaa:	b570      	push	{r4, r5, r6, lr}
 80a1aac:	460c      	mov	r4, r1
	if(radix<2 || radix>36){
 80a1aae:	1e91      	subs	r1, r2, #2
 80a1ab0:	2922      	cmp	r1, #34	; 0x22
 80a1ab2:	d822      	bhi.n	80a1afa <ultoa+0x50>
		return NULL;
	}
	char* ptr=buffer;
 80a1ab4:	4625      	mov	r5, r4

	div_t result;
	while(a){
 80a1ab6:	b168      	cbz	r0, 80a1ad4 <ultoa+0x2a>
            /* toolchain bug??
            result = div(a, radix);
            */
            result.quot = a/radix;
 80a1ab8:	fbb0 f6f2 	udiv	r6, r0, r2
            result.rem = a%radix;
 80a1abc:	fb02 0016 	mls	r0, r2, r6, r0
            *ptr = result.rem;
 80a1ac0:	b2c1      	uxtb	r1, r0
            if(result.rem<10){
 80a1ac2:	2809      	cmp	r0, #9
                *ptr += '0';
 80a1ac4:	bf94      	ite	ls
 80a1ac6:	3130      	addls	r1, #48	; 0x30
            }else{
                *ptr += 'a'-10;
 80a1ac8:	3157      	addhi	r1, #87	; 0x57
 80a1aca:	b2c9      	uxtb	r1, r1
            }
            ++ptr;
            a = result.quot;
 80a1acc:	4630      	mov	r0, r6
 80a1ace:	f805 1b01 	strb.w	r1, [r5], #1
	while(a){
 80a1ad2:	e7f0      	b.n	80a1ab6 <ultoa+0xc>
 80a1ad4:	462a      	mov	r2, r5
	}
        while (ptr < buffer+pad)
            *ptr++ = '0';
 80a1ad6:	2130      	movs	r1, #48	; 0x30
        while (ptr < buffer+pad)
 80a1ad8:	4423      	add	r3, r4
 80a1ada:	4293      	cmp	r3, r2
 80a1adc:	d902      	bls.n	80a1ae4 <ultoa+0x3a>
            *ptr++ = '0';
 80a1ade:	f802 1b01 	strb.w	r1, [r2], #1
        while (ptr < buffer+pad)
 80a1ae2:	e7fa      	b.n	80a1ada <ultoa+0x30>
 80a1ae4:	1b5a      	subs	r2, r3, r5
 80a1ae6:	42ab      	cmp	r3, r5
 80a1ae8:	bf38      	it	cc
 80a1aea:	2200      	movcc	r2, #0

	*ptr = '\0';
 80a1aec:	2300      	movs	r3, #0
	str_reverse(buffer);
 80a1aee:	4620      	mov	r0, r4
	*ptr = '\0';
 80a1af0:	54ab      	strb	r3, [r5, r2]
	str_reverse(buffer);
 80a1af2:	f7ff ffc9 	bl	80a1a88 <_Z11str_reversePc>
	return buffer;
 80a1af6:	4620      	mov	r0, r4
}
 80a1af8:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
 80a1afa:	2000      	movs	r0, #0
 80a1afc:	e7fc      	b.n	80a1af8 <ultoa+0x4e>

080a1afe <itoa>:

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
 80a1afe:	b538      	push	{r3, r4, r5, lr}
	if(a<0){
 80a1b00:	1e03      	subs	r3, r0, #0
__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
 80a1b02:	460c      	mov	r4, r1
 80a1b04:	4615      	mov	r5, r2
	if(a<0){
 80a1b06:	da0d      	bge.n	80a1b24 <itoa+0x26>
		*buffer = '-';
 80a1b08:	222d      	movs	r2, #45	; 0x2d
		unsigned v = a==INT_MIN ? ((unsigned)INT_MAX+1) : -a;
 80a1b0a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80a1b0e:	bf0c      	ite	eq
 80a1b10:	4618      	moveq	r0, r3
 80a1b12:	4258      	negne	r0, r3
		ultoa((unsigned)v, buffer + 1, radix);
 80a1b14:	2301      	movs	r3, #1
		*buffer = '-';
 80a1b16:	700a      	strb	r2, [r1, #0]
		ultoa((unsigned)v, buffer + 1, radix);
 80a1b18:	462a      	mov	r2, r5
 80a1b1a:	4419      	add	r1, r3
	}else{
		ultoa(a, buffer, radix);
 80a1b1c:	f7ff ffc5 	bl	80a1aaa <ultoa>
	}
	return buffer;
}
 80a1b20:	4620      	mov	r0, r4
 80a1b22:	bd38      	pop	{r3, r4, r5, pc}
		ultoa(a, buffer, radix);
 80a1b24:	2301      	movs	r3, #1
 80a1b26:	e7f9      	b.n	80a1b1c <itoa+0x1e>

080a1b28 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a1b28:	b510      	push	{r4, lr}
 80a1b2a:	4604      	mov	r4, r0
{
	free(buffer);
 80a1b2c:	6800      	ldr	r0, [r0, #0]
 80a1b2e:	f7ff ff61 	bl	80a19f4 <free>
}
 80a1b32:	4620      	mov	r0, r4
 80a1b34:	bd10      	pop	{r4, pc}

080a1b36 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a1b36:	b510      	push	{r4, lr}
 80a1b38:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a1b3a:	6800      	ldr	r0, [r0, #0]
 80a1b3c:	b108      	cbz	r0, 80a1b42 <_ZN6String10invalidateEv+0xc>
 80a1b3e:	f7ff ff59 	bl	80a19f4 <free>
	buffer = NULL;
 80a1b42:	2300      	movs	r3, #0
	capacity = len = 0;
 80a1b44:	e9c4 3301 	strd	r3, r3, [r4, #4]
	buffer = NULL;
 80a1b48:	6023      	str	r3, [r4, #0]
}
 80a1b4a:	bd10      	pop	{r4, pc}

080a1b4c <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a1b4c:	b538      	push	{r3, r4, r5, lr}
 80a1b4e:	4604      	mov	r4, r0
 80a1b50:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a1b52:	6800      	ldr	r0, [r0, #0]
 80a1b54:	3101      	adds	r1, #1
 80a1b56:	f7ff ff55 	bl	80a1a04 <realloc>
	if (newbuffer) {
 80a1b5a:	b110      	cbz	r0, 80a1b62 <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a1b5c:	e9c4 0500 	strd	r0, r5, [r4]
		return 1;
 80a1b60:	2001      	movs	r0, #1
	}
	return 0;
}
 80a1b62:	bd38      	pop	{r3, r4, r5, pc}

080a1b64 <_ZN6String7reserveEj>:
{
 80a1b64:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a1b66:	6803      	ldr	r3, [r0, #0]
{
 80a1b68:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a1b6a:	b123      	cbz	r3, 80a1b76 <_ZN6String7reserveEj+0x12>
 80a1b6c:	6843      	ldr	r3, [r0, #4]
 80a1b6e:	428b      	cmp	r3, r1
 80a1b70:	d301      	bcc.n	80a1b76 <_ZN6String7reserveEj+0x12>
 80a1b72:	2001      	movs	r0, #1
}
 80a1b74:	bd10      	pop	{r4, pc}
	if (changeBuffer(size)) {
 80a1b76:	4620      	mov	r0, r4
 80a1b78:	f7ff ffe8 	bl	80a1b4c <_ZN6String12changeBufferEj>
 80a1b7c:	2800      	cmp	r0, #0
 80a1b7e:	d0f9      	beq.n	80a1b74 <_ZN6String7reserveEj+0x10>
		if (len == 0) buffer[0] = 0;
 80a1b80:	68a3      	ldr	r3, [r4, #8]
 80a1b82:	2b00      	cmp	r3, #0
 80a1b84:	d1f5      	bne.n	80a1b72 <_ZN6String7reserveEj+0xe>
 80a1b86:	6822      	ldr	r2, [r4, #0]
 80a1b88:	7013      	strb	r3, [r2, #0]
 80a1b8a:	e7f2      	b.n	80a1b72 <_ZN6String7reserveEj+0xe>

080a1b8c <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a1b8c:	b570      	push	{r4, r5, r6, lr}
 80a1b8e:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a1b90:	4611      	mov	r1, r2
{
 80a1b92:	4604      	mov	r4, r0
 80a1b94:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a1b96:	f7ff ffe5 	bl	80a1b64 <_ZN6String7reserveEj>
 80a1b9a:	b920      	cbnz	r0, 80a1ba6 <_ZN6String4copyEPKcj+0x1a>
		invalidate();
 80a1b9c:	4620      	mov	r0, r4
 80a1b9e:	f7ff ffca 	bl	80a1b36 <_ZN6String10invalidateEv>
	}
	len = length;
	memcpy(buffer, cstr, length);
	buffer[len] = 0;
	return *this;
}
 80a1ba2:	4620      	mov	r0, r4
 80a1ba4:	bd70      	pop	{r4, r5, r6, pc}
	memcpy(buffer, cstr, length);
 80a1ba6:	462a      	mov	r2, r5
 80a1ba8:	4631      	mov	r1, r6
 80a1baa:	6820      	ldr	r0, [r4, #0]
	len = length;
 80a1bac:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a1bae:	f001 f850 	bl	80a2c52 <memcpy>
	buffer[len] = 0;
 80a1bb2:	2100      	movs	r1, #0
 80a1bb4:	6822      	ldr	r2, [r4, #0]
 80a1bb6:	68a3      	ldr	r3, [r4, #8]
 80a1bb8:	54d1      	strb	r1, [r2, r3]
	return *this;
 80a1bba:	e7f2      	b.n	80a1ba2 <_ZN6String4copyEPKcj+0x16>

080a1bbc <_ZN6StringC1EPKc>:
String::String(const char *cstr)
 80a1bbc:	b538      	push	{r3, r4, r5, lr}
	buffer = NULL;
 80a1bbe:	2300      	movs	r3, #0
String::String(const char *cstr)
 80a1bc0:	4604      	mov	r4, r0
	if (cstr) copy(cstr, strlen(cstr));
 80a1bc2:	460d      	mov	r5, r1
	capacity = 0;
 80a1bc4:	e9c0 3300 	strd	r3, r3, [r0]
	len = 0;
 80a1bc8:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a1bca:	7303      	strb	r3, [r0, #12]
	if (cstr) copy(cstr, strlen(cstr));
 80a1bcc:	b139      	cbz	r1, 80a1bde <_ZN6StringC1EPKc+0x22>
 80a1bce:	4608      	mov	r0, r1
 80a1bd0:	f001 f8a7 	bl	80a2d22 <strlen>
 80a1bd4:	4629      	mov	r1, r5
 80a1bd6:	4602      	mov	r2, r0
 80a1bd8:	4620      	mov	r0, r4
 80a1bda:	f7ff ffd7 	bl	80a1b8c <_ZN6String4copyEPKcj>
}
 80a1bde:	4620      	mov	r0, r4
 80a1be0:	bd38      	pop	{r3, r4, r5, pc}

080a1be2 <_ZN6String4moveERS_>:
    return copy(reinterpret_cast<const char*>(pstr), length);
}

#ifdef __GXX_EXPERIMENTAL_CXX0X__
void String::move(String &rhs)
{
 80a1be2:	b538      	push	{r3, r4, r5, lr}
 80a1be4:	4605      	mov	r5, r0
	if (buffer) {
 80a1be6:	6800      	ldr	r0, [r0, #0]
{
 80a1be8:	460c      	mov	r4, r1
	if (buffer) {
 80a1bea:	b168      	cbz	r0, 80a1c08 <_ZN6String4moveERS_+0x26>
		if (capacity >= rhs.len) {
 80a1bec:	686a      	ldr	r2, [r5, #4]
 80a1bee:	688b      	ldr	r3, [r1, #8]
 80a1bf0:	429a      	cmp	r2, r3
 80a1bf2:	d307      	bcc.n	80a1c04 <_ZN6String4moveERS_+0x22>
			strcpy(buffer, rhs.buffer);
 80a1bf4:	6809      	ldr	r1, [r1, #0]
 80a1bf6:	f001 f871 	bl	80a2cdc <strcpy>
			len = rhs.len;
 80a1bfa:	68a3      	ldr	r3, [r4, #8]
 80a1bfc:	60ab      	str	r3, [r5, #8]
			rhs.len = 0;
 80a1bfe:	2300      	movs	r3, #0
	buffer = rhs.buffer;
	capacity = rhs.capacity;
	len = rhs.len;
	rhs.buffer = NULL;
	rhs.capacity = 0;
	rhs.len = 0;
 80a1c00:	60a3      	str	r3, [r4, #8]
}
 80a1c02:	bd38      	pop	{r3, r4, r5, pc}
			free(buffer);
 80a1c04:	f7ff fef6 	bl	80a19f4 <free>
	buffer = rhs.buffer;
 80a1c08:	6823      	ldr	r3, [r4, #0]
 80a1c0a:	602b      	str	r3, [r5, #0]
	capacity = rhs.capacity;
 80a1c0c:	6863      	ldr	r3, [r4, #4]
 80a1c0e:	606b      	str	r3, [r5, #4]
	len = rhs.len;
 80a1c10:	68a3      	ldr	r3, [r4, #8]
 80a1c12:	60ab      	str	r3, [r5, #8]
	rhs.buffer = NULL;
 80a1c14:	2300      	movs	r3, #0
	rhs.capacity = 0;
 80a1c16:	e9c4 3300 	strd	r3, r3, [r4]
 80a1c1a:	e7f1      	b.n	80a1c00 <_ZN6String4moveERS_+0x1e>

080a1c1c <_ZN6StringaSERKS_>:
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
 80a1c1c:	4288      	cmp	r0, r1
{
 80a1c1e:	b510      	push	{r4, lr}
 80a1c20:	460b      	mov	r3, r1
 80a1c22:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
 80a1c24:	d004      	beq.n	80a1c30 <_ZN6StringaSERKS_+0x14>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
 80a1c26:	6809      	ldr	r1, [r1, #0]
 80a1c28:	b121      	cbz	r1, 80a1c34 <_ZN6StringaSERKS_+0x18>
 80a1c2a:	689a      	ldr	r2, [r3, #8]
 80a1c2c:	f7ff ffae 	bl	80a1b8c <_ZN6String4copyEPKcj>
	else invalidate();

	return *this;
}
 80a1c30:	4620      	mov	r0, r4
 80a1c32:	bd10      	pop	{r4, pc}
	else invalidate();
 80a1c34:	f7ff ff7f 	bl	80a1b36 <_ZN6String10invalidateEv>
 80a1c38:	e7fa      	b.n	80a1c30 <_ZN6StringaSERKS_+0x14>

080a1c3a <_ZN6StringC1ERKS_>:
	buffer = NULL;
 80a1c3a:	2300      	movs	r3, #0
String::String(const String &value)
 80a1c3c:	b510      	push	{r4, lr}
 80a1c3e:	4604      	mov	r4, r0
	capacity = 0;
 80a1c40:	e9c0 3300 	strd	r3, r3, [r0]
	len = 0;
 80a1c44:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a1c46:	7303      	strb	r3, [r0, #12]
	*this = value;
 80a1c48:	f7ff ffe8 	bl	80a1c1c <_ZN6StringaSERKS_>
}
 80a1c4c:	4620      	mov	r0, r4
 80a1c4e:	bd10      	pop	{r4, pc}

080a1c50 <_ZN6StringaSEOS_>:
}

#ifdef __GXX_EXPERIMENTAL_CXX0X__
String & String::operator = (String &&rval)
{
	if (this != &rval) move(rval);
 80a1c50:	4288      	cmp	r0, r1
{
 80a1c52:	b510      	push	{r4, lr}
 80a1c54:	4604      	mov	r4, r0
	if (this != &rval) move(rval);
 80a1c56:	d001      	beq.n	80a1c5c <_ZN6StringaSEOS_+0xc>
 80a1c58:	f7ff ffc3 	bl	80a1be2 <_ZN6String4moveERS_>
	return *this;
}
 80a1c5c:	4620      	mov	r0, r4
 80a1c5e:	bd10      	pop	{r4, pc}

080a1c60 <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
 80a1c60:	b538      	push	{r3, r4, r5, lr}
 80a1c62:	4605      	mov	r5, r0
	if (cstr) copy(cstr, strlen(cstr));
 80a1c64:	460c      	mov	r4, r1
 80a1c66:	b149      	cbz	r1, 80a1c7c <_ZN6StringaSEPKc+0x1c>
 80a1c68:	4608      	mov	r0, r1
 80a1c6a:	f001 f85a 	bl	80a2d22 <strlen>
 80a1c6e:	4621      	mov	r1, r4
 80a1c70:	4602      	mov	r2, r0
 80a1c72:	4628      	mov	r0, r5
 80a1c74:	f7ff ff8a 	bl	80a1b8c <_ZN6String4copyEPKcj>
	else invalidate();

	return *this;
}
 80a1c78:	4628      	mov	r0, r5
 80a1c7a:	bd38      	pop	{r3, r4, r5, pc}
	else invalidate();
 80a1c7c:	f7ff ff5b 	bl	80a1b36 <_ZN6String10invalidateEv>
 80a1c80:	e7fa      	b.n	80a1c78 <_ZN6StringaSEPKc+0x18>

080a1c82 <_ZN6StringC1Eih>:
String::String(int value, unsigned char base)
 80a1c82:	b510      	push	{r4, lr}
	buffer = NULL;
 80a1c84:	2300      	movs	r3, #0
String::String(int value, unsigned char base)
 80a1c86:	4604      	mov	r4, r0
 80a1c88:	b08a      	sub	sp, #40	; 0x28
	capacity = 0;
 80a1c8a:	e9c4 3300 	strd	r3, r3, [r4]
	len = 0;
 80a1c8e:	60a3      	str	r3, [r4, #8]
	flags = 0;
 80a1c90:	7323      	strb	r3, [r4, #12]
String::String(int value, unsigned char base)
 80a1c92:	4608      	mov	r0, r1
	itoa(value, buf, base);
 80a1c94:	a901      	add	r1, sp, #4
 80a1c96:	f7ff ff32 	bl	80a1afe <itoa>
	*this = buf;
 80a1c9a:	4620      	mov	r0, r4
 80a1c9c:	a901      	add	r1, sp, #4
 80a1c9e:	f7ff ffdf 	bl	80a1c60 <_ZN6StringaSEPKc>
}
 80a1ca2:	4620      	mov	r0, r4
 80a1ca4:	b00a      	add	sp, #40	; 0x28
 80a1ca6:	bd10      	pop	{r4, pc}

080a1ca8 <_ZNK6String6equalsEPKc>:
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
 80a1ca8:	b508      	push	{r3, lr}
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a1caa:	6882      	ldr	r2, [r0, #8]
 80a1cac:	b93a      	cbnz	r2, 80a1cbe <_ZNK6String6equalsEPKc+0x16>
 80a1cae:	b121      	cbz	r1, 80a1cba <_ZNK6String6equalsEPKc+0x12>
 80a1cb0:	7808      	ldrb	r0, [r1, #0]
	if (cstr == NULL) return buffer[0] == 0;
	return strcmp(buffer, cstr) == 0;
 80a1cb2:	fab0 f080 	clz	r0, r0
 80a1cb6:	0940      	lsrs	r0, r0, #5
 80a1cb8:	e000      	b.n	80a1cbc <_ZNK6String6equalsEPKc+0x14>
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a1cba:	2001      	movs	r0, #1
}
 80a1cbc:	bd08      	pop	{r3, pc}
	if (cstr == NULL) return buffer[0] == 0;
 80a1cbe:	6800      	ldr	r0, [r0, #0]
 80a1cc0:	b909      	cbnz	r1, 80a1cc6 <_ZNK6String6equalsEPKc+0x1e>
 80a1cc2:	7800      	ldrb	r0, [r0, #0]
 80a1cc4:	e7f5      	b.n	80a1cb2 <_ZNK6String6equalsEPKc+0xa>
	return strcmp(buffer, cstr) == 0;
 80a1cc6:	f000 ffff 	bl	80a2cc8 <strcmp>
 80a1cca:	e7f2      	b.n	80a1cb2 <_ZNK6String6equalsEPKc+0xa>

080a1ccc <_ZNK6String5toIntEv>:
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const
{
	if (buffer) return atol(buffer);
 80a1ccc:	6800      	ldr	r0, [r0, #0]
 80a1cce:	b108      	cbz	r0, 80a1cd4 <_ZNK6String5toIntEv+0x8>
 80a1cd0:	f000 bfbb 	b.w	80a2c4a <atol>
	return 0;
}
 80a1cd4:	4770      	bx	lr

080a1cd6 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a1cd6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1cd8:	4606      	mov	r6, r0
 80a1cda:	460d      	mov	r5, r1
  size_t n = 0;
 80a1cdc:	2400      	movs	r4, #0
 80a1cde:	188f      	adds	r7, r1, r2
  while (size--) {
 80a1ce0:	42bd      	cmp	r5, r7
 80a1ce2:	d00c      	beq.n	80a1cfe <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a1ce4:	6833      	ldr	r3, [r6, #0]
 80a1ce6:	4630      	mov	r0, r6
 80a1ce8:	689b      	ldr	r3, [r3, #8]
 80a1cea:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a1cee:	4798      	blx	r3
     if (chunk>=0)
 80a1cf0:	1e03      	subs	r3, r0, #0
 80a1cf2:	db01      	blt.n	80a1cf8 <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a1cf4:	441c      	add	r4, r3
  while (size--) {
 80a1cf6:	e7f3      	b.n	80a1ce0 <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a1cf8:	2c00      	cmp	r4, #0
 80a1cfa:	bf08      	it	eq
 80a1cfc:	461c      	moveq	r4, r3
             n = chunk;
         break;
     }
  }
  return n;
}
 80a1cfe:	4620      	mov	r0, r4
 80a1d00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a1d02 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a1d02:	b570      	push	{r4, r5, r6, lr}
 80a1d04:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a1d06:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a1d08:	4608      	mov	r0, r1
      if (str == NULL) return 0;
 80a1d0a:	b149      	cbz	r1, 80a1d20 <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a1d0c:	f001 f809 	bl	80a2d22 <strlen>
 80a1d10:	682b      	ldr	r3, [r5, #0]
 80a1d12:	4602      	mov	r2, r0
 80a1d14:	4621      	mov	r1, r4
 80a1d16:	4628      	mov	r0, r5
    }
 80a1d18:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      return write((const uint8_t *)str, strlen(str));
 80a1d1c:	68db      	ldr	r3, [r3, #12]
 80a1d1e:	4718      	bx	r3
    }
 80a1d20:	bd70      	pop	{r4, r5, r6, pc}

080a1d22 <_ZN5Print5printEPKc>:

size_t Print::print(const char str[])
{
 80a1d22:	b508      	push	{r3, lr}
  return write(str);
 80a1d24:	f7ff ffed 	bl	80a1d02 <_ZN5Print5writeEPKc>
}
 80a1d28:	bd08      	pop	{r3, pc}

080a1d2a <_ZN5Print5printEc>:

size_t Print::print(char c)
{
  return write(c);
 80a1d2a:	6803      	ldr	r3, [r0, #0]
 80a1d2c:	689b      	ldr	r3, [r3, #8]
 80a1d2e:	4718      	bx	r3

080a1d30 <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a1d30:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a1d32:	210d      	movs	r1, #13
{
 80a1d34:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a1d36:	f7ff fff8 	bl	80a1d2a <_ZN5Print5printEc>
  n += print('\n');
 80a1d3a:	210a      	movs	r1, #10
  size_t n = print('\r');
 80a1d3c:	4604      	mov	r4, r0
  n += print('\n');
 80a1d3e:	4628      	mov	r0, r5
 80a1d40:	f7ff fff3 	bl	80a1d2a <_ZN5Print5printEc>
  return n;
}
 80a1d44:	4420      	add	r0, r4
 80a1d46:	bd38      	pop	{r3, r4, r5, pc}

080a1d48 <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a1d48:	b538      	push	{r3, r4, r5, lr}
 80a1d4a:	4605      	mov	r5, r0
  return write(str);
 80a1d4c:	f7ff ffd9 	bl	80a1d02 <_ZN5Print5writeEPKc>
 80a1d50:	4604      	mov	r4, r0
  size_t n = print(c);
  n += println();
 80a1d52:	4628      	mov	r0, r5
 80a1d54:	f7ff ffec 	bl	80a1d30 <_ZN5Print7printlnEv>
  return n;
}
 80a1d58:	4420      	add	r0, r4
 80a1d5a:	bd38      	pop	{r3, r4, r5, pc}

080a1d5c <_ZN5Print11printNumberEmh>:

size_t Print::printNumber(unsigned long n, uint8_t base) {
  char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a1d5c:	2300      	movs	r3, #0

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a1d5e:	2a01      	cmp	r2, #1
 80a1d60:	bf98      	it	ls
 80a1d62:	220a      	movls	r2, #10
size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a1d64:	b530      	push	{r4, r5, lr}
 80a1d66:	b08b      	sub	sp, #44	; 0x2c
 80a1d68:	460c      	mov	r4, r1
  *str = '\0';
 80a1d6a:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
  if (base < 2) base = 10;
 80a1d6e:	a909      	add	r1, sp, #36	; 0x24

  do {
   decltype(n) m = n;
   n /= base;
 80a1d70:	4625      	mov	r5, r4
 80a1d72:	fbb4 f4f2 	udiv	r4, r4, r2
   char c = m - base * n;
 80a1d76:	fb04 5312 	mls	r3, r4, r2, r5
 80a1d7a:	b2db      	uxtb	r3, r3
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a1d7c:	2b09      	cmp	r3, #9
 80a1d7e:	bf94      	ite	ls
 80a1d80:	3330      	addls	r3, #48	; 0x30
 80a1d82:	3337      	addhi	r3, #55	; 0x37
 80a1d84:	b2db      	uxtb	r3, r3
  } while(n);
 80a1d86:	42aa      	cmp	r2, r5
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a1d88:	f801 3d01 	strb.w	r3, [r1, #-1]!
  } while(n);
 80a1d8c:	d9f0      	bls.n	80a1d70 <_ZN5Print11printNumberEmh+0x14>

  return write(str);
 80a1d8e:	f7ff ffb8 	bl	80a1d02 <_ZN5Print5writeEPKc>
}
 80a1d92:	b00b      	add	sp, #44	; 0x2c
 80a1d94:	bd30      	pop	{r4, r5, pc}

080a1d96 <_ZN5spark9WiFiClass2onEv>:
    bool ready(void) {
        return network_ready(*this, 0, NULL);
    }

    void on(void) {
        network_on(*this, 0, 0, NULL);
 80a1d96:	2300      	movs	r3, #0
 80a1d98:	6840      	ldr	r0, [r0, #4]
 80a1d9a:	461a      	mov	r2, r3
 80a1d9c:	4619      	mov	r1, r3
 80a1d9e:	f7ff bdb9 	b.w	80a1914 <network_on>

080a1da2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>:
      : _M_pi(__r._M_pi)
 80a1da2:	680b      	ldr	r3, [r1, #0]
 80a1da4:	6003      	str	r3, [r0, #0]
	if (_M_pi != 0)
 80a1da6:	b113      	cbz	r3, 80a1dae <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_+0xc>
    { ++_M_use_count; }
 80a1da8:	685a      	ldr	r2, [r3, #4]
 80a1daa:	3201      	adds	r2, #1
 80a1dac:	605a      	str	r2, [r3, #4]
      }
 80a1dae:	4770      	bx	lr

080a1db0 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a1db0:	4b01      	ldr	r3, [pc, #4]	; (80a1db8 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a1db2:	4a02      	ldr	r2, [pc, #8]	; (80a1dbc <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a1db4:	601a      	str	r2, [r3, #0]
#if Wiring_LogConfig

// spark::
void spark::logProcessControlRequest(ctrl_request* req) {
    JSONRequestHandler::process(req);
}
 80a1db6:	4770      	bx	lr
 80a1db8:	200000e4 	.word	0x200000e4
 80a1dbc:	080a2fcc 	.word	0x080a2fcc

080a1dc0 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a1dc0:	4b02      	ldr	r3, [pc, #8]	; (80a1dcc <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a1dc2:	681a      	ldr	r2, [r3, #0]
 80a1dc4:	4b02      	ldr	r3, [pc, #8]	; (80a1dd0 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a1dc6:	601a      	str	r2, [r3, #0]
{
  return isValid();
}


TimeClass Time;
 80a1dc8:	4770      	bx	lr
 80a1dca:	bf00      	nop
 80a1dcc:	20000010 	.word	0x20000010
 80a1dd0:	200000e8 	.word	0x200000e8

080a1dd4 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a1dd4:	2100      	movs	r1, #0
 80a1dd6:	f7ff bd51 	b.w	80a187c <system_delay_ms>

080a1dda <_ZNSt14_Function_baseD1Ev>:
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a1dda:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a1ddc:	6883      	ldr	r3, [r0, #8]
    ~_Function_base()
 80a1dde:	4604      	mov	r4, r0
      if (_M_manager)
 80a1de0:	b113      	cbz	r3, 80a1de8 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a1de2:	2203      	movs	r2, #3
 80a1de4:	4601      	mov	r1, r0
 80a1de6:	4798      	blx	r3
    }
 80a1de8:	4620      	mov	r0, r4
 80a1dea:	bd10      	pop	{r4, pc}

080a1dec <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>:
    inline
#if __cplusplus >= 201103L
    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
			      is_move_constructible<_Tp>,
			      is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
 80a1dec:	b513      	push	{r0, r1, r4, lr}
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a1dee:	466c      	mov	r4, sp
    swap(_Tp& __a, _Tp& __b)
 80a1df0:	460b      	mov	r3, r1
 80a1df2:	4602      	mov	r2, r0
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a1df4:	c803      	ldmia	r0, {r0, r1}
 80a1df6:	e884 0003 	stmia.w	r4, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
 80a1dfa:	e893 0003 	ldmia.w	r3, {r0, r1}
 80a1dfe:	e882 0003 	stmia.w	r2, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
 80a1e02:	e894 0003 	ldmia.w	r4, {r0, r1}
 80a1e06:	e883 0003 	stmia.w	r3, {r0, r1}
    }
 80a1e0a:	b002      	add	sp, #8
 80a1e0c:	bd10      	pop	{r4, pc}
	...

080a1e10 <_GLOBAL__sub_I_RGB>:
    _Function_base() : _M_manager(nullptr) { }
 80a1e10:	2200      	movs	r2, #0
 80a1e12:	4b01      	ldr	r3, [pc, #4]	; (80a1e18 <_GLOBAL__sub_I_RGB+0x8>)
 80a1e14:	609a      	str	r2, [r3, #8]
{
    RGBClass* const d = static_cast<RGBClass*>(data);
    if (d->changeHandler_) {
        d->changeHandler_(r, g, b);
    }
}
 80a1e16:	4770      	bx	lr
 80a1e18:	200000ec 	.word	0x200000ec

080a1e1c <_ZZ21module_user_init_hookENUlP6_reentjmPvE_4_FUNES0_jmS1_>:

void module_user_init_hook()
{
#if HAL_PLATFORM_NEWLIB
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
        _impure_ptr = r;
 80a1e1c:	4b01      	ldr	r3, [pc, #4]	; (80a1e24 <_ZZ21module_user_init_hookENUlP6_reentjmPvE_4_FUNES0_jmS1_+0x8>)
 80a1e1e:	6018      	str	r0, [r3, #0]
    }, nullptr);
 80a1e20:	4770      	bx	lr
 80a1e22:	bf00      	nop
 80a1e24:	20000014 	.word	0x20000014

080a1e28 <serialEventRun>:
{
 80a1e28:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a1e2a:	4b13      	ldr	r3, [pc, #76]	; (80a1e78 <serialEventRun+0x50>)
 80a1e2c:	b143      	cbz	r3, 80a1e40 <serialEventRun+0x18>
 80a1e2e:	f000 fc39 	bl	80a26a4 <_Z16_fetch_usbserialv>
 80a1e32:	6803      	ldr	r3, [r0, #0]
 80a1e34:	691b      	ldr	r3, [r3, #16]
 80a1e36:	4798      	blx	r3
 80a1e38:	2800      	cmp	r0, #0
 80a1e3a:	dd01      	ble.n	80a1e40 <serialEventRun+0x18>
        serialEvent();
 80a1e3c:	f3af 8000 	nop.w
    if (serialEvent1 && Serial1.available()>0)
 80a1e40:	4b0e      	ldr	r3, [pc, #56]	; (80a1e7c <serialEventRun+0x54>)
 80a1e42:	b143      	cbz	r3, 80a1e56 <serialEventRun+0x2e>
 80a1e44:	f000 fcde 	bl	80a2804 <_Z22__fetch_global_Serial1v>
 80a1e48:	6803      	ldr	r3, [r0, #0]
 80a1e4a:	691b      	ldr	r3, [r3, #16]
 80a1e4c:	4798      	blx	r3
 80a1e4e:	2800      	cmp	r0, #0
 80a1e50:	dd01      	ble.n	80a1e56 <serialEventRun+0x2e>
        serialEvent1();
 80a1e52:	f3af 8000 	nop.w
    if (serialEventRun2) serialEventRun2();
 80a1e56:	4b0a      	ldr	r3, [pc, #40]	; (80a1e80 <serialEventRun+0x58>)
 80a1e58:	b10b      	cbz	r3, 80a1e5e <serialEventRun+0x36>
 80a1e5a:	f3af 8000 	nop.w
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a1e5e:	4b09      	ldr	r3, [pc, #36]	; (80a1e84 <serialEventRun+0x5c>)
 80a1e60:	b143      	cbz	r3, 80a1e74 <serialEventRun+0x4c>
 80a1e62:	f000 fc59 	bl	80a2718 <_Z17_fetch_usbserial1v>
 80a1e66:	6803      	ldr	r3, [r0, #0]
 80a1e68:	691b      	ldr	r3, [r3, #16]
 80a1e6a:	4798      	blx	r3
 80a1e6c:	2800      	cmp	r0, #0
 80a1e6e:	dd01      	ble.n	80a1e74 <serialEventRun+0x4c>
        usbSerialEvent1();
 80a1e70:	f3af 8000 	nop.w
}
 80a1e74:	bd08      	pop	{r3, pc}
 80a1e76:	bf00      	nop
	...

080a1e88 <_post_loop>:
{
 80a1e88:	b508      	push	{r3, lr}
	serialEventRun();
 80a1e8a:	f7ff ffcd 	bl	80a1e28 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a1e8e:	f7ff fc0b 	bl	80a16a8 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a1e92:	4b01      	ldr	r3, [pc, #4]	; (80a1e98 <_post_loop+0x10>)
 80a1e94:	6018      	str	r0, [r3, #0]
}
 80a1e96:	bd08      	pop	{r3, pc}
 80a1e98:	20000578 	.word	0x20000578

080a1e9c <_Z33system_initialize_user_backup_ramv>:
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a1e9c:	4805      	ldr	r0, [pc, #20]	; (80a1eb4 <_Z33system_initialize_user_backup_ramv+0x18>)
 80a1e9e:	4a06      	ldr	r2, [pc, #24]	; (80a1eb8 <_Z33system_initialize_user_backup_ramv+0x1c>)
{
 80a1ea0:	b508      	push	{r3, lr}
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a1ea2:	1a12      	subs	r2, r2, r0
 80a1ea4:	4905      	ldr	r1, [pc, #20]	; (80a1ebc <_Z33system_initialize_user_backup_ramv+0x20>)
 80a1ea6:	f000 fed4 	bl	80a2c52 <memcpy>
    __backup_sram_signature = signature;
 80a1eaa:	4b05      	ldr	r3, [pc, #20]	; (80a1ec0 <_Z33system_initialize_user_backup_ramv+0x24>)
 80a1eac:	4a05      	ldr	r2, [pc, #20]	; (80a1ec4 <_Z33system_initialize_user_backup_ramv+0x28>)
 80a1eae:	601a      	str	r2, [r3, #0]
}
 80a1eb0:	bd08      	pop	{r3, pc}
 80a1eb2:	bf00      	nop
 80a1eb4:	40024000 	.word	0x40024000
 80a1eb8:	40024004 	.word	0x40024004
 80a1ebc:	080a3250 	.word	0x080a3250
 80a1ec0:	40024000 	.word	0x40024000
 80a1ec4:	9a271c1e 	.word	0x9a271c1e

080a1ec8 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a1ec8:	2300      	movs	r3, #0
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a1eca:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a1ecc:	461a      	mov	r2, r3
 80a1ece:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a1ed2:	9300      	str	r3, [sp, #0]
 80a1ed4:	f7ff fcf4 	bl	80a18c0 <system_ctrl_set_result>
}
 80a1ed8:	b003      	add	sp, #12
 80a1eda:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a1ee0 <_ZL20ctrl_request_handlerP12ctrl_request>:
static void ctrl_request_handler(ctrl_request* req) {
 80a1ee0:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a1ee2:	8843      	ldrh	r3, [r0, #2]
 80a1ee4:	2b0a      	cmp	r3, #10
 80a1ee6:	d008      	beq.n	80a1efa <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a1ee8:	2b50      	cmp	r3, #80	; 0x50
 80a1eea:	d10b      	bne.n	80a1f04 <_ZL20ctrl_request_handlerP12ctrl_request+0x24>
        if (log_process_ctrl_request_callback) {
 80a1eec:	4b09      	ldr	r3, [pc, #36]	; (80a1f14 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a1eee:	681b      	ldr	r3, [r3, #0]
 80a1ef0:	b14b      	cbz	r3, 80a1f06 <_ZL20ctrl_request_handlerP12ctrl_request+0x26>
}
 80a1ef2:	b003      	add	sp, #12
 80a1ef4:	f85d eb04 	ldr.w	lr, [sp], #4
            log_process_ctrl_request_callback(req);
 80a1ef8:	4718      	bx	r3
        ctrl_request_custom_handler(req);
 80a1efa:	f7ff ffe5 	bl	80a1ec8 <_Z27ctrl_request_custom_handlerP12ctrl_request>
}
 80a1efe:	b003      	add	sp, #12
 80a1f00:	f85d fb04 	ldr.w	pc, [sp], #4
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a1f04:	2300      	movs	r3, #0
 80a1f06:	461a      	mov	r2, r3
 80a1f08:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a1f0c:	9300      	str	r3, [sp, #0]
 80a1f0e:	f7ff fcd7 	bl	80a18c0 <system_ctrl_set_result>
}
 80a1f12:	e7f4      	b.n	80a1efe <_ZL20ctrl_request_handlerP12ctrl_request+0x1e>
 80a1f14:	20000100 	.word	0x20000100

080a1f18 <module_user_init_hook>:
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
 80a1f18:	2100      	movs	r1, #0
{
 80a1f1a:	b510      	push	{r4, lr}
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
 80a1f1c:	4811      	ldr	r0, [pc, #68]	; (80a1f64 <module_user_init_hook+0x4c>)
 80a1f1e:	f7ff fd89 	bl	80a1a34 <newlib_impure_ptr_callback>
#endif // HAL_PLATFORM_NEWLIB

#if HAL_PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ = __backup_sram_signature == signature;
 80a1f22:	4b11      	ldr	r3, [pc, #68]	; (80a1f68 <module_user_init_hook+0x50>)
 80a1f24:	681a      	ldr	r2, [r3, #0]
 80a1f26:	4b11      	ldr	r3, [pc, #68]	; (80a1f6c <module_user_init_hook+0x54>)
 80a1f28:	429a      	cmp	r2, r3
 80a1f2a:	bf0c      	ite	eq
 80a1f2c:	2201      	moveq	r2, #1
 80a1f2e:	2200      	movne	r2, #0
 80a1f30:	4b0f      	ldr	r3, [pc, #60]	; (80a1f70 <module_user_init_hook+0x58>)
 80a1f32:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a1f34:	d001      	beq.n	80a1f3a <module_user_init_hook+0x22>
        system_initialize_user_backup_ram();
 80a1f36:	f7ff ffb1 	bl	80a1e9c <_Z33system_initialize_user_backup_ramv>
    }
#endif

#if HAL_PLATFORM_RNG
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    const uint32_t seed = HAL_RNG_GetRandomNumber();
 80a1f3a:	f7ff fba5 	bl	80a1688 <HAL_RNG_GetRandomNumber>
 80a1f3e:	4604      	mov	r4, r0
    srand(seed);
 80a1f40:	f000 fe9e 	bl	80a2c80 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a1f44:	4b0b      	ldr	r3, [pc, #44]	; (80a1f74 <module_user_init_hook+0x5c>)
 80a1f46:	b113      	cbz	r3, 80a1f4e <module_user_init_hook+0x36>
        random_seed_from_cloud(seed);
 80a1f48:	4620      	mov	r0, r4
 80a1f4a:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a1f4e:	2100      	movs	r1, #0
 80a1f50:	4808      	ldr	r0, [pc, #32]	; (80a1f74 <module_user_init_hook+0x5c>)
 80a1f52:	f7ff fd3f 	bl	80a19d4 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a1f56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a1f5a:	2100      	movs	r1, #0
 80a1f5c:	4806      	ldr	r0, [pc, #24]	; (80a1f78 <module_user_init_hook+0x60>)
 80a1f5e:	f7ff bca5 	b.w	80a18ac <system_ctrl_set_app_request_handler>
 80a1f62:	bf00      	nop
 80a1f64:	080a1e1d 	.word	0x080a1e1d
 80a1f68:	40024000 	.word	0x40024000
 80a1f6c:	9a271c1e 	.word	0x9a271c1e
 80a1f70:	200000fc 	.word	0x200000fc
 80a1f74:	00000000 	.word	0x00000000
 80a1f78:	080a1ee1 	.word	0x080a1ee1

080a1f7c <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
 80a1f7c:	4770      	bx	lr

080a1f7e <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
      { return nullptr; }
 80a1f7e:	2000      	movs	r0, #0
 80a1f80:	4770      	bx	lr

080a1f82 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
 80a1f82:	b510      	push	{r4, lr}
 80a1f84:	4604      	mov	r4, r0
 80a1f86:	2110      	movs	r1, #16
 80a1f88:	f000 fe52 	bl	80a2c30 <_ZdlPvj>
 80a1f8c:	4620      	mov	r0, r4
 80a1f8e:	bd10      	pop	{r4, pc}

080a1f90 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
      _M_destroy() noexcept
 80a1f90:	b508      	push	{r3, lr}
      { delete this; }
 80a1f92:	f7ff fff6 	bl	80a1f82 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>
 80a1f96:	bd08      	pop	{r3, pc}

080a1f98 <_ZN8particle5ErrorC1EOS0_>:

} // namespace particle

inline particle::Error::Error(Type type) :
        msg_(nullptr),
        type_(type) {
 80a1f98:	2200      	movs	r2, #0

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
}

inline particle::Error::Error(Error&& error) :
 80a1f9a:	b530      	push	{r4, r5, lr}
        type_(type) {
 80a1f9c:	f64f 749c 	movw	r4, #65436	; 0xff9c
 80a1fa0:	6002      	str	r2, [r0, #0]
 80a1fa2:	8084      	strh	r4, [r0, #4]
      __a = _GLIBCXX_MOVE(__b);
 80a1fa4:	888d      	ldrh	r5, [r1, #4]
      __b = _GLIBCXX_MOVE(__tmp);
 80a1fa6:	808c      	strh	r4, [r1, #4]
      __a = _GLIBCXX_MOVE(__b);
 80a1fa8:	680c      	ldr	r4, [r1, #0]
 80a1faa:	8085      	strh	r5, [r0, #4]
 80a1fac:	6004      	str	r4, [r0, #0]
      __b = _GLIBCXX_MOVE(__tmp);
 80a1fae:	600a      	str	r2, [r1, #0]
        Error() {
    swap(*this, error);
}
 80a1fb0:	bd30      	pop	{r4, r5, pc}

080a1fb2 <_ZN8particle5ErrorD1Ev>:

inline particle::Error::~Error() {
 80a1fb2:	b510      	push	{r4, lr}
 80a1fb4:	4604      	mov	r4, r0
    free((void*)msg_);
 80a1fb6:	6800      	ldr	r0, [r0, #0]
 80a1fb8:	f7ff fd1c 	bl	80a19f4 <free>
}
 80a1fbc:	4620      	mov	r0, r4
 80a1fbe:	bd10      	pop	{r4, pc}

080a1fc0 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      _M_dispose() noexcept
 80a1fc0:	b538      	push	{r3, r4, r5, lr}
      { delete _M_ptr; }
 80a1fc2:	68c4      	ldr	r4, [r0, #12]
 80a1fc4:	b1f4      	cbz	r4, 80a2004 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x44>
      _Tp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
	alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
	_Tp* __ptr = reinterpret_cast<_Tp*>(__buf);
	__atomic_load(std::__addressof(_M_i), __ptr, int(__m));
 80a1fc6:	7823      	ldrb	r3, [r4, #0]
    ~FutureImpl() {
        // Call destructor of the appropriate unnamed enum's field
        const State s = this->state();
        if (s == State::SUCCEEDED) {
            result_.~ResultT();
        } else if (s == State::FAILED) {
 80a1fc8:	2b02      	cmp	r3, #2
 80a1fca:	d103      	bne.n	80a1fd4 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x14>
            error_.~Error();
 80a1fcc:	f104 000c 	add.w	r0, r4, #12
 80a1fd0:	f7ff ffef 	bl	80a1fb2 <_ZN8particle5ErrorD1Ev>
      {
	memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_p, int(__m));
 80a1fd4:	6865      	ldr	r5, [r4, #4]
        delete onSuccess_.load(std::memory_order_relaxed);
 80a1fd6:	b135      	cbz	r5, 80a1fe6 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x26>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a1fd8:	4628      	mov	r0, r5
 80a1fda:	f7ff fefe 	bl	80a1dda <_ZNSt14_Function_baseD1Ev>
 80a1fde:	2110      	movs	r1, #16
 80a1fe0:	4628      	mov	r0, r5
 80a1fe2:	f000 fe25 	bl	80a2c30 <_ZdlPvj>
 80a1fe6:	68a5      	ldr	r5, [r4, #8]
        delete onError_.load(std::memory_order_relaxed);
 80a1fe8:	b135      	cbz	r5, 80a1ff8 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x38>
 80a1fea:	4628      	mov	r0, r5
 80a1fec:	f7ff fef5 	bl	80a1dda <_ZNSt14_Function_baseD1Ev>
 80a1ff0:	2110      	movs	r1, #16
 80a1ff2:	4628      	mov	r0, r5
 80a1ff4:	f000 fe1c 	bl	80a2c30 <_ZdlPvj>
 80a1ff8:	4620      	mov	r0, r4
 80a1ffa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80a1ffe:	2114      	movs	r1, #20
 80a2000:	f000 be16 	b.w	80a2c30 <_ZdlPvj>
 80a2004:	bd38      	pop	{r3, r4, r5, pc}

080a2006 <_ZN10CloudClass22call_raw_user_functionEPvPKcS0_>:
    }
    return CloudDisconnectOptions(options->flags, options->timeout, options->graceful, clearSession);
}

int CloudClass::call_raw_user_function(void* data, const char* param, void* reserved)
{
 80a2006:	b510      	push	{r4, lr}
 80a2008:	b088      	sub	sp, #32
 80a200a:	4604      	mov	r4, r0
    user_function_int_str_t* fn = (user_function_int_str_t*)(data);
    String p(param);
 80a200c:	4668      	mov	r0, sp
 80a200e:	f7ff fdd5 	bl	80a1bbc <_ZN6StringC1EPKc>
    return (*fn)(p);
 80a2012:	4669      	mov	r1, sp
 80a2014:	a804      	add	r0, sp, #16
 80a2016:	f7ff fe10 	bl	80a1c3a <_ZN6StringC1ERKS_>
 80a201a:	a804      	add	r0, sp, #16
 80a201c:	47a0      	blx	r4
 80a201e:	4604      	mov	r4, r0
 80a2020:	a804      	add	r0, sp, #16
 80a2022:	f7ff fd81 	bl	80a1b28 <_ZN6StringD1Ev>
    String p(param);
 80a2026:	4668      	mov	r0, sp
 80a2028:	f7ff fd7e 	bl	80a1b28 <_ZN6StringD1Ev>
}
 80a202c:	4620      	mov	r0, r4
 80a202e:	b008      	add	sp, #32
 80a2030:	bd10      	pop	{r4, pc}

080a2032 <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>:
    wiring_event_handler_t* fn = (wiring_event_handler_t*)(handler_data);
    (*fn)(event_name, data);
}

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
 80a2032:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    const char *funcKey;
    cloud_function_t fn;
    void* data;

     cloud_function_descriptor() {
         memset(this, 0, sizeof(*this));
 80a2034:	2300      	movs	r3, #0
         size = sizeof(*this);
 80a2036:	2410      	movs	r4, #16
    cloud_function_descriptor desc = {};
    desc.size = sizeof(desc);
    desc.fn = fn;
    desc.data = (void*)data;
 80a2038:	e9cd 0102 	strd	r0, r1, [sp, #8]
    desc.funcKey = funcKey;
 80a203c:	9201      	str	r2, [sp, #4]
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
 80a203e:	4669      	mov	r1, sp
 80a2040:	461a      	mov	r2, r3
 80a2042:	4618      	mov	r0, r3
         memset(this, 0, sizeof(*this));
 80a2044:	f8ad 3002 	strh.w	r3, [sp, #2]
         size = sizeof(*this);
 80a2048:	f8ad 4000 	strh.w	r4, [sp]
 80a204c:	f7ff fcaa 	bl	80a19a4 <spark_function>
}
 80a2050:	b004      	add	sp, #16
 80a2052:	bd10      	pop	{r4, pc}

080a2054 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>:
        // TODO: Use custom reference counting object to avoid unnecessary memory allocation
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
    }

    // Unwraps promise from an object pointer created via dataPtr() method
    static Promise<ResultT, ContextT> fromDataPtr(void* data) {
 80a2054:	b573      	push	{r0, r1, r4, r5, r6, lr}
      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a2056:	460e      	mov	r6, r1
 80a2058:	4604      	mov	r4, r0
 80a205a:	f856 3b04 	ldr.w	r3, [r6], #4
 80a205e:	460d      	mov	r5, r1
 80a2060:	a801      	add	r0, sp, #4
 80a2062:	4631      	mov	r1, r6
 80a2064:	9300      	str	r3, [sp, #0]
 80a2066:	f7ff fe9c 	bl	80a1da2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
	__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
	{ }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a206a:	9b00      	ldr	r3, [sp, #0]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 80a206c:	9a01      	ldr	r2, [sp, #4]
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a206e:	6023      	str	r3, [r4, #0]
	__r._M_pi = _M_pi;
 80a2070:	2300      	movs	r3, #0
	_M_pi = __tmp;
 80a2072:	6062      	str	r2, [r4, #4]
      ~__shared_ptr() = default;
 80a2074:	a801      	add	r0, sp, #4
	__r._M_pi = _M_pi;
 80a2076:	9301      	str	r3, [sp, #4]
      {
	_M_refcount._M_swap(__r._M_refcount);
	__r._M_ptr = 0;
 80a2078:	9300      	str	r3, [sp, #0]
      ~__shared_ptr() = default;
 80a207a:	f7fe f85f 	bl	80a013c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a207e:	4630      	mov	r0, r6
 80a2080:	f7fe f85c 	bl	80a013c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        auto d = static_cast<detail::FutureImplPtr<ResultT, ContextT>*>(data);
        const Promise<ResultT, ContextT> p(*d);
        delete d;
 80a2084:	4628      	mov	r0, r5
 80a2086:	2108      	movs	r1, #8
 80a2088:	f000 fdd2 	bl	80a2c30 <_ZdlPvj>
        return p;
    }
 80a208c:	4620      	mov	r0, r4
 80a208e:	b002      	add	sp, #8
 80a2090:	bd70      	pop	{r4, r5, r6, pc}

080a2092 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>:
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a2092:	6882      	ldr	r2, [r0, #8]
    function<_Res(_ArgTypes...)>::
 80a2094:	b510      	push	{r4, lr}
      if (_M_empty())
 80a2096:	b90a      	cbnz	r2, 80a209c <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_+0xa>
	__throw_bad_function_call();
 80a2098:	f000 fdce 	bl	80a2c38 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a209c:	68c3      	ldr	r3, [r0, #12]
    }
 80a209e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a20a2:	4718      	bx	r3

080a20a4 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE9_M_invokeERKSt9_Any_data>:
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 80a20a4:	b508      	push	{r3, lr}
	    return __source._M_access<_Functor*>();
 80a20a6:	6800      	ldr	r0, [r0, #0]
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }
 80a20a8:	f100 0110 	add.w	r1, r0, #16
 80a20ac:	f7ff fff1 	bl	80a2092 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
      }
 80a20b0:	bd08      	pop	{r3, pc}

080a20b2 <_ZNKSt8functionIFvRKbEEclES1_>:
      if (_M_empty())
 80a20b2:	6882      	ldr	r2, [r0, #8]
    function<_Res(_ArgTypes...)>::
 80a20b4:	b510      	push	{r4, lr}
      if (_M_empty())
 80a20b6:	b90a      	cbnz	r2, 80a20bc <_ZNKSt8functionIFvRKbEEclES1_+0xa>
	__throw_bad_function_call();
 80a20b8:	f000 fdbe 	bl	80a2c38 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a20bc:	68c3      	ldr	r3, [r0, #12]
    }
 80a20be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a20c2:	4718      	bx	r3

080a20c4 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE9_M_invokeERKSt9_Any_data>:
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 80a20c4:	b508      	push	{r3, lr}
	    return __source._M_access<_Functor*>();
 80a20c6:	6800      	ldr	r0, [r0, #0]
 80a20c8:	f100 0110 	add.w	r1, r0, #16
 80a20cc:	f7ff fff1 	bl	80a20b2 <_ZNKSt8functionIFvRKbEEclES1_>
      }
 80a20d0:	bd08      	pop	{r3, pc}
	...

080a20d4 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>:
	__shared_count(_Ptr __p) : _M_pi(0)
 80a20d4:	b538      	push	{r3, r4, r5, lr}
 80a20d6:	2300      	movs	r3, #0
 80a20d8:	4604      	mov	r4, r0
 80a20da:	6003      	str	r3, [r0, #0]
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a20dc:	2010      	movs	r0, #16
	__shared_count(_Ptr __p) : _M_pi(0)
 80a20de:	460d      	mov	r5, r1
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a20e0:	f7fd ffd9 	bl	80a0096 <_Znwj>
 80a20e4:	b128      	cbz	r0, 80a20f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_+0x1e>
      : _M_use_count(1), _M_weak_count(1) { }
 80a20e6:	2301      	movs	r3, #1
 80a20e8:	e9c0 3301 	strd	r3, r3, [r0, #4]
      : _M_ptr(__p) { }
 80a20ec:	4b02      	ldr	r3, [pc, #8]	; (80a20f8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_+0x24>)
 80a20ee:	60c5      	str	r5, [r0, #12]
 80a20f0:	6003      	str	r3, [r0, #0]
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a20f2:	6020      	str	r0, [r4, #0]
	}
 80a20f4:	4620      	mov	r0, r4
 80a20f6:	bd38      	pop	{r3, r4, r5, pc}
 80a20f8:	080a2ff4 	.word	0x080a2ff4

080a20fc <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>:
    function<_Res(_ArgTypes...)>::
 80a20fc:	b538      	push	{r3, r4, r5, lr}
    _Function_base() : _M_manager(nullptr) { }
 80a20fe:	2300      	movs	r3, #0
 80a2100:	6083      	str	r3, [r0, #8]
      { return !_M_empty(); }
 80a2102:	688b      	ldr	r3, [r1, #8]
    function<_Res(_ArgTypes...)>::
 80a2104:	4604      	mov	r4, r0
 80a2106:	460d      	mov	r5, r1
      if (static_cast<bool>(__x))
 80a2108:	b12b      	cbz	r3, 80a2116 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_+0x1a>
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a210a:	2202      	movs	r2, #2
 80a210c:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a210e:	68eb      	ldr	r3, [r5, #12]
 80a2110:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a2112:	68ab      	ldr	r3, [r5, #8]
 80a2114:	60a3      	str	r3, [r4, #8]
    }
 80a2116:	4620      	mov	r0, r4
 80a2118:	bd38      	pop	{r3, r4, r5, pc}
	...

080a211c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>:
    void setError(Error error) {
 80a211c:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a211e:	b089      	sub	sp, #36	; 0x24
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
 80a2120:	6804      	ldr	r4, [r0, #0]
        p_->setError(std::move(error));
 80a2122:	4668      	mov	r0, sp
 80a2124:	f7ff ff38 	bl	80a1f98 <_ZN8particle5ErrorC1EOS0_>

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
			      memory_order __f) noexcept
      {
	return __atomic_compare_exchange(std::__addressof(_M_i),
 80a2128:	f04f 0302 	mov.w	r3, #2
 80a212c:	e8d4 2f4f 	ldrexb	r2, [r4]
 80a2130:	2a00      	cmp	r2, #0
 80a2132:	d103      	bne.n	80a213c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x20>
 80a2134:	e8c4 3f41 	strexb	r1, r3, [r4]
 80a2138:	2900      	cmp	r1, #0
 80a213a:	d1f7      	bne.n	80a212c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x10>
        if (this->changeState(State::FAILED)) {
 80a213c:	d125      	bne.n	80a218a <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x6e>
            new(&error_) Error(std::move(error));
 80a213e:	f104 050c 	add.w	r5, r4, #12
 80a2142:	4669      	mov	r1, sp
 80a2144:	4628      	mov	r0, r5
 80a2146:	f7ff ff27 	bl	80a1f98 <_ZN8particle5ErrorC1EOS0_>
	__atomic_store_n(&_M_i, __i, int(__m));
 80a214a:	2301      	movs	r3, #1
 80a214c:	f3bf 8f5b 	dmb	ish
 80a2150:	7063      	strb	r3, [r4, #1]

      _GLIBCXX_ALWAYS_INLINE __pointer_type
      exchange(__pointer_type __p,
	       memory_order __m = memory_order_seq_cst) noexcept
      {
	return __atomic_exchange_n(&_M_p, __p, int(__m));
 80a2152:	2000      	movs	r0, #0
 80a2154:	f3bf 8f5b 	dmb	ish
 80a2158:	f104 0308 	add.w	r3, r4, #8
 80a215c:	e853 6f00 	ldrex	r6, [r3]
 80a2160:	e843 0200 	strex	r2, r0, [r3]
 80a2164:	2a00      	cmp	r2, #0
 80a2166:	d1f9      	bne.n	80a215c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x40>
 80a2168:	f3bf 8f5b 	dmb	ish
        if (callbackPtr) {
 80a216c:	b16e      	cbz	r6, 80a218a <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x6e>
        return (application_thread_current(nullptr) != 0);
 80a216e:	f7ff fb8d 	bl	80a188c <application_thread_current>
        if (ContextT::isApplicationThreadCurrent()) {
 80a2172:	b178      	cbz	r0, 80a2194 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x78>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
 80a2174:	4629      	mov	r1, r5
 80a2176:	4630      	mov	r0, r6
 80a2178:	f7ff ff8b 	bl	80a2092 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
    class function<_Res(_ArgTypes...)>
 80a217c:	4630      	mov	r0, r6
 80a217e:	f7ff fe2c 	bl	80a1dda <_ZNSt14_Function_baseD1Ev>
            delete callbackPtr;
 80a2182:	2110      	movs	r1, #16
 80a2184:	4630      	mov	r0, r6
 80a2186:	f000 fd53 	bl	80a2c30 <_ZdlPvj>
        p_->setError(std::move(error));
 80a218a:	4668      	mov	r0, sp
 80a218c:	f7ff ff11 	bl	80a1fb2 <_ZN8particle5ErrorD1Ev>
    }
 80a2190:	b009      	add	sp, #36	; 0x24
 80a2192:	bdf0      	pop	{r4, r5, r6, r7, pc}
	  typename __cv_quals<_Bound_args>::type...>;

     public:
      template<typename... _Args>
	explicit _Bind(const _Functor& __f, _Args&&... __args)
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 80a2194:	4631      	mov	r1, r6
 80a2196:	a802      	add	r0, sp, #8
 80a2198:	f7ff ffb0 	bl	80a20fc <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
        Error(error.type_, error.msg_) {
 80a219c:	68e0      	ldr	r0, [r4, #12]
 80a219e:	f9b4 5010 	ldrsh.w	r5, [r4, #16]
        msg_(msg ? (const char*)strdup(msg) : nullptr),
 80a21a2:	b108      	cbz	r0, 80a21a8 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x8c>
 80a21a4:	f000 fda2 	bl	80a2cec <strdup>
        type_(type) {
 80a21a8:	9006      	str	r0, [sp, #24]
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
 80a21aa:	2010      	movs	r0, #16
 80a21ac:	f8ad 501c 	strh.w	r5, [sp, #28]
 80a21b0:	f7fd ff71 	bl	80a0096 <_Znwj>
 80a21b4:	4605      	mov	r5, r0
 80a21b6:	b1e8      	cbz	r0, 80a21f4 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xd8>
    _Function_base() : _M_manager(nullptr) { }
 80a21b8:	2700      	movs	r7, #0
 80a21ba:	6087      	str	r7, [r0, #8]
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a21bc:	2018      	movs	r0, #24
 80a21be:	f7fd ff6a 	bl	80a0096 <_Znwj>
 80a21c2:	4604      	mov	r4, r0
 80a21c4:	b188      	cbz	r0, 80a21ea <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xce>
	std::swap(_M_functor, __x._M_functor);
 80a21c6:	4601      	mov	r1, r0
    _Function_base() : _M_manager(nullptr) { }
 80a21c8:	6087      	str	r7, [r0, #8]
	std::swap(_M_functor, __x._M_functor);
 80a21ca:	a802      	add	r0, sp, #8
 80a21cc:	f7ff fe0e 	bl	80a1dec <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a21d0:	9b04      	ldr	r3, [sp, #16]
      __a = _GLIBCXX_MOVE(__b);
 80a21d2:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a21d4:	60a3      	str	r3, [r4, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a21d6:	9b05      	ldr	r3, [sp, #20]
      __a = _GLIBCXX_MOVE(__b);
 80a21d8:	9204      	str	r2, [sp, #16]
 80a21da:	68e2      	ldr	r2, [r4, #12]
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 80a21dc:	a906      	add	r1, sp, #24
      __b = _GLIBCXX_MOVE(__tmp);
 80a21de:	60e3      	str	r3, [r4, #12]
 80a21e0:	f104 0010 	add.w	r0, r4, #16
      __a = _GLIBCXX_MOVE(__b);
 80a21e4:	9205      	str	r2, [sp, #20]
 80a21e6:	f7ff fed7 	bl	80a1f98 <_ZN8particle5ErrorC1EOS0_>
	    _M_invoker = &_My_handler::_M_invoke;
 80a21ea:	4b08      	ldr	r3, [pc, #32]	; (80a220c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf0>)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a21ec:	602c      	str	r4, [r5, #0]
	    _M_invoker = &_My_handler::_M_invoke;
 80a21ee:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a21f0:	4b07      	ldr	r3, [pc, #28]	; (80a2210 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf4>)
 80a21f2:	60ab      	str	r3, [r5, #8]
    struct _Head_base<_Idx, _Head, false>
 80a21f4:	a806      	add	r0, sp, #24
 80a21f6:	f7ff fedc 	bl	80a1fb2 <_ZN8particle5ErrorD1Ev>
    class function<_Res(_ArgTypes...)>
 80a21fa:	a802      	add	r0, sp, #8
 80a21fc:	f7ff fded 	bl	80a1dda <_ZNSt14_Function_baseD1Ev>
        return (application_thread_invoke(callback, data, nullptr) == 0);
 80a2200:	2200      	movs	r2, #0
 80a2202:	4629      	mov	r1, r5
 80a2204:	4803      	ldr	r0, [pc, #12]	; (80a2214 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf8>)
 80a2206:	f7ff fb49 	bl	80a189c <application_thread_invoke>
 80a220a:	e7b7      	b.n	80a217c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x60>
 80a220c:	080a20a5 	.word	0x080a20a5
 80a2210:	080a233d 	.word	0x080a233d
 80a2214:	080a284d 	.word	0x080a284d

080a2218 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>:

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
 80a2218:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a221c:	b08a      	sub	sp, #40	; 0x28
 80a221e:	4605      	mov	r5, r0
 80a2220:	460c      	mov	r4, r1
 80a2222:	4617      	mov	r7, r2
 80a2224:	4698      	mov	r8, r3
 80a2226:	f89d 9048 	ldrb.w	r9, [sp, #72]	; 0x48
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
 80a222a:	f7ff fbc3 	bl	80a19b4 <spark_cloud_flag_connected>
 80a222e:	ae07      	add	r6, sp, #28
    if (!connected()) {
 80a2230:	4682      	mov	sl, r0
 80a2232:	bb38      	cbnz	r0, 80a2284 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x6c>
        type_(type) {
 80a2234:	f64f 732e 	movw	r3, #65326	; 0xff2e
 80a2238:	9005      	str	r0, [sp, #20]
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnSuccessCallback OnSuccessCallback;
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnErrorCallback OnErrorCallback;

    // Construct failed future
    explicit FutureBase(Error error) :
            p_(new detail::FutureImpl<ResultT, ContextT>(std::move(error))) {
 80a223a:	a905      	add	r1, sp, #20
 80a223c:	4630      	mov	r0, r6
 80a223e:	f8ad 3018 	strh.w	r3, [sp, #24]
 80a2242:	f7ff fea9 	bl	80a1f98 <_ZN8particle5ErrorC1EOS0_>
 80a2246:	2014      	movs	r0, #20
 80a2248:	f7fd ff25 	bl	80a0096 <_Znwj>
 80a224c:	4604      	mov	r4, r0
 80a224e:	b148      	cbz	r0, 80a2264 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x4c>
      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }
 80a2250:	2302      	movs	r3, #2
 80a2252:	7003      	strb	r3, [r0, #0]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
 80a2254:	2301      	movs	r3, #1
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
 80a2256:	e9c0 aa01 	strd	sl, sl, [r0, #4]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
 80a225a:	7043      	strb	r3, [r0, #1]
            error_(std::move(error)) {
 80a225c:	4631      	mov	r1, r6
 80a225e:	300c      	adds	r0, #12
 80a2260:	f7ff fe9a 	bl	80a1f98 <_ZN8particle5ErrorC1EOS0_>
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 80a2264:	4628      	mov	r0, r5
	: __shared_count(__p)
 80a2266:	4621      	mov	r1, r4
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 80a2268:	f840 4b04 	str.w	r4, [r0], #4
	: __shared_count(__p)
 80a226c:	f7ff ff32 	bl	80a20d4 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>
            p_(new detail::FutureImpl<ResultT, ContextT>(std::move(error))) {
 80a2270:	4630      	mov	r0, r6
 80a2272:	f7ff fe9e 	bl	80a1fb2 <_ZN8particle5ErrorD1Ev>
    }

    explicit FutureBase(Error::Type error) :
            FutureBase(Error(error)) {
 80a2276:	a805      	add	r0, sp, #20
 80a2278:	f7ff fe9b 	bl	80a1fb2 <_ZN8particle5ErrorD1Ev>
        p.setError(Error::UNKNOWN);
        p.fromDataPtr(d.handler_data); // Free wrapper object
    }

    return p.future();
}
 80a227c:	4628      	mov	r0, r5
 80a227e:	b00a      	add	sp, #40	; 0x28
 80a2280:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    spark_send_event_data d = { sizeof(spark_send_event_data) };
 80a2284:	230c      	movs	r3, #12
 80a2286:	f04f 0a00 	mov.w	sl, #0
            p_(new detail::FutureImpl<ResultT, ContextT>(State::RUNNING)) {
 80a228a:	2014      	movs	r0, #20
 80a228c:	e9cd aa08 	strd	sl, sl, [sp, #32]
 80a2290:	9307      	str	r3, [sp, #28]
 80a2292:	f7fd ff00 	bl	80a0096 <_Znwj>
 80a2296:	4601      	mov	r1, r0
 80a2298:	b128      	cbz	r0, 80a22a6 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x8e>
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
 80a229a:	e9c0 aa01 	strd	sl, sl, [r0, #4]
 80a229e:	f880 a000 	strb.w	sl, [r0]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
 80a22a2:	f880 a001 	strb.w	sl, [r0, #1]
 80a22a6:	a804      	add	r0, sp, #16
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 80a22a8:	9103      	str	r1, [sp, #12]
	: __shared_count(__p)
 80a22aa:	f7ff ff13 	bl	80a20d4 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>
    d.handler_callback = publishCompletionCallback;
 80a22ae:	4b22      	ldr	r3, [pc, #136]	; (80a2338 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x120>)
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
 80a22b0:	2008      	movs	r0, #8
 80a22b2:	9308      	str	r3, [sp, #32]
 80a22b4:	f7fd feef 	bl	80a0096 <_Znwj>
 80a22b8:	4682      	mov	sl, r0
 80a22ba:	b128      	cbz	r0, 80a22c8 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xb0>
      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a22bc:	9b03      	ldr	r3, [sp, #12]
 80a22be:	a904      	add	r1, sp, #16
 80a22c0:	f840 3b04 	str.w	r3, [r0], #4
 80a22c4:	f7ff fd6d 	bl	80a1da2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
 80a22c8:	4642      	mov	r2, r8
 80a22ca:	4639      	mov	r1, r7
 80a22cc:	4620      	mov	r0, r4
 80a22ce:	9600      	str	r6, [sp, #0]
 80a22d0:	fa5f f389 	uxtb.w	r3, r9
    d.handler_data = p.dataPtr();
 80a22d4:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
 80a22d8:	f7ff fb74 	bl	80a19c4 <spark_send_event>
 80a22dc:	b9b8      	cbnz	r0, 80a230e <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xf6>
	return __atomic_load_n(&_M_i, int(__m));
 80a22de:	9b03      	ldr	r3, [sp, #12]
 80a22e0:	785b      	ldrb	r3, [r3, #1]
 80a22e2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80a22e6:	b993      	cbnz	r3, 80a230e <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xf6>
 80a22e8:	f64f 739c 	movw	r3, #65436	; 0xff9c
        p.setError(Error::UNKNOWN);
 80a22ec:	a905      	add	r1, sp, #20
 80a22ee:	a803      	add	r0, sp, #12
 80a22f0:	9205      	str	r2, [sp, #20]
 80a22f2:	f8ad 3018 	strh.w	r3, [sp, #24]
 80a22f6:	f7ff ff11 	bl	80a211c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
 80a22fa:	a805      	add	r0, sp, #20
 80a22fc:	f7ff fe59 	bl	80a1fb2 <_ZN8particle5ErrorD1Ev>
        p.fromDataPtr(d.handler_data); // Free wrapper object
 80a2300:	a805      	add	r0, sp, #20
 80a2302:	9909      	ldr	r1, [sp, #36]	; 0x24
 80a2304:	f7ff fea6 	bl	80a2054 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
      ~__shared_ptr() = default;
 80a2308:	a806      	add	r0, sp, #24
 80a230a:	f7fd ff17 	bl	80a013c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a230e:	9b03      	ldr	r3, [sp, #12]
 80a2310:	a904      	add	r1, sp, #16
 80a2312:	a806      	add	r0, sp, #24
 80a2314:	9305      	str	r3, [sp, #20]
 80a2316:	f7ff fd44 	bl	80a1da2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a231a:	9b05      	ldr	r3, [sp, #20]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 80a231c:	9a06      	ldr	r2, [sp, #24]
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a231e:	602b      	str	r3, [r5, #0]
	__r._M_pi = _M_pi;
 80a2320:	2300      	movs	r3, #0
	_M_pi = __tmp;
 80a2322:	606a      	str	r2, [r5, #4]
      ~__shared_ptr() = default;
 80a2324:	a806      	add	r0, sp, #24
	__r._M_pi = _M_pi;
 80a2326:	9306      	str	r3, [sp, #24]
	__r._M_ptr = 0;
 80a2328:	9305      	str	r3, [sp, #20]
      ~__shared_ptr() = default;
 80a232a:	f7fd ff07 	bl	80a013c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a232e:	a804      	add	r0, sp, #16
 80a2330:	f7fd ff04 	bl	80a013c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
class Promise: public PromiseBase<ResultT, ContextT> {
 80a2334:	e7a2      	b.n	80a227c <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x64>
 80a2336:	bf00      	nop
 80a2338:	080a2401 	.word	0x080a2401

080a233c <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation>:
	  switch (__op)
 80a233c:	2a02      	cmp	r2, #2
	_M_manager(_Any_data& __dest, const _Any_data& __source,
 80a233e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2340:	4605      	mov	r5, r0
	  switch (__op)
 80a2342:	d007      	beq.n	80a2354 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x18>
 80a2344:	2a03      	cmp	r2, #3
 80a2346:	d018      	beq.n	80a237a <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x3e>
 80a2348:	2a01      	cmp	r2, #1
 80a234a:	d101      	bne.n	80a2350 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x14>
	    return __source._M_access<_Functor*>();
 80a234c:	680b      	ldr	r3, [r1, #0]
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a234e:	6003      	str	r3, [r0, #0]
	}
 80a2350:	2000      	movs	r0, #0
 80a2352:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	    new _Functor(*__source._M_access<const _Functor*>());
 80a2354:	2018      	movs	r0, #24
	  __dest._M_access<_Functor*>() =
 80a2356:	680e      	ldr	r6, [r1, #0]
	    new _Functor(*__source._M_access<const _Functor*>());
 80a2358:	f7fd fe9d 	bl	80a0096 <_Znwj>
 80a235c:	4604      	mov	r4, r0
 80a235e:	b150      	cbz	r0, 80a2376 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x3a>
      template<typename... _Args>
	explicit _Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
 80a2360:	4631      	mov	r1, r6
 80a2362:	f7ff fecb 	bl	80a20fc <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
        Error(error.type_, error.msg_) {
 80a2366:	6930      	ldr	r0, [r6, #16]
 80a2368:	f9b6 7014 	ldrsh.w	r7, [r6, #20]
        msg_(msg ? (const char*)strdup(msg) : nullptr),
 80a236c:	b108      	cbz	r0, 80a2372 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x36>
 80a236e:	f000 fcbd 	bl	80a2cec <strdup>
        type_(type) {
 80a2372:	6120      	str	r0, [r4, #16]
 80a2374:	82a7      	strh	r7, [r4, #20]
	  __dest._M_access<_Functor*>() =
 80a2376:	602c      	str	r4, [r5, #0]
	}
 80a2378:	e7ea      	b.n	80a2350 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x14>
	  delete __victim._M_access<_Functor*>();
 80a237a:	6804      	ldr	r4, [r0, #0]
 80a237c:	2c00      	cmp	r4, #0
 80a237e:	d0e7      	beq.n	80a2350 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x14>
 80a2380:	f104 0010 	add.w	r0, r4, #16
 80a2384:	f7ff fe15 	bl	80a1fb2 <_ZN8particle5ErrorD1Ev>
    class function<_Res(_ArgTypes...)>
 80a2388:	4620      	mov	r0, r4
 80a238a:	f7ff fd26 	bl	80a1dda <_ZNSt14_Function_baseD1Ev>
	  delete __victim._M_access<_Functor*>();
 80a238e:	2118      	movs	r1, #24
 80a2390:	4620      	mov	r0, r4
 80a2392:	f000 fc4d 	bl	80a2c30 <_ZdlPvj>
 80a2396:	e7db      	b.n	80a2350 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x14>

080a2398 <_ZNSt8functionIFvRKbEEC1ERKS3_>:
    function<_Res(_ArgTypes...)>::
 80a2398:	b538      	push	{r3, r4, r5, lr}
    _Function_base() : _M_manager(nullptr) { }
 80a239a:	2300      	movs	r3, #0
 80a239c:	6083      	str	r3, [r0, #8]
      { return !_M_empty(); }
 80a239e:	688b      	ldr	r3, [r1, #8]
    function<_Res(_ArgTypes...)>::
 80a23a0:	4604      	mov	r4, r0
 80a23a2:	460d      	mov	r5, r1
      if (static_cast<bool>(__x))
 80a23a4:	b12b      	cbz	r3, 80a23b2 <_ZNSt8functionIFvRKbEEC1ERKS3_+0x1a>
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a23a6:	2202      	movs	r2, #2
 80a23a8:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a23aa:	68eb      	ldr	r3, [r5, #12]
 80a23ac:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a23ae:	68ab      	ldr	r3, [r5, #8]
 80a23b0:	60a3      	str	r3, [r4, #8]
    }
 80a23b2:	4620      	mov	r0, r4
 80a23b4:	bd38      	pop	{r3, r4, r5, pc}

080a23b6 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation>:
	  switch (__op)
 80a23b6:	2a02      	cmp	r2, #2
	_M_manager(_Any_data& __dest, const _Any_data& __source,
 80a23b8:	b570      	push	{r4, r5, r6, lr}
 80a23ba:	4604      	mov	r4, r0
	  switch (__op)
 80a23bc:	d007      	beq.n	80a23ce <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x18>
 80a23be:	2a03      	cmp	r2, #3
 80a23c0:	d012      	beq.n	80a23e8 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x32>
 80a23c2:	2a01      	cmp	r2, #1
 80a23c4:	d101      	bne.n	80a23ca <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x14>
	    return __source._M_access<_Functor*>();
 80a23c6:	680b      	ldr	r3, [r1, #0]
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a23c8:	6003      	str	r3, [r0, #0]
	}
 80a23ca:	2000      	movs	r0, #0
 80a23cc:	bd70      	pop	{r4, r5, r6, pc}
	    new _Functor(*__source._M_access<const _Functor*>());
 80a23ce:	2014      	movs	r0, #20
	  __dest._M_access<_Functor*>() =
 80a23d0:	680e      	ldr	r6, [r1, #0]
	    new _Functor(*__source._M_access<const _Functor*>());
 80a23d2:	f7fd fe60 	bl	80a0096 <_Znwj>
 80a23d6:	4605      	mov	r5, r0
 80a23d8:	b120      	cbz	r0, 80a23e4 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x2e>
 80a23da:	4631      	mov	r1, r6
 80a23dc:	f7ff ffdc 	bl	80a2398 <_ZNSt8functionIFvRKbEEC1ERKS3_>
 80a23e0:	7c33      	ldrb	r3, [r6, #16]
 80a23e2:	742b      	strb	r3, [r5, #16]
	  __dest._M_access<_Functor*>() =
 80a23e4:	6025      	str	r5, [r4, #0]
	}
 80a23e6:	e7f0      	b.n	80a23ca <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x14>
	  delete __victim._M_access<_Functor*>();
 80a23e8:	6804      	ldr	r4, [r0, #0]
 80a23ea:	2c00      	cmp	r4, #0
 80a23ec:	d0ed      	beq.n	80a23ca <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x14>
    class function<_Res(_ArgTypes...)>
 80a23ee:	4620      	mov	r0, r4
 80a23f0:	f7ff fcf3 	bl	80a1dda <_ZNSt14_Function_baseD1Ev>
	  delete __victim._M_access<_Functor*>();
 80a23f4:	2114      	movs	r1, #20
 80a23f6:	4620      	mov	r0, r4
 80a23f8:	f000 fc1a 	bl	80a2c30 <_ZdlPvj>
 80a23fc:	e7e5      	b.n	80a23ca <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x14>
	...

080a2400 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_>:
void publishCompletionCallback(int error, const void* data, void* callbackData, void* reserved) {
 80a2400:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a2402:	4604      	mov	r4, r0
 80a2404:	b089      	sub	sp, #36	; 0x24
 80a2406:	460d      	mov	r5, r1
    auto p = Promise<bool>::fromDataPtr(callbackData);
 80a2408:	a801      	add	r0, sp, #4
 80a240a:	4611      	mov	r1, r2
 80a240c:	f7ff fe22 	bl	80a2054 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
    if (error != Error::NONE) {
 80a2410:	b1a4      	cbz	r4, 80a243c <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x3c>
        p.setError(Error((Error::Type)error, (const char*)data));
 80a2412:	b224      	sxth	r4, r4
        msg_(msg ? (const char*)strdup(msg) : nullptr),
 80a2414:	b11d      	cbz	r5, 80a241e <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x1e>
 80a2416:	4628      	mov	r0, r5
 80a2418:	f000 fc68 	bl	80a2cec <strdup>
 80a241c:	4605      	mov	r5, r0
 80a241e:	a801      	add	r0, sp, #4
 80a2420:	a903      	add	r1, sp, #12
        type_(type) {
 80a2422:	9503      	str	r5, [sp, #12]
 80a2424:	f8ad 4010 	strh.w	r4, [sp, #16]
 80a2428:	f7ff fe78 	bl	80a211c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
 80a242c:	a803      	add	r0, sp, #12
 80a242e:	f7ff fdc0 	bl	80a1fb2 <_ZN8particle5ErrorD1Ev>
 80a2432:	a802      	add	r0, sp, #8
 80a2434:	f7fd fe82 	bl	80a013c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a2438:	b009      	add	sp, #36	; 0x24
 80a243a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return __atomic_compare_exchange(std::__addressof(_M_i),
 80a243c:	2301      	movs	r3, #1
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
 80a243e:	9d01      	ldr	r5, [sp, #4]
 80a2440:	e8d5 2f4f 	ldrexb	r2, [r5]
 80a2444:	2a00      	cmp	r2, #0
 80a2446:	d103      	bne.n	80a2450 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x50>
 80a2448:	e8c5 3f41 	strexb	r1, r3, [r5]
 80a244c:	2900      	cmp	r1, #0
 80a244e:	d1f7      	bne.n	80a2440 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x40>
        if (this->changeState(State::SUCCEEDED)) {
 80a2450:	d1ef      	bne.n	80a2432 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
            new(&result_) ResultT(std::move(result));
 80a2452:	732b      	strb	r3, [r5, #12]
	__atomic_store_n(&_M_i, __i, int(__m));
 80a2454:	f3bf 8f5b 	dmb	ish
 80a2458:	706b      	strb	r3, [r5, #1]
	return __atomic_exchange_n(&_M_p, __p, int(__m));
 80a245a:	f3bf 8f5b 	dmb	ish
 80a245e:	1d2b      	adds	r3, r5, #4
 80a2460:	e853 6f00 	ldrex	r6, [r3]
 80a2464:	e843 4200 	strex	r2, r4, [r3]
 80a2468:	2a00      	cmp	r2, #0
 80a246a:	d1f9      	bne.n	80a2460 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x60>
 80a246c:	f3bf 8f5b 	dmb	ish
        if (callbackPtr) {
 80a2470:	2e00      	cmp	r6, #0
 80a2472:	d0de      	beq.n	80a2432 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
        return (application_thread_current(nullptr) != 0);
 80a2474:	4620      	mov	r0, r4
 80a2476:	f7ff fa09 	bl	80a188c <application_thread_current>
        if (ContextT::isApplicationThreadCurrent()) {
 80a247a:	4607      	mov	r7, r0
 80a247c:	b160      	cbz	r0, 80a2498 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x98>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
 80a247e:	4630      	mov	r0, r6
 80a2480:	f105 010c 	add.w	r1, r5, #12
 80a2484:	f7ff fe15 	bl	80a20b2 <_ZNKSt8functionIFvRKbEEclES1_>
    class function<_Res(_ArgTypes...)>
 80a2488:	4630      	mov	r0, r6
 80a248a:	f7ff fca6 	bl	80a1dda <_ZNSt14_Function_baseD1Ev>
            delete callbackPtr;
 80a248e:	2110      	movs	r1, #16
 80a2490:	4630      	mov	r0, r6
 80a2492:	f000 fbcd 	bl	80a2c30 <_ZdlPvj>
 80a2496:	e7cc      	b.n	80a2432 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 80a2498:	4631      	mov	r1, r6
 80a249a:	a803      	add	r0, sp, #12
 80a249c:	f7ff ff7c 	bl	80a2398 <_ZNSt8functionIFvRKbEEC1ERKS3_>
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 80a24a0:	7b2b      	ldrb	r3, [r5, #12]
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
 80a24a2:	2010      	movs	r0, #16
 80a24a4:	f88d 301c 	strb.w	r3, [sp, #28]
 80a24a8:	f7fd fdf5 	bl	80a0096 <_Znwj>
 80a24ac:	4605      	mov	r5, r0
 80a24ae:	b1d0      	cbz	r0, 80a24e6 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xe6>
    _Function_base() : _M_manager(nullptr) { }
 80a24b0:	6087      	str	r7, [r0, #8]
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a24b2:	2014      	movs	r0, #20
 80a24b4:	f7fd fdef 	bl	80a0096 <_Znwj>
 80a24b8:	4604      	mov	r4, r0
 80a24ba:	b178      	cbz	r0, 80a24dc <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xdc>
	std::swap(_M_functor, __x._M_functor);
 80a24bc:	4601      	mov	r1, r0
    _Function_base() : _M_manager(nullptr) { }
 80a24be:	6087      	str	r7, [r0, #8]
	std::swap(_M_functor, __x._M_functor);
 80a24c0:	a803      	add	r0, sp, #12
 80a24c2:	f7ff fc93 	bl	80a1dec <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a24c6:	9b05      	ldr	r3, [sp, #20]
      __a = _GLIBCXX_MOVE(__b);
 80a24c8:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a24ca:	60a3      	str	r3, [r4, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a24cc:	9b06      	ldr	r3, [sp, #24]
      __a = _GLIBCXX_MOVE(__b);
 80a24ce:	9205      	str	r2, [sp, #20]
 80a24d0:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a24d2:	60e3      	str	r3, [r4, #12]
 80a24d4:	f89d 301c 	ldrb.w	r3, [sp, #28]
      __a = _GLIBCXX_MOVE(__b);
 80a24d8:	9206      	str	r2, [sp, #24]
 80a24da:	7423      	strb	r3, [r4, #16]
	    _M_invoker = &_My_handler::_M_invoke;
 80a24dc:	4b06      	ldr	r3, [pc, #24]	; (80a24f8 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xf8>)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a24de:	602c      	str	r4, [r5, #0]
	    _M_invoker = &_My_handler::_M_invoke;
 80a24e0:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a24e2:	4b06      	ldr	r3, [pc, #24]	; (80a24fc <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xfc>)
 80a24e4:	60ab      	str	r3, [r5, #8]
    class function<_Res(_ArgTypes...)>
 80a24e6:	a803      	add	r0, sp, #12
 80a24e8:	f7ff fc77 	bl	80a1dda <_ZNSt14_Function_baseD1Ev>
        return (application_thread_invoke(callback, data, nullptr) == 0);
 80a24ec:	2200      	movs	r2, #0
 80a24ee:	4629      	mov	r1, r5
 80a24f0:	4803      	ldr	r0, [pc, #12]	; (80a2500 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x100>)
 80a24f2:	f7ff f9d3 	bl	80a189c <application_thread_invoke>
 80a24f6:	e7c7      	b.n	80a2488 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x88>
 80a24f8:	080a20c5 	.word	0x080a20c5
 80a24fc:	080a23b7 	.word	0x080a23b7
 80a2500:	080a284d 	.word	0x080a284d

080a2504 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a2504:	4770      	bx	lr

080a2506 <_ZN9IPAddressD0Ev>:
 80a2506:	b510      	push	{r4, lr}
 80a2508:	4604      	mov	r4, r0
 80a250a:	2118      	movs	r1, #24
 80a250c:	f000 fb90 	bl	80a2c30 <_ZdlPvj>
 80a2510:	4620      	mov	r0, r4
 80a2512:	bd10      	pop	{r4, pc}

080a2514 <_ZNK9IPAddress7printToER5Print>:
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a2514:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2516:	460e      	mov	r6, r1
 80a2518:	2400      	movs	r4, #0
 80a251a:	f100 0708 	add.w	r7, r0, #8
 80a251e:	1d05      	adds	r5, r0, #4
            val = n;
        }
#if __GNUC__ >= 9
#pragma GCC diagnostic pop
#endif // __GNUC__ >= 9
        return printNumber(val, base) + t;
 80a2520:	f817 1d01 	ldrb.w	r1, [r7, #-1]!
 80a2524:	220a      	movs	r2, #10
 80a2526:	4630      	mov	r0, r6
 80a2528:	f7ff fc18 	bl	80a1d5c <_ZN5Print11printNumberEmh>
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a252c:	42af      	cmp	r7, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a252e:	4404      	add	r4, r0
    for (int i = 0; i < 4; i++)
 80a2530:	d101      	bne.n	80a2536 <_ZNK9IPAddress7printToER5Print+0x22>
    }
    return n;
}
 80a2532:	4620      	mov	r0, r4
 80a2534:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (n)
 80a2536:	2c00      	cmp	r4, #0
 80a2538:	d0f2      	beq.n	80a2520 <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a253a:	212e      	movs	r1, #46	; 0x2e
 80a253c:	4630      	mov	r0, r6
 80a253e:	f7ff fbf4 	bl	80a1d2a <_ZN5Print5printEc>
 80a2542:	4404      	add	r4, r0
 80a2544:	e7ec      	b.n	80a2520 <_ZNK9IPAddress7printToER5Print+0xc>
	...

080a2548 <_ZN9IPAddressC1Ev>:
IPAddress::IPAddress()
 80a2548:	b510      	push	{r4, lr}
 80a254a:	4604      	mov	r4, r0
 80a254c:	4b04      	ldr	r3, [pc, #16]	; (80a2560 <_ZN9IPAddressC1Ev+0x18>)
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a254e:	2211      	movs	r2, #17
 80a2550:	2100      	movs	r1, #0
 80a2552:	f840 3b04 	str.w	r3, [r0], #4
 80a2556:	f000 fb8a 	bl	80a2c6e <memset>
}
 80a255a:	4620      	mov	r0, r4
 80a255c:	bd10      	pop	{r4, pc}
 80a255e:	bf00      	nop
 80a2560:	080a3010 	.word	0x080a3010

080a2564 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>:
IPAddress::IPAddress(const HAL_IPAddress& address)
 80a2564:	4603      	mov	r3, r0
 80a2566:	4a07      	ldr	r2, [pc, #28]	; (80a2584 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0x20>)
 80a2568:	b510      	push	{r4, lr}
 80a256a:	f843 2b04 	str.w	r2, [r3], #4
    memcpy(&this->address, &address, sizeof(address));
 80a256e:	f101 0210 	add.w	r2, r1, #16
 80a2572:	f851 4b04 	ldr.w	r4, [r1], #4
 80a2576:	4291      	cmp	r1, r2
 80a2578:	f843 4b04 	str.w	r4, [r3], #4
 80a257c:	d1f9      	bne.n	80a2572 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0xe>
 80a257e:	780a      	ldrb	r2, [r1, #0]
 80a2580:	701a      	strb	r2, [r3, #0]
}
 80a2582:	bd10      	pop	{r4, pc}
 80a2584:	080a3010 	.word	0x080a3010

080a2588 <_ZN9IPAddressC1Em>:
IPAddress::IPAddress(uint32_t address)
 80a2588:	4a02      	ldr	r2, [pc, #8]	; (80a2594 <_ZN9IPAddressC1Em+0xc>)
    address.ipv4 = ipv4;
 80a258a:	e9c0 2100 	strd	r2, r1, [r0]
        address.v = version;
 80a258e:	2204      	movs	r2, #4
 80a2590:	7502      	strb	r2, [r0, #20]
}
 80a2592:	4770      	bx	lr
 80a2594:	080a3010 	.word	0x080a3010

080a2598 <_ZN9IPAddress8set_ipv4Ehhhh>:
{
 80a2598:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a259a:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a259e:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 80a25a2:	2304      	movs	r3, #4
 80a25a4:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80a25a8:	ea44 6401 	orr.w	r4, r4, r1, lsl #24
 80a25ac:	6044      	str	r4, [r0, #4]
 80a25ae:	7503      	strb	r3, [r0, #20]
}
 80a25b0:	bd10      	pop	{r4, pc}
	...

080a25b4 <_ZN9IPAddressC1Ehhhh>:
IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a25b4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a25b6:	4d04      	ldr	r5, [pc, #16]	; (80a25c8 <_ZN9IPAddressC1Ehhhh+0x14>)
 80a25b8:	6005      	str	r5, [r0, #0]
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a25ba:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a25be:	9500      	str	r5, [sp, #0]
 80a25c0:	f7ff ffea 	bl	80a2598 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a25c4:	b003      	add	sp, #12
 80a25c6:	bd30      	pop	{r4, r5, pc}
 80a25c8:	080a3010 	.word	0x080a3010

080a25cc <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a25cc:	7441      	strb	r1, [r0, #17]
}
 80a25ce:	4770      	bx	lr

080a25d0 <__tcf_0>:
}

USBSerial& _fetch_usbserial()
{
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a25d0:	4770      	bx	lr

080a25d2 <_ZN9USBSerialD1Ev>:
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"
#include "concurrent_hal.h"

class USBSerial : public Stream
 80a25d2:	4770      	bx	lr

080a25d4 <_ZN9USBSerial4readEv>:
{
 80a25d4:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
 80a25d6:	2100      	movs	r1, #0
 80a25d8:	7c00      	ldrb	r0, [r0, #16]
 80a25da:	f7ff f927 	bl	80a182c <HAL_USB_USART_Receive_Data>
}
 80a25de:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a25e2:	bd08      	pop	{r3, pc}

080a25e4 <_ZN9USBSerial4peekEv>:
{
 80a25e4:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, true));
 80a25e6:	2101      	movs	r1, #1
 80a25e8:	7c00      	ldrb	r0, [r0, #16]
 80a25ea:	f7ff f91f 	bl	80a182c <HAL_USB_USART_Receive_Data>
}
 80a25ee:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a25f2:	bd08      	pop	{r3, pc}

080a25f4 <_ZN9USBSerial17availableForWriteEv>:
{
 80a25f4:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USB_USART_Available_Data_For_Write(_serial));
 80a25f6:	7c00      	ldrb	r0, [r0, #16]
 80a25f8:	f7ff f910 	bl	80a181c <HAL_USB_USART_Available_Data_For_Write>
}
 80a25fc:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a2600:	bd08      	pop	{r3, pc}

080a2602 <_ZN9USBSerial9availableEv>:
{
 80a2602:	b508      	push	{r3, lr}
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
 80a2604:	7c00      	ldrb	r0, [r0, #16]
 80a2606:	f7ff f901 	bl	80a180c <HAL_USB_USART_Available_Data>
}
 80a260a:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a260e:	bd08      	pop	{r3, pc}

080a2610 <_ZN9USBSerial5writeEh>:
{
 80a2610:	b538      	push	{r3, r4, r5, lr}
 80a2612:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a2614:	7c00      	ldrb	r0, [r0, #16]
{
 80a2616:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a2618:	f7ff f900 	bl	80a181c <HAL_USB_USART_Available_Data_For_Write>
 80a261c:	2800      	cmp	r0, #0
 80a261e:	dc01      	bgt.n	80a2624 <_ZN9USBSerial5writeEh+0x14>
 80a2620:	7c60      	ldrb	r0, [r4, #17]
 80a2622:	b128      	cbz	r0, 80a2630 <_ZN9USBSerial5writeEh+0x20>
    return std::max(0, (int)HAL_USB_USART_Send_Data(_serial, byte));
 80a2624:	4629      	mov	r1, r5
 80a2626:	7c20      	ldrb	r0, [r4, #16]
 80a2628:	f7ff f908 	bl	80a183c <HAL_USB_USART_Send_Data>
 80a262c:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
}
 80a2630:	bd38      	pop	{r3, r4, r5, pc}

080a2632 <_ZN9USBSerial5flushEv>:
  HAL_USB_USART_Flush_Data(_serial);
 80a2632:	7c00      	ldrb	r0, [r0, #16]
 80a2634:	f7ff b90a 	b.w	80a184c <HAL_USB_USART_Flush_Data>

080a2638 <_ZN9USBSerialD0Ev>:
 80a2638:	b510      	push	{r4, lr}
 80a263a:	4604      	mov	r4, r0
 80a263c:	2114      	movs	r1, #20
 80a263e:	f000 faf7 	bl	80a2c30 <_ZdlPvj>
 80a2642:	4620      	mov	r0, r4
 80a2644:	bd10      	pop	{r4, pc}

080a2646 <__tcf_1>:
 80a2646:	4770      	bx	lr

080a2648 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:
USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a2648:	b510      	push	{r4, lr}
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a264a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a264e:	4604      	mov	r4, r0
 80a2650:	4608      	mov	r0, r1
 80a2652:	2100      	movs	r1, #0
 80a2654:	e9c4 1301 	strd	r1, r3, [r4, #4]
 80a2658:	4b04      	ldr	r3, [pc, #16]	; (80a266c <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
  _serial = serial;
 80a265a:	7420      	strb	r0, [r4, #16]
USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a265c:	6023      	str	r3, [r4, #0]
  _blocking = true;
 80a265e:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
 80a2660:	4611      	mov	r1, r2
  _blocking = true;
 80a2662:	7463      	strb	r3, [r4, #17]
  HAL_USB_USART_Init(_serial, &conf);
 80a2664:	f7ff f8c2 	bl	80a17ec <HAL_USB_USART_Init>
}
 80a2668:	4620      	mov	r0, r4
 80a266a:	bd10      	pop	{r4, pc}
 80a266c:	080a3024 	.word	0x080a3024

080a2670 <_ZN9USBSerial5beginEl>:
    HAL_USB_USART_Begin(_serial, speed, NULL);
 80a2670:	2200      	movs	r2, #0
 80a2672:	7c00      	ldrb	r0, [r0, #16]
 80a2674:	f7ff b8c2 	b.w	80a17fc <HAL_USB_USART_Begin>

080a2678 <_Z19acquireSerialBufferv>:
{
 80a2678:	b510      	push	{r4, lr}
 80a267a:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a267c:	2214      	movs	r2, #20
 80a267e:	2100      	movs	r1, #0
 80a2680:	f000 faf5 	bl	80a2c6e <memset>
  conf.rx_buffer = serial_rx_buffer;
 80a2684:	4b05      	ldr	r3, [pc, #20]	; (80a269c <_Z19acquireSerialBufferv+0x24>)
}
 80a2686:	4620      	mov	r0, r4
  conf.rx_buffer = serial_rx_buffer;
 80a2688:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a268a:	4b05      	ldr	r3, [pc, #20]	; (80a26a0 <_Z19acquireSerialBufferv+0x28>)
 80a268c:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a268e:	f240 1301 	movw	r3, #257	; 0x101
 80a2692:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a2694:	2381      	movs	r3, #129	; 0x81
 80a2696:	8223      	strh	r3, [r4, #16]
}
 80a2698:	bd10      	pop	{r4, pc}
 80a269a:	bf00      	nop
 80a269c:	20000134 	.word	0x20000134
 80a26a0:	20000235 	.word	0x20000235

080a26a4 <_Z16_fetch_usbserialv>:
{
 80a26a4:	b530      	push	{r4, r5, lr}
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a26a6:	4d0e      	ldr	r5, [pc, #56]	; (80a26e0 <_Z16_fetch_usbserialv+0x3c>)
{
 80a26a8:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a26aa:	a801      	add	r0, sp, #4
 80a26ac:	f7ff ffe4 	bl	80a2678 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a26b0:	7829      	ldrb	r1, [r5, #0]
 80a26b2:	f3bf 8f5b 	dmb	ish
 80a26b6:	f011 0401 	ands.w	r4, r1, #1
 80a26ba:	d10e      	bne.n	80a26da <_Z16_fetch_usbserialv+0x36>
 80a26bc:	4628      	mov	r0, r5
 80a26be:	f7fd fcf0 	bl	80a00a2 <__cxa_guard_acquire>
 80a26c2:	b150      	cbz	r0, 80a26da <_Z16_fetch_usbserialv+0x36>
 80a26c4:	4621      	mov	r1, r4
 80a26c6:	aa01      	add	r2, sp, #4
 80a26c8:	4806      	ldr	r0, [pc, #24]	; (80a26e4 <_Z16_fetch_usbserialv+0x40>)
 80a26ca:	f7ff ffbd 	bl	80a2648 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a26ce:	4628      	mov	r0, r5
 80a26d0:	f7fd fcec 	bl	80a00ac <__cxa_guard_release>
 80a26d4:	4804      	ldr	r0, [pc, #16]	; (80a26e8 <_Z16_fetch_usbserialv+0x44>)
 80a26d6:	f000 fab2 	bl	80a2c3e <atexit>
	return _usbserial;
}
 80a26da:	4802      	ldr	r0, [pc, #8]	; (80a26e4 <_Z16_fetch_usbserialv+0x40>)
 80a26dc:	b007      	add	sp, #28
 80a26de:	bd30      	pop	{r4, r5, pc}
 80a26e0:	20000104 	.word	0x20000104
 80a26e4:	2000010c 	.word	0x2000010c
 80a26e8:	080a25d1 	.word	0x080a25d1

080a26ec <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a26ec:	b510      	push	{r4, lr}
 80a26ee:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a26f0:	2214      	movs	r2, #20
 80a26f2:	2100      	movs	r1, #0
 80a26f4:	f000 fabb 	bl	80a2c6e <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a26f8:	4b05      	ldr	r3, [pc, #20]	; (80a2710 <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a26fa:	4620      	mov	r0, r4
  conf.rx_buffer = usbserial1_rx_buffer;
 80a26fc:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a26fe:	4b05      	ldr	r3, [pc, #20]	; (80a2714 <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a2700:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a2702:	f240 1301 	movw	r3, #257	; 0x101
 80a2706:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a2708:	2381      	movs	r3, #129	; 0x81
 80a270a:	8223      	strh	r3, [r4, #16]
}
 80a270c:	bd10      	pop	{r4, pc}
 80a270e:	bf00      	nop
 80a2710:	200002b6 	.word	0x200002b6
 80a2714:	200003b7 	.word	0x200003b7

080a2718 <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a2718:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a271a:	4c0e      	ldr	r4, [pc, #56]	; (80a2754 <_Z17_fetch_usbserial1v+0x3c>)
{
 80a271c:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a271e:	a801      	add	r0, sp, #4
 80a2720:	f7ff ffe4 	bl	80a26ec <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a2724:	7823      	ldrb	r3, [r4, #0]
 80a2726:	f3bf 8f5b 	dmb	ish
 80a272a:	07db      	lsls	r3, r3, #31
 80a272c:	d40e      	bmi.n	80a274c <_Z17_fetch_usbserial1v+0x34>
 80a272e:	4620      	mov	r0, r4
 80a2730:	f7fd fcb7 	bl	80a00a2 <__cxa_guard_acquire>
 80a2734:	b150      	cbz	r0, 80a274c <_Z17_fetch_usbserial1v+0x34>
 80a2736:	2101      	movs	r1, #1
 80a2738:	aa01      	add	r2, sp, #4
 80a273a:	4807      	ldr	r0, [pc, #28]	; (80a2758 <_Z17_fetch_usbserial1v+0x40>)
 80a273c:	f7ff ff84 	bl	80a2648 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a2740:	4620      	mov	r0, r4
 80a2742:	f7fd fcb3 	bl	80a00ac <__cxa_guard_release>
 80a2746:	4805      	ldr	r0, [pc, #20]	; (80a275c <_Z17_fetch_usbserial1v+0x44>)
 80a2748:	f000 fa79 	bl	80a2c3e <atexit>
  return _usbserial1;
}
 80a274c:	4802      	ldr	r0, [pc, #8]	; (80a2758 <_Z17_fetch_usbserial1v+0x40>)
 80a274e:	b006      	add	sp, #24
 80a2750:	bd10      	pop	{r4, pc}
 80a2752:	bf00      	nop
 80a2754:	20000108 	.word	0x20000108
 80a2758:	20000120 	.word	0x20000120
 80a275c:	080a2647 	.word	0x080a2647

080a2760 <_ZN11USARTSerialD1Ev>:
private:
  hal_usart_interface_t _serial;
  bool _blocking;
public:
  USARTSerial(hal_usart_interface_t serial, hal_usart_ring_buffer_t *rx_buffer, hal_usart_ring_buffer_t *tx_buffer);
  virtual ~USARTSerial() {};
 80a2760:	4770      	bx	lr

080a2762 <_ZN11USARTSerial14blockOnOverrunEb>:
    hal_usart_half_duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a2762:	7441      	strb	r1, [r0, #17]
}
 80a2764:	4770      	bx	lr

080a2766 <__tcf_0>:
#endif

USARTSerial& __fetch_global_Serial1()
{
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a2766:	4770      	bx	lr

080a2768 <_ZN11USARTSerial17availableForWriteEv>:
{
 80a2768:	b508      	push	{r3, lr}
  return std::max(0, (int)hal_usart_available_data_for_write(_serial));
 80a276a:	7c00      	ldrb	r0, [r0, #16]
 80a276c:	f7fe ffec 	bl	80a1748 <hal_usart_available_data_for_write>
}
 80a2770:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a2774:	bd08      	pop	{r3, pc}

080a2776 <_ZN11USARTSerial9availableEv>:
{
 80a2776:	b508      	push	{r3, lr}
  return std::max(0, (int)hal_usart_available(_serial));
 80a2778:	7c00      	ldrb	r0, [r0, #16]
 80a277a:	f7fe ffbd 	bl	80a16f8 <hal_usart_available>
}
 80a277e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a2782:	bd08      	pop	{r3, pc}

080a2784 <_ZN11USARTSerial4peekEv>:
{
 80a2784:	b508      	push	{r3, lr}
  return std::max(-1, (int)hal_usart_peek(_serial));
 80a2786:	7c00      	ldrb	r0, [r0, #16]
 80a2788:	f7fe ffc6 	bl	80a1718 <hal_usart_peek>
}
 80a278c:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a2790:	bd08      	pop	{r3, pc}

080a2792 <_ZN11USARTSerial4readEv>:
{
 80a2792:	b508      	push	{r3, lr}
  return std::max(-1, (int)hal_usart_read(_serial));
 80a2794:	7c00      	ldrb	r0, [r0, #16]
 80a2796:	f7fe ffb7 	bl	80a1708 <hal_usart_read>
}
 80a279a:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a279e:	bd08      	pop	{r3, pc}

080a27a0 <_ZN11USARTSerial5flushEv>:
  hal_usart_flush(_serial);
 80a27a0:	7c00      	ldrb	r0, [r0, #16]
 80a27a2:	f7fe bfc1 	b.w	80a1728 <hal_usart_flush>

080a27a6 <_ZN11USARTSerial5writeEh>:
{
 80a27a6:	b570      	push	{r4, r5, r6, lr}
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
 80a27a8:	7c46      	ldrb	r6, [r0, #17]
{
 80a27aa:	4604      	mov	r4, r0
 80a27ac:	460d      	mov	r5, r1
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
 80a27ae:	b12e      	cbz	r6, 80a27bc <_ZN11USARTSerial5writeEh+0x16>
	  return hal_usart_write(_serial, c);
 80a27b0:	4629      	mov	r1, r5
 80a27b2:	7c20      	ldrb	r0, [r4, #16]
}
 80a27b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	  return hal_usart_write(_serial, c);
 80a27b8:	f7fe bf96 	b.w	80a16e8 <hal_usart_write>
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
 80a27bc:	7c00      	ldrb	r0, [r0, #16]
 80a27be:	f7fe ffc3 	bl	80a1748 <hal_usart_available_data_for_write>
 80a27c2:	2800      	cmp	r0, #0
 80a27c4:	dcf4      	bgt.n	80a27b0 <_ZN11USARTSerial5writeEh+0xa>
}
 80a27c6:	4630      	mov	r0, r6
 80a27c8:	bd70      	pop	{r4, r5, r6, pc}

080a27ca <_ZN11USARTSerialD0Ev>:
 80a27ca:	b510      	push	{r4, lr}
 80a27cc:	4604      	mov	r4, r0
 80a27ce:	2114      	movs	r1, #20
 80a27d0:	f000 fa2e 	bl	80a2c30 <_ZdlPvj>
 80a27d4:	4620      	mov	r0, r4
 80a27d6:	bd10      	pop	{r4, pc}

080a27d8 <_ZN11USARTSerialC1E21hal_usart_interface_tP23hal_usart_ring_buffer_tS2_>:
 80a27d8:	f04f 0c00 	mov.w	ip, #0
USARTSerial::USARTSerial(hal_usart_interface_t serial, hal_usart_ring_buffer_t *rx_buffer, hal_usart_ring_buffer_t *tx_buffer)
 80a27dc:	b510      	push	{r4, lr}
 80a27de:	4604      	mov	r4, r0
 80a27e0:	4608      	mov	r0, r1
 80a27e2:	4611      	mov	r1, r2
 80a27e4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a27e8:	e9c4 c201 	strd	ip, r2, [r4, #4]
 80a27ec:	4a04      	ldr	r2, [pc, #16]	; (80a2800 <_ZN11USARTSerialC1E21hal_usart_interface_tP23hal_usart_ring_buffer_tS2_+0x28>)
  _serial = serial;
 80a27ee:	7420      	strb	r0, [r4, #16]
USARTSerial::USARTSerial(hal_usart_interface_t serial, hal_usart_ring_buffer_t *rx_buffer, hal_usart_ring_buffer_t *tx_buffer)
 80a27f0:	6022      	str	r2, [r4, #0]
  _blocking = true;
 80a27f2:	2201      	movs	r2, #1
 80a27f4:	7462      	strb	r2, [r4, #17]
  hal_usart_init(serial, rx_buffer, tx_buffer);
 80a27f6:	461a      	mov	r2, r3
 80a27f8:	f7fe ff6e 	bl	80a16d8 <hal_usart_init>
}
 80a27fc:	4620      	mov	r0, r4
 80a27fe:	bd10      	pop	{r4, pc}
 80a2800:	080a3054 	.word	0x080a3054

080a2804 <_Z22__fetch_global_Serial1v>:
{
 80a2804:	b538      	push	{r3, r4, r5, lr}
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a2806:	4d0c      	ldr	r5, [pc, #48]	; (80a2838 <_Z22__fetch_global_Serial1v+0x34>)
 80a2808:	7829      	ldrb	r1, [r5, #0]
 80a280a:	f3bf 8f5b 	dmb	ish
 80a280e:	f011 0401 	ands.w	r4, r1, #1
 80a2812:	d10f      	bne.n	80a2834 <_Z22__fetch_global_Serial1v+0x30>
 80a2814:	4628      	mov	r0, r5
 80a2816:	f7fd fc44 	bl	80a00a2 <__cxa_guard_acquire>
 80a281a:	b158      	cbz	r0, 80a2834 <_Z22__fetch_global_Serial1v+0x30>
 80a281c:	4621      	mov	r1, r4
 80a281e:	4b07      	ldr	r3, [pc, #28]	; (80a283c <_Z22__fetch_global_Serial1v+0x38>)
 80a2820:	4a07      	ldr	r2, [pc, #28]	; (80a2840 <_Z22__fetch_global_Serial1v+0x3c>)
 80a2822:	4808      	ldr	r0, [pc, #32]	; (80a2844 <_Z22__fetch_global_Serial1v+0x40>)
 80a2824:	f7ff ffd8 	bl	80a27d8 <_ZN11USARTSerialC1E21hal_usart_interface_tP23hal_usart_ring_buffer_tS2_>
 80a2828:	4628      	mov	r0, r5
 80a282a:	f7fd fc3f 	bl	80a00ac <__cxa_guard_release>
 80a282e:	4806      	ldr	r0, [pc, #24]	; (80a2848 <_Z22__fetch_global_Serial1v+0x44>)
 80a2830:	f000 fa05 	bl	80a2c3e <atexit>
    serial1_tx_buffer = new hal_usart_ring_buffer_t();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
#endif
	return serial1;
}
 80a2834:	4803      	ldr	r0, [pc, #12]	; (80a2844 <_Z22__fetch_global_Serial1v+0x40>)
 80a2836:	bd38      	pop	{r3, r4, r5, pc}
 80a2838:	20000438 	.word	0x20000438
 80a283c:	200004c0 	.word	0x200004c0
 80a2840:	2000043c 	.word	0x2000043c
 80a2844:	20000544 	.word	0x20000544
 80a2848:	080a2767 	.word	0x080a2767

080a284c <_ZN8particle6detail21futureCallbackWrapperEPv>:
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#include "spark_wiring_async.h"

void particle::detail::futureCallbackWrapper(void* data) {
 80a284c:	b510      	push	{r4, lr}
      if (_M_empty())
 80a284e:	6883      	ldr	r3, [r0, #8]
 80a2850:	4604      	mov	r4, r0
 80a2852:	b90b      	cbnz	r3, 80a2858 <_ZN8particle6detail21futureCallbackWrapperEPv+0xc>
	__throw_bad_function_call();
 80a2854:	f000 f9f0 	bl	80a2c38 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a2858:	68c3      	ldr	r3, [r0, #12]
 80a285a:	4798      	blx	r3
      if (_M_manager)
 80a285c:	68a3      	ldr	r3, [r4, #8]
 80a285e:	b11b      	cbz	r3, 80a2868 <_ZN8particle6detail21futureCallbackWrapperEPv+0x1c>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a2860:	2203      	movs	r2, #3
 80a2862:	4621      	mov	r1, r4
 80a2864:	4620      	mov	r0, r4
 80a2866:	4798      	blx	r3
    auto callbackPtr = static_cast<const std::function<void()>*>(data);
    (*callbackPtr)();
    delete callbackPtr;
 80a2868:	4620      	mov	r0, r4
}
 80a286a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    delete callbackPtr;
 80a286e:	2110      	movs	r1, #16
 80a2870:	f000 b9de 	b.w	80a2c30 <_ZdlPvj>

080a2874 <_ZN7TwoWireD1Ev>:
private:
  hal_i2c_interface_t _i2c;

public:
  TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& config);
  virtual ~TwoWire() {};
 80a2874:	4770      	bx	lr

080a2876 <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a2876:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2878:	4606      	mov	r6, r0
 80a287a:	4615      	mov	r5, r2
 80a287c:	460c      	mov	r4, r1
 80a287e:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a2880:	42bc      	cmp	r4, r7
 80a2882:	d006      	beq.n	80a2892 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a2884:	6833      	ldr	r3, [r6, #0]
 80a2886:	4630      	mov	r0, r6
 80a2888:	689b      	ldr	r3, [r3, #8]
 80a288a:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a288e:	4798      	blx	r3
  for(size_t i = 0; i < quantity; ++i)
 80a2890:	e7f6      	b.n	80a2880 <_ZN7TwoWire5writeEPKhj+0xa>
  }

  return quantity;
}
 80a2892:	4628      	mov	r0, r5
 80a2894:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a2896 <_ZN7TwoWire5writeEh>:
  return hal_i2c_write(_i2c, data, NULL);
 80a2896:	2200      	movs	r2, #0
 80a2898:	7c00      	ldrb	r0, [r0, #16]
 80a289a:	f7fe bf5d 	b.w	80a1758 <hal_i2c_write>

080a289e <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return hal_i2c_available(_i2c, NULL);
 80a289e:	2100      	movs	r1, #0
 80a28a0:	7c00      	ldrb	r0, [r0, #16]
 80a28a2:	f7fe bf61 	b.w	80a1768 <hal_i2c_available>

080a28a6 <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return hal_i2c_read(_i2c, NULL);
 80a28a6:	2100      	movs	r1, #0
 80a28a8:	7c00      	ldrb	r0, [r0, #16]
 80a28aa:	f7fe bf65 	b.w	80a1778 <hal_i2c_read>

080a28ae <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return hal_i2c_peek(_i2c, NULL);
 80a28ae:	2100      	movs	r1, #0
 80a28b0:	7c00      	ldrb	r0, [r0, #16]
 80a28b2:	f7fe bf69 	b.w	80a1788 <hal_i2c_peek>

080a28b6 <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  hal_i2c_flush(_i2c, NULL);
 80a28b6:	2100      	movs	r1, #0
 80a28b8:	7c00      	ldrb	r0, [r0, #16]
 80a28ba:	f7fe bf6d 	b.w	80a1798 <hal_i2c_flush>

080a28be <_ZN7TwoWireD0Ev>:
 80a28be:	b510      	push	{r4, lr}
 80a28c0:	4604      	mov	r4, r0
 80a28c2:	2114      	movs	r1, #20
 80a28c4:	f000 f9b4 	bl	80a2c30 <_ZdlPvj>
 80a28c8:	4620      	mov	r0, r4
 80a28ca:	bd10      	pop	{r4, pc}

080a28cc <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t>:
TwoWire::TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& conf)
 80a28cc:	b510      	push	{r4, lr}
 80a28ce:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a28d2:	4604      	mov	r4, r0
 80a28d4:	4608      	mov	r0, r1
 80a28d6:	2100      	movs	r1, #0
 80a28d8:	e9c4 1301 	strd	r1, r3, [r4, #4]
 80a28dc:	4b03      	ldr	r3, [pc, #12]	; (80a28ec <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t+0x20>)
  hal_i2c_init(_i2c, &conf);
 80a28de:	4611      	mov	r1, r2
TwoWire::TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& conf)
 80a28e0:	6023      	str	r3, [r4, #0]
  _i2c = i2c;
 80a28e2:	7420      	strb	r0, [r4, #16]
  hal_i2c_init(_i2c, &conf);
 80a28e4:	f7fe ff68 	bl	80a17b8 <hal_i2c_init>
}
 80a28e8:	4620      	mov	r0, r4
 80a28ea:	bd10      	pop	{r4, pc}
 80a28ec:	080a3084 	.word	0x080a3084

080a28f0 <_ZN5spark9WiFiClass5readyEv>:
        return network_ready(*this, 0, NULL);
 80a28f0:	2200      	movs	r2, #0
 80a28f2:	6840      	ldr	r0, [r0, #4]
 80a28f4:	4611      	mov	r1, r2
 80a28f6:	f7ff b805 	b.w	80a1904 <network_ready>

080a28fa <_ZN5spark9WiFiClass7resolveEPKc>:
    WLanSelectAntenna_TypeDef getAntenna() {
        return wlan_get_antenna(nullptr);
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
 80a28fa:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a28fc:	4615      	mov	r5, r2
 80a28fe:	b089      	sub	sp, #36	; 0x24
    {
        HAL_IPAddress ip = {};
 80a2900:	2211      	movs	r2, #17
    IPAddress resolve(const char* name)
 80a2902:	460e      	mov	r6, r1
 80a2904:	4604      	mov	r4, r0
        HAL_IPAddress ip = {};
 80a2906:	2100      	movs	r1, #0
 80a2908:	a803      	add	r0, sp, #12
 80a290a:	f000 f9b0 	bl	80a2c6e <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a290e:	4628      	mov	r0, r5
 80a2910:	f000 fa07 	bl	80a2d22 <strlen>
 80a2914:	2700      	movs	r7, #0
 80a2916:	b281      	uxth	r1, r0
 80a2918:	6873      	ldr	r3, [r6, #4]
 80a291a:	4628      	mov	r0, r5
 80a291c:	9700      	str	r7, [sp, #0]
 80a291e:	aa03      	add	r2, sp, #12
 80a2920:	f7fe ff9c 	bl	80a185c <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a2924:	b130      	cbz	r0, 80a2934 <_ZN5spark9WiFiClass7resolveEPKc+0x3a>
 80a2926:	4639      	mov	r1, r7
 80a2928:	4620      	mov	r0, r4
 80a292a:	f7ff fe2d 	bl	80a2588 <_ZN9IPAddressC1Em>
    }
 80a292e:	4620      	mov	r0, r4
 80a2930:	b009      	add	sp, #36	; 0x24
 80a2932:	bdf0      	pop	{r4, r5, r6, r7, pc}
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a2934:	4620      	mov	r0, r4
 80a2936:	a903      	add	r1, sp, #12
 80a2938:	f7ff fe14 	bl	80a2564 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
 80a293c:	e7f7      	b.n	80a292e <_ZN5spark9WiFiClass7resolveEPKc+0x34>

080a293e <_ZN5spark9WiFiClass9listeningEv>:
        return network_listening(*this, 0, NULL);
 80a293e:	2200      	movs	r2, #0
 80a2940:	6840      	ldr	r0, [r0, #4]
 80a2942:	4611      	mov	r1, r2
 80a2944:	f7fe bffe 	b.w	80a1944 <network_listening>

080a2948 <_ZN5spark9WiFiClass16getListenTimeoutEv>:
        return network_get_listen_timeout(*this, 0, NULL);
 80a2948:	2200      	movs	r2, #0
 80a294a:	6840      	ldr	r0, [r0, #4]
 80a294c:	4611      	mov	r1, r2
 80a294e:	f7ff b809 	b.w	80a1964 <network_get_listen_timeout>

080a2952 <_ZN5spark9WiFiClass16setListenTimeoutEt>:
        network_set_listen_timeout(*this, timeout, NULL);
 80a2952:	2200      	movs	r2, #0
 80a2954:	6840      	ldr	r0, [r0, #4]
 80a2956:	f7fe bffd 	b.w	80a1954 <network_set_listen_timeout>

080a295a <_ZN5spark9WiFiClass6listenEb>:
        network_listen(*this, begin ? 0 : 1, NULL);
 80a295a:	2200      	movs	r2, #0
 80a295c:	6840      	ldr	r0, [r0, #4]
 80a295e:	f081 0101 	eor.w	r1, r1, #1
 80a2962:	f7fe bfe7 	b.w	80a1934 <network_listen>

080a2966 <_ZN5spark9WiFiClass3offEv>:
        network_off(*this, 0, 0, NULL);
 80a2966:	2300      	movs	r3, #0
 80a2968:	6840      	ldr	r0, [r0, #4]
 80a296a:	461a      	mov	r2, r3
 80a296c:	4619      	mov	r1, r3
 80a296e:	f7fe bfd9 	b.w	80a1924 <network_off>

080a2972 <_ZN5spark9WiFiClass10connectingEv>:
        return network_connecting(*this, 0, NULL);
 80a2972:	2200      	movs	r2, #0
 80a2974:	6840      	ldr	r0, [r0, #4]
 80a2976:	4611      	mov	r1, r2
 80a2978:	f7fe bfb4 	b.w	80a18e4 <network_connecting>

080a297c <_ZN5spark9WiFiClass10disconnectEv>:
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
 80a297c:	2200      	movs	r2, #0
 80a297e:	2102      	movs	r1, #2
 80a2980:	6840      	ldr	r0, [r0, #4]
 80a2982:	f7fe bfb7 	b.w	80a18f4 <network_disconnect>

080a2986 <_ZN5spark9WiFiClass7connectEj>:
        network_connect(*this, flags, 0, NULL);
 80a2986:	2300      	movs	r3, #0
 80a2988:	6840      	ldr	r0, [r0, #4]
 80a298a:	461a      	mov	r2, r3
 80a298c:	f7fe bfa2 	b.w	80a18d4 <network_connect>

080a2990 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
    static NetworkClass& from(network_interface_t nif);

    virtual IPAddress resolve(const char* name);

    explicit NetworkClass(network_interface_t iface)
            : iface_(iface) {
 80a2990:	2204      	movs	r2, #4
 80a2992:	4b02      	ldr	r3, [pc, #8]	; (80a299c <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0xc>)
 80a2994:	605a      	str	r2, [r3, #4]
            NetworkClass(NETWORK_INTERFACE_WIFI_STA) {
 80a2996:	4a02      	ldr	r2, [pc, #8]	; (80a29a0 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a2998:	601a      	str	r2, [r3, #0]
the same way.
*****************************************************************************/

    WiFiClass WiFi;
    // NetworkClass& Network = WiFi;
}
 80a299a:	4770      	bx	lr
 80a299c:	20000558 	.word	0x20000558
 80a29a0:	080a30ac 	.word	0x080a30ac

080a29a4 <_ZN5spark12NetworkClass7connectEj>:
        return Network;
    }
}

void NetworkClass::connect(unsigned flags) {
    network_connect(*this, flags, 0, nullptr);
 80a29a4:	2300      	movs	r3, #0
 80a29a6:	6840      	ldr	r0, [r0, #4]
 80a29a8:	461a      	mov	r2, r3
 80a29aa:	f7fe bf93 	b.w	80a18d4 <network_connect>

080a29ae <_ZN5spark12NetworkClass10disconnectEv>:
}

void NetworkClass::disconnect() {
    network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, nullptr);
 80a29ae:	2200      	movs	r2, #0
 80a29b0:	2102      	movs	r1, #2
 80a29b2:	6840      	ldr	r0, [r0, #4]
 80a29b4:	f7fe bf9e 	b.w	80a18f4 <network_disconnect>

080a29b8 <_ZN5spark12NetworkClass10connectingEv>:
}

bool NetworkClass::connecting() {
    return network_connecting(*this, 0, nullptr);
 80a29b8:	2200      	movs	r2, #0
 80a29ba:	6840      	ldr	r0, [r0, #4]
 80a29bc:	4611      	mov	r1, r2
 80a29be:	f7fe bf91 	b.w	80a18e4 <network_connecting>

080a29c2 <_ZN5spark12NetworkClass5readyEv>:
}

bool NetworkClass::ready() {
    return network_ready(*this, 0, nullptr);
 80a29c2:	2200      	movs	r2, #0
 80a29c4:	6840      	ldr	r0, [r0, #4]
 80a29c6:	4611      	mov	r1, r2
 80a29c8:	f7fe bf9c 	b.w	80a1904 <network_ready>

080a29cc <_ZN5spark12NetworkClass2onEv>:
}

void NetworkClass::on() {
    network_on(*this, 0, 0, nullptr);
 80a29cc:	2300      	movs	r3, #0
 80a29ce:	6840      	ldr	r0, [r0, #4]
 80a29d0:	461a      	mov	r2, r3
 80a29d2:	4619      	mov	r1, r3
 80a29d4:	f7fe bf9e 	b.w	80a1914 <network_on>

080a29d8 <_ZN5spark12NetworkClass3offEv>:
}

void NetworkClass::off() {
    network_off(*this, 0, 0, nullptr);
 80a29d8:	2300      	movs	r3, #0
 80a29da:	6840      	ldr	r0, [r0, #4]
 80a29dc:	461a      	mov	r2, r3
 80a29de:	4619      	mov	r1, r3
 80a29e0:	f7fe bfa0 	b.w	80a1924 <network_off>

080a29e4 <_ZN5spark12NetworkClass4isOnEv>:
}

bool NetworkClass::isOn() {
    return network_is_on(*this, nullptr);
 80a29e4:	2100      	movs	r1, #0
 80a29e6:	6840      	ldr	r0, [r0, #4]
 80a29e8:	f7fe bfc4 	b.w	80a1974 <network_is_on>

080a29ec <_ZN5spark12NetworkClass5isOffEv>:
}

bool NetworkClass::isOff() {
    return network_is_off(*this, nullptr);
 80a29ec:	2100      	movs	r1, #0
 80a29ee:	6840      	ldr	r0, [r0, #4]
 80a29f0:	f7fe bfc8 	b.w	80a1984 <network_is_off>

080a29f4 <_ZN5spark12NetworkClass6listenEb>:
}

void NetworkClass::listen(bool begin) {
    network_listen(*this, begin ? 0 : 1, nullptr);
 80a29f4:	2200      	movs	r2, #0
 80a29f6:	6840      	ldr	r0, [r0, #4]
 80a29f8:	f081 0101 	eor.w	r1, r1, #1
 80a29fc:	f7fe bf9a 	b.w	80a1934 <network_listen>

080a2a00 <_ZN5spark12NetworkClass16setListenTimeoutEt>:
}

void NetworkClass::setListenTimeout(uint16_t timeout) {
    network_set_listen_timeout(*this, timeout, nullptr);
 80a2a00:	2200      	movs	r2, #0
 80a2a02:	6840      	ldr	r0, [r0, #4]
 80a2a04:	f7fe bfa6 	b.w	80a1954 <network_set_listen_timeout>

080a2a08 <_ZN5spark12NetworkClass16getListenTimeoutEv>:
}

uint16_t NetworkClass::getListenTimeout() {
    return network_get_listen_timeout(*this, 0, nullptr);
 80a2a08:	2200      	movs	r2, #0
 80a2a0a:	6840      	ldr	r0, [r0, #4]
 80a2a0c:	4611      	mov	r1, r2
 80a2a0e:	f7fe bfa9 	b.w	80a1964 <network_get_listen_timeout>

080a2a12 <_ZN5spark12NetworkClass9listeningEv>:
}

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
 80a2a12:	2200      	movs	r2, #0
 80a2a14:	6840      	ldr	r0, [r0, #4]
 80a2a16:	4611      	mov	r1, r2
 80a2a18:	f7fe bf94 	b.w	80a1944 <network_listening>

080a2a1c <_ZN5spark12NetworkClass7resolveEPKc>:
}

IPAddress NetworkClass::resolve(const char* name) {
 80a2a1c:	b570      	push	{r4, r5, r6, lr}
 80a2a1e:	4615      	mov	r5, r2
 80a2a20:	b08e      	sub	sp, #56	; 0x38
 80a2a22:	4604      	mov	r4, r0
    IPAddress addr;
 80a2a24:	a808      	add	r0, sp, #32
 80a2a26:	f7ff fd8f 	bl	80a2548 <_ZN9IPAddressC1Ev>
        HAL_IPAddress ip = {};
 80a2a2a:	2211      	movs	r2, #17
 80a2a2c:	2100      	movs	r1, #0
 80a2a2e:	a803      	add	r0, sp, #12
 80a2a30:	f000 f91d 	bl	80a2c6e <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a2a34:	2600      	movs	r6, #0
 80a2a36:	4628      	mov	r0, r5
 80a2a38:	f000 f973 	bl	80a2d22 <strlen>
 80a2a3c:	4b0a      	ldr	r3, [pc, #40]	; (80a2a68 <_ZN5spark12NetworkClass7resolveEPKc+0x4c>)
 80a2a3e:	9600      	str	r6, [sp, #0]
 80a2a40:	b281      	uxth	r1, r0
 80a2a42:	685b      	ldr	r3, [r3, #4]
 80a2a44:	4628      	mov	r0, r5
 80a2a46:	aa03      	add	r2, sp, #12
 80a2a48:	f7fe ff08 	bl	80a185c <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a2a4c:	b130      	cbz	r0, 80a2a5c <_ZN5spark12NetworkClass7resolveEPKc+0x40>
 80a2a4e:	4631      	mov	r1, r6
 80a2a50:	4620      	mov	r0, r4
 80a2a52:	f7ff fd99 	bl	80a2588 <_ZN9IPAddressC1Em>
    return Cellular.resolve(name);
#endif // Wiring_Cellular

#endif // HAL_USE_INET_HAL_POSIX
    return addr;
}
 80a2a56:	4620      	mov	r0, r4
 80a2a58:	b00e      	add	sp, #56	; 0x38
 80a2a5a:	bd70      	pop	{r4, r5, r6, pc}
 80a2a5c:	4620      	mov	r0, r4
 80a2a5e:	a903      	add	r1, sp, #12
 80a2a60:	f7ff fd80 	bl	80a2564 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
    virtual ~IPAddress() {}
 80a2a64:	e7f7      	b.n	80a2a56 <_ZN5spark12NetworkClass7resolveEPKc+0x3a>
 80a2a66:	bf00      	nop
 80a2a68:	20000558 	.word	0x20000558

080a2a6c <_GLOBAL__sub_I__ZN5spark7NetworkE>:
 80a2a6c:	4b02      	ldr	r3, [pc, #8]	; (80a2a78 <_GLOBAL__sub_I__ZN5spark7NetworkE+0xc>)
 80a2a6e:	4a03      	ldr	r2, [pc, #12]	; (80a2a7c <_GLOBAL__sub_I__ZN5spark7NetworkE+0x10>)
 80a2a70:	601a      	str	r2, [r3, #0]
 80a2a72:	2200      	movs	r2, #0
 80a2a74:	605a      	str	r2, [r3, #4]

} // spark
 80a2a76:	4770      	bx	lr
 80a2a78:	20000560 	.word	0x20000560
 80a2a7c:	080a30e8 	.word	0x080a30e8

080a2a80 <__tcf_0>:
        dispose();
    }

    void dispose()
    {
        if (handle_) {
 80a2a80:	4b02      	ldr	r3, [pc, #8]	; (80a2a8c <__tcf_0+0xc>)
 80a2a82:	6898      	ldr	r0, [r3, #8]
 80a2a84:	b108      	cbz	r0, 80a2a8a <__tcf_0+0xa>
            os_mutex_recursive_destroy(handle_);
 80a2a86:	f7fe be1f 	b.w	80a16c8 <os_mutex_recursive_destroy>

template <hal_spi_interface_t Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
 80a2a8a:	4770      	bx	lr
 80a2a8c:	2000056c 	.word	0x2000056c

080a2a90 <pinAvailable>:
/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
  if (pin >= TOTAL_PINS) {
 80a2a90:	2817      	cmp	r0, #23
bool pinAvailable(uint16_t pin) {
 80a2a92:	b570      	push	{r4, r5, r6, lr}
 80a2a94:	4604      	mov	r4, r0
  if (pin >= TOTAL_PINS) {
 80a2a96:	d901      	bls.n	80a2a9c <pinAvailable+0xc>
    return false;
 80a2a98:	2000      	movs	r0, #0
    return false; // 'pin' is used
  }
#endif

  return true; // 'pin' is available
}
 80a2a9a:	bd70      	pop	{r4, r5, r6, pc}
  if((pin == SCK || pin == MOSI || pin == MISO) && hal_spi_is_enabled(SPI.interface()) == true)
 80a2a9c:	f1a0 030d 	sub.w	r3, r0, #13
 80a2aa0:	2b02      	cmp	r3, #2
 80a2aa2:	d90b      	bls.n	80a2abc <pinAvailable+0x2c>
  if((pin == SCL || pin == SDA) && hal_i2c_is_enabled(Wire.interface(), nullptr) == true)
 80a2aa4:	2801      	cmp	r0, #1
 80a2aa6:	d824      	bhi.n	80a2af2 <pinAvailable+0x62>
 80a2aa8:	f000 f89e 	bl	80a2be8 <_Z19__fetch_global_Wirev>
 80a2aac:	2100      	movs	r1, #0
 80a2aae:	7c00      	ldrb	r0, [r0, #16]
 80a2ab0:	f7fe fe7a 	bl	80a17a8 <hal_i2c_is_enabled>
  if((pin == RX || pin == TX) && hal_usart_is_enabled(Serial1.interface()) == true)
 80a2ab4:	f080 0001 	eor.w	r0, r0, #1
 80a2ab8:	b2c0      	uxtb	r0, r0
 80a2aba:	e7ee      	b.n	80a2a9a <pinAvailable+0xa>
 80a2abc:	4e12      	ldr	r6, [pc, #72]	; (80a2b08 <pinAvailable+0x78>)
 80a2abe:	7831      	ldrb	r1, [r6, #0]
 80a2ac0:	f3bf 8f5b 	dmb	ish
 80a2ac4:	f011 0501 	ands.w	r5, r1, #1
 80a2ac8:	d10d      	bne.n	80a2ae6 <pinAvailable+0x56>
 80a2aca:	4630      	mov	r0, r6
 80a2acc:	f7fd fae9 	bl	80a00a2 <__cxa_guard_acquire>
 80a2ad0:	b148      	cbz	r0, 80a2ae6 <pinAvailable+0x56>
 80a2ad2:	4629      	mov	r1, r5
 80a2ad4:	480d      	ldr	r0, [pc, #52]	; (80a2b0c <pinAvailable+0x7c>)
 80a2ad6:	f7fe ffb5 	bl	80a1a44 <_ZN8SPIClassC1E19hal_spi_interface_t>
 80a2ada:	4630      	mov	r0, r6
 80a2adc:	f7fd fae6 	bl	80a00ac <__cxa_guard_release>
 80a2ae0:	480b      	ldr	r0, [pc, #44]	; (80a2b10 <pinAvailable+0x80>)
 80a2ae2:	f000 f8ac 	bl	80a2c3e <atexit>
  if((pin == SCK || pin == MOSI || pin == MISO) && hal_spi_is_enabled(SPI.interface()) == true)
 80a2ae6:	4b09      	ldr	r3, [pc, #36]	; (80a2b0c <pinAvailable+0x7c>)
 80a2ae8:	7818      	ldrb	r0, [r3, #0]
 80a2aea:	f7fe fe77 	bl	80a17dc <hal_spi_is_enabled>
 80a2aee:	2800      	cmp	r0, #0
 80a2af0:	d1d2      	bne.n	80a2a98 <pinAvailable+0x8>
  if((pin == RX || pin == TX) && hal_usart_is_enabled(Serial1.interface()) == true)
 80a2af2:	3c12      	subs	r4, #18
 80a2af4:	2c01      	cmp	r4, #1
 80a2af6:	d805      	bhi.n	80a2b04 <pinAvailable+0x74>
 80a2af8:	f7ff fe84 	bl	80a2804 <_Z22__fetch_global_Serial1v>
 80a2afc:	7c00      	ldrb	r0, [r0, #16]
 80a2afe:	f7fe fe1b 	bl	80a1738 <hal_usart_is_enabled>
 80a2b02:	e7d7      	b.n	80a2ab4 <pinAvailable+0x24>
  return true; // 'pin' is available
 80a2b04:	2001      	movs	r0, #1
 80a2b06:	e7c8      	b.n	80a2a9a <pinAvailable+0xa>
 80a2b08:	20000568 	.word	0x20000568
 80a2b0c:	2000056c 	.word	0x2000056c
 80a2b10:	080a2a81 	.word	0x080a2a81

080a2b14 <pinMode>:
  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a2b14:	2817      	cmp	r0, #23
{
 80a2b16:	b538      	push	{r3, r4, r5, lr}
 80a2b18:	4604      	mov	r4, r0
 80a2b1a:	460d      	mov	r5, r1
  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a2b1c:	d80a      	bhi.n	80a2b34 <pinMode+0x20>
 80a2b1e:	29ff      	cmp	r1, #255	; 0xff
 80a2b20:	d008      	beq.n	80a2b34 <pinMode+0x20>
  if( !pinAvailable(pin) ) {
 80a2b22:	f7ff ffb5 	bl	80a2a90 <pinAvailable>
 80a2b26:	b128      	cbz	r0, 80a2b34 <pinMode+0x20>
  HAL_Pin_Mode(pin, setMode);
 80a2b28:	4629      	mov	r1, r5
 80a2b2a:	4620      	mov	r0, r4
}
 80a2b2c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_Pin_Mode(pin, setMode);
 80a2b30:	f7fe bd8a 	b.w	80a1648 <HAL_Pin_Mode>
}
 80a2b34:	bd38      	pop	{r3, r4, r5, pc}

080a2b36 <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
 80a2b36:	b538      	push	{r3, r4, r5, lr}
 80a2b38:	4604      	mov	r4, r0
 80a2b3a:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a2b3c:	f7fe fd8c 	bl	80a1658 <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
 80a2b40:	28ff      	cmp	r0, #255	; 0xff
 80a2b42:	d010      	beq.n	80a2b66 <digitalWrite+0x30>
            mode == INPUT_PULLDOWN ||
 80a2b44:	2806      	cmp	r0, #6
 80a2b46:	d804      	bhi.n	80a2b52 <digitalWrite+0x1c>
 80a2b48:	234d      	movs	r3, #77	; 0x4d
 80a2b4a:	fa23 f000 	lsr.w	r0, r3, r0
 80a2b4e:	07c3      	lsls	r3, r0, #31
 80a2b50:	d409      	bmi.n	80a2b66 <digitalWrite+0x30>
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
 80a2b52:	4620      	mov	r0, r4
 80a2b54:	f7ff ff9c 	bl	80a2a90 <pinAvailable>
 80a2b58:	b128      	cbz	r0, 80a2b66 <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a2b5a:	4629      	mov	r1, r5
 80a2b5c:	4620      	mov	r0, r4
}
 80a2b5e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_GPIO_Write(pin, value);
 80a2b62:	f7fe bd81 	b.w	80a1668 <HAL_GPIO_Write>
}
 80a2b66:	bd38      	pop	{r3, r4, r5, pc}

080a2b68 <analogRead>:
 * @brief Read the analog value of a pin.
 * Should return a 16-bit value, 0-65536 (0 = LOW, 65536 = HIGH)
 * Note: ADC is 12-bit. Currently it returns 0-4095
 */
int32_t analogRead(pin_t pin)
{
 80a2b68:	b510      	push	{r4, lr}
 80a2b6a:	4604      	mov	r4, r0
  // Allow people to use 0-7 to define analog pins by checking to see if the values are too low.
  if(pin < FIRST_ANALOG_PIN)
 80a2b6c:	2809      	cmp	r0, #9
  {
    pin = pin + FIRST_ANALOG_PIN;
 80a2b6e:	bf9c      	itt	ls
 80a2b70:	340a      	addls	r4, #10
 80a2b72:	b2a4      	uxthls	r4, r4
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a2b74:	4620      	mov	r0, r4
 80a2b76:	f7ff ff8b 	bl	80a2a90 <pinAvailable>
 80a2b7a:	b150      	cbz	r0, 80a2b92 <analogRead+0x2a>
    return LOW;
  }

  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
 80a2b7c:	2103      	movs	r1, #3
 80a2b7e:	4620      	mov	r0, r4
 80a2b80:	f7fe fd5a 	bl	80a1638 <HAL_Validate_Pin_Function>
 80a2b84:	2803      	cmp	r0, #3
 80a2b86:	d104      	bne.n	80a2b92 <analogRead+0x2a>
  {
    return LOW;
  }

  return hal_adc_read(pin);
 80a2b88:	4620      	mov	r0, r4
}
 80a2b8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return hal_adc_read(pin);
 80a2b8e:	f7fe bd73 	b.w	80a1678 <hal_adc_read>
}
 80a2b92:	2000      	movs	r0, #0
 80a2b94:	bd10      	pop	{r4, pc}
	...

080a2b98 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

#if !HAL_USE_SOCKET_HAL_POSIX
const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a2b98:	2300      	movs	r3, #0
 80a2b9a:	b507      	push	{r0, r1, r2, lr}
 80a2b9c:	461a      	mov	r2, r3
 80a2b9e:	4619      	mov	r1, r3
 80a2ba0:	9300      	str	r3, [sp, #0]
 80a2ba2:	4803      	ldr	r0, [pc, #12]	; (80a2bb0 <_GLOBAL__sub_I_INADDR_NONE+0x18>)
 80a2ba4:	f7ff fd06 	bl	80a25b4 <_ZN9IPAddressC1Ehhhh>
 80a2ba8:	b003      	add	sp, #12
 80a2baa:	f85d fb04 	ldr.w	pc, [sp], #4
 80a2bae:	bf00      	nop
 80a2bb0:	2000057c 	.word	0x2000057c

080a2bb4 <__tcf_0>:
}
#endif

TwoWire& __fetch_global_Wire()
{
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a2bb4:	4770      	bx	lr
	...

080a2bb8 <_Z17acquireWireBufferv>:
	hal_i2c_config_t config = {
 80a2bb8:	2300      	movs	r3, #0
{
 80a2bba:	b570      	push	{r4, r5, r6, lr}
	hal_i2c_config_t config = {
 80a2bbc:	2520      	movs	r5, #32
 80a2bbe:	8043      	strh	r3, [r0, #2]
 80a2bc0:	2314      	movs	r3, #20
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a2bc2:	4e08      	ldr	r6, [pc, #32]	; (80a2be4 <_Z17acquireWireBufferv+0x2c>)
{
 80a2bc4:	4604      	mov	r4, r0
	hal_i2c_config_t config = {
 80a2bc6:	8003      	strh	r3, [r0, #0]
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a2bc8:	4631      	mov	r1, r6
	hal_i2c_config_t config = {
 80a2bca:	6085      	str	r5, [r0, #8]
 80a2bcc:	6105      	str	r5, [r0, #16]
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a2bce:	4628      	mov	r0, r5
 80a2bd0:	f000 f830 	bl	80a2c34 <_ZnajRKSt9nothrow_t>
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a2bd4:	4631      	mov	r1, r6
	};
 80a2bd6:	6060      	str	r0, [r4, #4]
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a2bd8:	4628      	mov	r0, r5
 80a2bda:	f000 f82b 	bl	80a2c34 <_ZnajRKSt9nothrow_t>
	};
 80a2bde:	60e0      	str	r0, [r4, #12]
}
 80a2be0:	4620      	mov	r0, r4
 80a2be2:	bd70      	pop	{r4, r5, r6, pc}
 80a2be4:	080a311c 	.word	0x080a311c

080a2be8 <_Z19__fetch_global_Wirev>:
{
 80a2be8:	b530      	push	{r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a2bea:	4d0e      	ldr	r5, [pc, #56]	; (80a2c24 <_Z19__fetch_global_Wirev+0x3c>)
{
 80a2bec:	b087      	sub	sp, #28
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a2bee:	7829      	ldrb	r1, [r5, #0]
 80a2bf0:	f3bf 8f5b 	dmb	ish
 80a2bf4:	f011 0401 	ands.w	r4, r1, #1
 80a2bf8:	d111      	bne.n	80a2c1e <_Z19__fetch_global_Wirev+0x36>
 80a2bfa:	4628      	mov	r0, r5
 80a2bfc:	f7fd fa51 	bl	80a00a2 <__cxa_guard_acquire>
 80a2c00:	b168      	cbz	r0, 80a2c1e <_Z19__fetch_global_Wirev+0x36>
 80a2c02:	a801      	add	r0, sp, #4
 80a2c04:	f7ff ffd8 	bl	80a2bb8 <_Z17acquireWireBufferv>
 80a2c08:	4621      	mov	r1, r4
 80a2c0a:	aa01      	add	r2, sp, #4
 80a2c0c:	4806      	ldr	r0, [pc, #24]	; (80a2c28 <_Z19__fetch_global_Wirev+0x40>)
 80a2c0e:	f7ff fe5d 	bl	80a28cc <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t>
 80a2c12:	4628      	mov	r0, r5
 80a2c14:	f7fd fa4a 	bl	80a00ac <__cxa_guard_release>
 80a2c18:	4804      	ldr	r0, [pc, #16]	; (80a2c2c <_Z19__fetch_global_Wirev+0x44>)
 80a2c1a:	f000 f810 	bl	80a2c3e <atexit>
	return wire;
}
 80a2c1e:	4802      	ldr	r0, [pc, #8]	; (80a2c28 <_Z19__fetch_global_Wirev+0x40>)
 80a2c20:	b007      	add	sp, #28
 80a2c22:	bd30      	pop	{r4, r5, pc}
 80a2c24:	20000594 	.word	0x20000594
 80a2c28:	20000598 	.word	0x20000598
 80a2c2c:	080a2bb5 	.word	0x080a2bb5

080a2c30 <_ZdlPvj>:
 80a2c30:	f7fd ba35 	b.w	80a009e <_ZdlPv>

080a2c34 <_ZnajRKSt9nothrow_t>:
 80a2c34:	f7fd ba31 	b.w	80a009a <_Znaj>

080a2c38 <_ZSt25__throw_bad_function_callv>:
 80a2c38:	b508      	push	{r3, lr}
 80a2c3a:	f7fe feeb 	bl	80a1a14 <abort>

080a2c3e <atexit>:
 80a2c3e:	2300      	movs	r3, #0
 80a2c40:	4601      	mov	r1, r0
 80a2c42:	461a      	mov	r2, r3
 80a2c44:	4618      	mov	r0, r3
 80a2c46:	f000 b8f9 	b.w	80a2e3c <__register_exitproc>

080a2c4a <atol>:
 80a2c4a:	220a      	movs	r2, #10
 80a2c4c:	2100      	movs	r1, #0
 80a2c4e:	f000 b8eb 	b.w	80a2e28 <strtol>

080a2c52 <memcpy>:
 80a2c52:	440a      	add	r2, r1
 80a2c54:	4291      	cmp	r1, r2
 80a2c56:	f100 33ff 	add.w	r3, r0, #4294967295
 80a2c5a:	d100      	bne.n	80a2c5e <memcpy+0xc>
 80a2c5c:	4770      	bx	lr
 80a2c5e:	b510      	push	{r4, lr}
 80a2c60:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a2c64:	4291      	cmp	r1, r2
 80a2c66:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a2c6a:	d1f9      	bne.n	80a2c60 <memcpy+0xe>
 80a2c6c:	bd10      	pop	{r4, pc}

080a2c6e <memset>:
 80a2c6e:	4603      	mov	r3, r0
 80a2c70:	4402      	add	r2, r0
 80a2c72:	4293      	cmp	r3, r2
 80a2c74:	d100      	bne.n	80a2c78 <memset+0xa>
 80a2c76:	4770      	bx	lr
 80a2c78:	f803 1b01 	strb.w	r1, [r3], #1
 80a2c7c:	e7f9      	b.n	80a2c72 <memset+0x4>
	...

080a2c80 <srand>:
 80a2c80:	b538      	push	{r3, r4, r5, lr}
 80a2c82:	4b0d      	ldr	r3, [pc, #52]	; (80a2cb8 <srand+0x38>)
 80a2c84:	4604      	mov	r4, r0
 80a2c86:	681d      	ldr	r5, [r3, #0]
 80a2c88:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80a2c8a:	b97b      	cbnz	r3, 80a2cac <srand+0x2c>
 80a2c8c:	2018      	movs	r0, #24
 80a2c8e:	f7fe fea9 	bl	80a19e4 <malloc>
 80a2c92:	4a0a      	ldr	r2, [pc, #40]	; (80a2cbc <srand+0x3c>)
 80a2c94:	4b0a      	ldr	r3, [pc, #40]	; (80a2cc0 <srand+0x40>)
 80a2c96:	63a8      	str	r0, [r5, #56]	; 0x38
 80a2c98:	e9c0 2300 	strd	r2, r3, [r0]
 80a2c9c:	4b09      	ldr	r3, [pc, #36]	; (80a2cc4 <srand+0x44>)
 80a2c9e:	2201      	movs	r2, #1
 80a2ca0:	6083      	str	r3, [r0, #8]
 80a2ca2:	230b      	movs	r3, #11
 80a2ca4:	8183      	strh	r3, [r0, #12]
 80a2ca6:	2300      	movs	r3, #0
 80a2ca8:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a2cac:	2200      	movs	r2, #0
 80a2cae:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80a2cb0:	611c      	str	r4, [r3, #16]
 80a2cb2:	615a      	str	r2, [r3, #20]
 80a2cb4:	bd38      	pop	{r3, r4, r5, pc}
 80a2cb6:	bf00      	nop
 80a2cb8:	20000014 	.word	0x20000014
 80a2cbc:	abcd330e 	.word	0xabcd330e
 80a2cc0:	e66d1234 	.word	0xe66d1234
 80a2cc4:	0005deec 	.word	0x0005deec

080a2cc8 <strcmp>:
 80a2cc8:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a2ccc:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a2cd0:	2a01      	cmp	r2, #1
 80a2cd2:	bf28      	it	cs
 80a2cd4:	429a      	cmpcs	r2, r3
 80a2cd6:	d0f7      	beq.n	80a2cc8 <strcmp>
 80a2cd8:	1ad0      	subs	r0, r2, r3
 80a2cda:	4770      	bx	lr

080a2cdc <strcpy>:
 80a2cdc:	4603      	mov	r3, r0
 80a2cde:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a2ce2:	f803 2b01 	strb.w	r2, [r3], #1
 80a2ce6:	2a00      	cmp	r2, #0
 80a2ce8:	d1f9      	bne.n	80a2cde <strcpy+0x2>
 80a2cea:	4770      	bx	lr

080a2cec <strdup>:
 80a2cec:	4b02      	ldr	r3, [pc, #8]	; (80a2cf8 <strdup+0xc>)
 80a2cee:	4601      	mov	r1, r0
 80a2cf0:	6818      	ldr	r0, [r3, #0]
 80a2cf2:	f000 b803 	b.w	80a2cfc <_strdup_r>
 80a2cf6:	bf00      	nop
 80a2cf8:	20000014 	.word	0x20000014

080a2cfc <_strdup_r>:
 80a2cfc:	b570      	push	{r4, r5, r6, lr}
 80a2cfe:	4604      	mov	r4, r0
 80a2d00:	4608      	mov	r0, r1
 80a2d02:	460d      	mov	r5, r1
 80a2d04:	f000 f80d 	bl	80a2d22 <strlen>
 80a2d08:	1c46      	adds	r6, r0, #1
 80a2d0a:	4631      	mov	r1, r6
 80a2d0c:	4620      	mov	r0, r4
 80a2d0e:	f7fe fe89 	bl	80a1a24 <_malloc_r>
 80a2d12:	4604      	mov	r4, r0
 80a2d14:	b118      	cbz	r0, 80a2d1e <_strdup_r+0x22>
 80a2d16:	4632      	mov	r2, r6
 80a2d18:	4629      	mov	r1, r5
 80a2d1a:	f7ff ff9a 	bl	80a2c52 <memcpy>
 80a2d1e:	4620      	mov	r0, r4
 80a2d20:	bd70      	pop	{r4, r5, r6, pc}

080a2d22 <strlen>:
 80a2d22:	4603      	mov	r3, r0
 80a2d24:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a2d28:	2a00      	cmp	r2, #0
 80a2d2a:	d1fb      	bne.n	80a2d24 <strlen+0x2>
 80a2d2c:	1a18      	subs	r0, r3, r0
 80a2d2e:	3801      	subs	r0, #1
 80a2d30:	4770      	bx	lr
	...

080a2d34 <_strtol_l.isra.0>:
 80a2d34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a2d38:	468c      	mov	ip, r1
 80a2d3a:	4686      	mov	lr, r0
 80a2d3c:	4e39      	ldr	r6, [pc, #228]	; (80a2e24 <_strtol_l.isra.0+0xf0>)
 80a2d3e:	4660      	mov	r0, ip
 80a2d40:	f81c 4b01 	ldrb.w	r4, [ip], #1
 80a2d44:	5da5      	ldrb	r5, [r4, r6]
 80a2d46:	f015 0508 	ands.w	r5, r5, #8
 80a2d4a:	d1f8      	bne.n	80a2d3e <_strtol_l.isra.0+0xa>
 80a2d4c:	2c2d      	cmp	r4, #45	; 0x2d
 80a2d4e:	d133      	bne.n	80a2db8 <_strtol_l.isra.0+0x84>
 80a2d50:	f04f 0801 	mov.w	r8, #1
 80a2d54:	f89c 4000 	ldrb.w	r4, [ip]
 80a2d58:	f100 0c02 	add.w	ip, r0, #2
 80a2d5c:	2b00      	cmp	r3, #0
 80a2d5e:	d05c      	beq.n	80a2e1a <_strtol_l.isra.0+0xe6>
 80a2d60:	2b10      	cmp	r3, #16
 80a2d62:	d10c      	bne.n	80a2d7e <_strtol_l.isra.0+0x4a>
 80a2d64:	2c30      	cmp	r4, #48	; 0x30
 80a2d66:	d10a      	bne.n	80a2d7e <_strtol_l.isra.0+0x4a>
 80a2d68:	f89c 0000 	ldrb.w	r0, [ip]
 80a2d6c:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80a2d70:	2858      	cmp	r0, #88	; 0x58
 80a2d72:	d14d      	bne.n	80a2e10 <_strtol_l.isra.0+0xdc>
 80a2d74:	2310      	movs	r3, #16
 80a2d76:	f89c 4001 	ldrb.w	r4, [ip, #1]
 80a2d7a:	f10c 0c02 	add.w	ip, ip, #2
 80a2d7e:	2600      	movs	r6, #0
 80a2d80:	f108 4700 	add.w	r7, r8, #2147483648	; 0x80000000
 80a2d84:	3f01      	subs	r7, #1
 80a2d86:	fbb7 f9f3 	udiv	r9, r7, r3
 80a2d8a:	4630      	mov	r0, r6
 80a2d8c:	fb03 7a19 	mls	sl, r3, r9, r7
 80a2d90:	f1a4 0530 	sub.w	r5, r4, #48	; 0x30
 80a2d94:	2d09      	cmp	r5, #9
 80a2d96:	d818      	bhi.n	80a2dca <_strtol_l.isra.0+0x96>
 80a2d98:	462c      	mov	r4, r5
 80a2d9a:	42a3      	cmp	r3, r4
 80a2d9c:	dd24      	ble.n	80a2de8 <_strtol_l.isra.0+0xb4>
 80a2d9e:	1c75      	adds	r5, r6, #1
 80a2da0:	d007      	beq.n	80a2db2 <_strtol_l.isra.0+0x7e>
 80a2da2:	4581      	cmp	r9, r0
 80a2da4:	d31d      	bcc.n	80a2de2 <_strtol_l.isra.0+0xae>
 80a2da6:	d101      	bne.n	80a2dac <_strtol_l.isra.0+0x78>
 80a2da8:	45a2      	cmp	sl, r4
 80a2daa:	db1a      	blt.n	80a2de2 <_strtol_l.isra.0+0xae>
 80a2dac:	2601      	movs	r6, #1
 80a2dae:	fb00 4003 	mla	r0, r0, r3, r4
 80a2db2:	f81c 4b01 	ldrb.w	r4, [ip], #1
 80a2db6:	e7eb      	b.n	80a2d90 <_strtol_l.isra.0+0x5c>
 80a2db8:	2c2b      	cmp	r4, #43	; 0x2b
 80a2dba:	bf08      	it	eq
 80a2dbc:	f89c 4000 	ldrbeq.w	r4, [ip]
 80a2dc0:	46a8      	mov	r8, r5
 80a2dc2:	bf08      	it	eq
 80a2dc4:	f100 0c02 	addeq.w	ip, r0, #2
 80a2dc8:	e7c8      	b.n	80a2d5c <_strtol_l.isra.0+0x28>
 80a2dca:	f1a4 0541 	sub.w	r5, r4, #65	; 0x41
 80a2dce:	2d19      	cmp	r5, #25
 80a2dd0:	d801      	bhi.n	80a2dd6 <_strtol_l.isra.0+0xa2>
 80a2dd2:	3c37      	subs	r4, #55	; 0x37
 80a2dd4:	e7e1      	b.n	80a2d9a <_strtol_l.isra.0+0x66>
 80a2dd6:	f1a4 0561 	sub.w	r5, r4, #97	; 0x61
 80a2dda:	2d19      	cmp	r5, #25
 80a2ddc:	d804      	bhi.n	80a2de8 <_strtol_l.isra.0+0xb4>
 80a2dde:	3c57      	subs	r4, #87	; 0x57
 80a2de0:	e7db      	b.n	80a2d9a <_strtol_l.isra.0+0x66>
 80a2de2:	f04f 36ff 	mov.w	r6, #4294967295
 80a2de6:	e7e4      	b.n	80a2db2 <_strtol_l.isra.0+0x7e>
 80a2de8:	1c73      	adds	r3, r6, #1
 80a2dea:	d106      	bne.n	80a2dfa <_strtol_l.isra.0+0xc6>
 80a2dec:	2322      	movs	r3, #34	; 0x22
 80a2dee:	4638      	mov	r0, r7
 80a2df0:	f8ce 3000 	str.w	r3, [lr]
 80a2df4:	b942      	cbnz	r2, 80a2e08 <_strtol_l.isra.0+0xd4>
 80a2df6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a2dfa:	f1b8 0f00 	cmp.w	r8, #0
 80a2dfe:	d000      	beq.n	80a2e02 <_strtol_l.isra.0+0xce>
 80a2e00:	4240      	negs	r0, r0
 80a2e02:	2a00      	cmp	r2, #0
 80a2e04:	d0f7      	beq.n	80a2df6 <_strtol_l.isra.0+0xc2>
 80a2e06:	b10e      	cbz	r6, 80a2e0c <_strtol_l.isra.0+0xd8>
 80a2e08:	f10c 31ff 	add.w	r1, ip, #4294967295
 80a2e0c:	6011      	str	r1, [r2, #0]
 80a2e0e:	e7f2      	b.n	80a2df6 <_strtol_l.isra.0+0xc2>
 80a2e10:	2430      	movs	r4, #48	; 0x30
 80a2e12:	2b00      	cmp	r3, #0
 80a2e14:	d1b3      	bne.n	80a2d7e <_strtol_l.isra.0+0x4a>
 80a2e16:	2308      	movs	r3, #8
 80a2e18:	e7b1      	b.n	80a2d7e <_strtol_l.isra.0+0x4a>
 80a2e1a:	2c30      	cmp	r4, #48	; 0x30
 80a2e1c:	d0a4      	beq.n	80a2d68 <_strtol_l.isra.0+0x34>
 80a2e1e:	230a      	movs	r3, #10
 80a2e20:	e7ad      	b.n	80a2d7e <_strtol_l.isra.0+0x4a>
 80a2e22:	bf00      	nop
 80a2e24:	080a311e 	.word	0x080a311e

080a2e28 <strtol>:
 80a2e28:	4613      	mov	r3, r2
 80a2e2a:	460a      	mov	r2, r1
 80a2e2c:	4601      	mov	r1, r0
 80a2e2e:	4802      	ldr	r0, [pc, #8]	; (80a2e38 <strtol+0x10>)
 80a2e30:	6800      	ldr	r0, [r0, #0]
 80a2e32:	f7ff bf7f 	b.w	80a2d34 <_strtol_l.isra.0>
 80a2e36:	bf00      	nop
 80a2e38:	20000014 	.word	0x20000014

080a2e3c <__register_exitproc>:
 80a2e3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80a2e40:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 80a2f00 <__register_exitproc+0xc4>
 80a2e44:	4606      	mov	r6, r0
 80a2e46:	f8d8 0000 	ldr.w	r0, [r8]
 80a2e4a:	461f      	mov	r7, r3
 80a2e4c:	460d      	mov	r5, r1
 80a2e4e:	4691      	mov	r9, r2
 80a2e50:	f000 f858 	bl	80a2f04 <__retarget_lock_acquire_recursive>
 80a2e54:	4b26      	ldr	r3, [pc, #152]	; (80a2ef0 <__register_exitproc+0xb4>)
 80a2e56:	681c      	ldr	r4, [r3, #0]
 80a2e58:	b934      	cbnz	r4, 80a2e68 <__register_exitproc+0x2c>
 80a2e5a:	4c26      	ldr	r4, [pc, #152]	; (80a2ef4 <__register_exitproc+0xb8>)
 80a2e5c:	601c      	str	r4, [r3, #0]
 80a2e5e:	4b26      	ldr	r3, [pc, #152]	; (80a2ef8 <__register_exitproc+0xbc>)
 80a2e60:	b113      	cbz	r3, 80a2e68 <__register_exitproc+0x2c>
 80a2e62:	681b      	ldr	r3, [r3, #0]
 80a2e64:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 80a2e68:	6863      	ldr	r3, [r4, #4]
 80a2e6a:	2b1f      	cmp	r3, #31
 80a2e6c:	dd07      	ble.n	80a2e7e <__register_exitproc+0x42>
 80a2e6e:	f8d8 0000 	ldr.w	r0, [r8]
 80a2e72:	f000 f849 	bl	80a2f08 <__retarget_lock_release_recursive>
 80a2e76:	f04f 30ff 	mov.w	r0, #4294967295
 80a2e7a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80a2e7e:	b35e      	cbz	r6, 80a2ed8 <__register_exitproc+0x9c>
 80a2e80:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 80a2e84:	b988      	cbnz	r0, 80a2eaa <__register_exitproc+0x6e>
 80a2e86:	4b1d      	ldr	r3, [pc, #116]	; (80a2efc <__register_exitproc+0xc0>)
 80a2e88:	b923      	cbnz	r3, 80a2e94 <__register_exitproc+0x58>
 80a2e8a:	f8d8 0000 	ldr.w	r0, [r8]
 80a2e8e:	f000 f83a 	bl	80a2f06 <__retarget_lock_release>
 80a2e92:	e7f0      	b.n	80a2e76 <__register_exitproc+0x3a>
 80a2e94:	f44f 7084 	mov.w	r0, #264	; 0x108
 80a2e98:	f7fe fda4 	bl	80a19e4 <malloc>
 80a2e9c:	2800      	cmp	r0, #0
 80a2e9e:	d0f4      	beq.n	80a2e8a <__register_exitproc+0x4e>
 80a2ea0:	2300      	movs	r3, #0
 80a2ea2:	e9c0 3340 	strd	r3, r3, [r0, #256]	; 0x100
 80a2ea6:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
 80a2eaa:	2201      	movs	r2, #1
 80a2eac:	6863      	ldr	r3, [r4, #4]
 80a2eae:	2e02      	cmp	r6, #2
 80a2eb0:	f840 9023 	str.w	r9, [r0, r3, lsl #2]
 80a2eb4:	fa02 f203 	lsl.w	r2, r2, r3
 80a2eb8:	eb00 0183 	add.w	r1, r0, r3, lsl #2
 80a2ebc:	f8d0 3100 	ldr.w	r3, [r0, #256]	; 0x100
 80a2ec0:	ea43 0302 	orr.w	r3, r3, r2
 80a2ec4:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
 80a2ec8:	f8c1 7080 	str.w	r7, [r1, #128]	; 0x80
 80a2ecc:	bf02      	ittt	eq
 80a2ece:	f8d0 3104 	ldreq.w	r3, [r0, #260]	; 0x104
 80a2ed2:	431a      	orreq	r2, r3
 80a2ed4:	f8c0 2104 	streq.w	r2, [r0, #260]	; 0x104
 80a2ed8:	6863      	ldr	r3, [r4, #4]
 80a2eda:	f8d8 0000 	ldr.w	r0, [r8]
 80a2ede:	1c5a      	adds	r2, r3, #1
 80a2ee0:	3302      	adds	r3, #2
 80a2ee2:	6062      	str	r2, [r4, #4]
 80a2ee4:	f844 5023 	str.w	r5, [r4, r3, lsl #2]
 80a2ee8:	f000 f80e 	bl	80a2f08 <__retarget_lock_release_recursive>
 80a2eec:	2000      	movs	r0, #0
 80a2eee:	e7c4      	b.n	80a2e7a <__register_exitproc+0x3e>
 80a2ef0:	20000638 	.word	0x20000638
 80a2ef4:	200005ac 	.word	0x200005ac
 80a2ef8:	00000000 	.word	0x00000000
 80a2efc:	080a19e5 	.word	0x080a19e5
 80a2f00:	20000078 	.word	0x20000078

080a2f04 <__retarget_lock_acquire_recursive>:
 80a2f04:	4770      	bx	lr

080a2f06 <__retarget_lock_release>:
 80a2f06:	4770      	bx	lr

080a2f08 <__retarget_lock_release_recursive>:
 80a2f08:	4770      	bx	lr

080a2f0a <link_code_end>:
	...

080a2f0c <dynalib_user>:
 80a2f0c:	001d 080a 005d 080a 0085 080a 0089 080a     ....]...........
 80a2f1c:	0000 0000 6573 5f74 6574 706d 6300 7275     ....set_temp.cur
 80a2f2c:	6572 746e 745f 6d65 0070 6564 6973 6572     rent_temp.desire
 80a2f3c:	5f64 6574 706d 6100 6862 7369 6574 706d     d_temp.abhistemp
 80a2f4c:	5200 6465 6f4d 6564 6c41 7265 0074 6552     .RedModeAlert.Re
 80a2f5c:	4d64 646f 4165 656c 7472 6920 2073 6e69     dModeAlert is in
 80a2f6c:	6120 7463 6f69 2e6e 4c20 4445 6920 2073      action. LED is 
 80a2f7c:	6f6e 2077 6874 2065 6f63 6f6c 2072 6552     now the color Re
 80a2f8c:	0064 4552 4d44 444f 4145 454c 5452 4900     d.REDMODEALERT.I
 80a2f9c:	766e 6c61 6469 4d20 646f 3a65 0020 6552     nvalid Mode: .Re
 80a2fac:	4d64 646f 2065 7369 6f20 006e               dMode is on.

080a2fb8 <CSWTCH.189>:
 80a2fb8:	012c 0000 0018 0000 01f4 0000 012c 0000     ,...........,...
 80a2fc8:	0050 0000 7061 0070 5925 252d 2d6d 6425     P...app.%Y-%m-%d
 80a2fd8:	2554 3a48 4d25 253a 2553 007a 7361 7463     T%H:%M:%S%z.asct
 80a2fe8:	6d69 0065                                   ime.

080a2fec <_ZTVSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE>:
	...
 80a2ff4:	1f7d 080a 1f83 080a 1fc1 080a 1f91 080a     }...............
 80a3004:	1f7f 080a                                   ....

080a3008 <_ZTV9IPAddress>:
	...
 80a3010:	2515 080a 2505 080a 2507 080a               .%...%...%..

080a301c <_ZTV9USBSerial>:
	...
 80a3024:	25d3 080a 2639 080a 2611 080a 1cd7 080a     .%..9&...&......
 80a3034:	2603 080a 25d5 080a 25e5 080a 2633 080a     .&...%...%..3&..
 80a3044:	25f5 080a 25cd 080a                         .%...%..

080a304c <_ZTV11USARTSerial>:
	...
 80a3054:	2761 080a 27cb 080a 27a7 080a 1cd7 080a     a'...'...'......
 80a3064:	2777 080a 2793 080a 2785 080a 27a1 080a     w'...'...'...'..
 80a3074:	2763 080a 2769 080a                         c'..i'..

080a307c <_ZTV7TwoWire>:
	...
 80a3084:	2875 080a 28bf 080a 2897 080a 2877 080a     u(...(...(..w(..
 80a3094:	289f 080a 28a7 080a 28af 080a 28b7 080a     .(...(...(...(..

080a30a4 <_ZTVN5spark9WiFiClassE>:
	...
 80a30ac:	2987 080a 297d 080a 2973 080a 28f1 080a     .)..})..s)...(..
 80a30bc:	1d97 080a 2967 080a 29e5 080a 29ed 080a     ....g)...)...)..
 80a30cc:	295b 080a 2953 080a 2949 080a 293f 080a     [)..S)..I)..?)..
 80a30dc:	28fb 080a                                   .(..

080a30e0 <_ZTVN5spark12NetworkClassE>:
	...
 80a30e8:	29a5 080a 29af 080a 29b9 080a 29c3 080a     .)...)...)...)..
 80a30f8:	29cd 080a 29d9 080a 29e5 080a 29ed 080a     .)...)...)...)..
 80a3108:	29f5 080a 2a01 080a 2a09 080a 2a13 080a     .)...*...*...*..
 80a3118:	2a1d 080a                                   .*..

080a311c <_ZSt7nothrow>:
	...

080a311d <_ctype_>:
 80a311d:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
 80a312d:	2020 2020 2020 2020 2020 2020 2020 2020                     
 80a313d:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
 80a314d:	0410 0404 0404 0404 0404 1004 1010 1010     ................
 80a315d:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
 80a316d:	0101 0101 0101 0101 0101 0101 1010 1010     ................
 80a317d:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
 80a318d:	0202 0202 0202 0202 0202 0202 1010 1010     ................
 80a319d:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...

080a321e <link_const_variable_data_end>:
	...

080a3220 <link_constructors_location>:
 80a3220:	080a02e5 	.word	0x080a02e5
 80a3224:	080a1619 	.word	0x080a1619
 80a3228:	080a1a65 	.word	0x080a1a65
 80a322c:	080a1db1 	.word	0x080a1db1
 80a3230:	080a1dc1 	.word	0x080a1dc1
 80a3234:	080a1e11 	.word	0x080a1e11
 80a3238:	080a2991 	.word	0x080a2991
 80a323c:	080a2a6d 	.word	0x080a2a6d
 80a3240:	080a2b99 	.word	0x080a2b99

080a3244 <link_constructors_end>:
	...
